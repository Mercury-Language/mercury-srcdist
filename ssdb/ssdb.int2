:- module ssdb.
:- interface.
:- use_module list.
:- type debugging_paused.
:- type list_var_value == list.list(ssdb.var_value).
:- type pos == int.
:- type ssdb_event_type
    --->    ssdb_call 
    ;       ssdb_exit 
    ;       ssdb_fail 
    ;       ssdb_call_nondet 
    ;       ssdb_exit_nondet 
    ;       ssdb_redo_nondet 
    ;       ssdb_fail_nondet 
    ;       ssdb_excp .
:- type ssdb_proc_id
    --->    ssdb_proc_id((ssdb.module_name) :: string, (ssdb.proc_name) :: string).
:- type ssdb_retry
    --->    do_retry 
    ;       do_not_retry .
:- type ssdb_tracing_level
    --->    deep 
    ;       shallow .
:- type var_name == string.
:- type var_value
    --->    unbound_head_var(ssdb.var_name, ssdb.pos)
    ;       some [T] (bound_head_var(ssdb.var_name, ssdb.pos, T))
    ;       some [T] (bound_other_var(ssdb.var_name, T)).
:- type_representation(breakpoints_map, is_eqv_to(map.map(ssdb.ssdb_proc_id, ssdb.breakpoint))).
:- type_representation(debugging_paused, is_eqv_to(ssdb.debugger_state)).
:- type_representation(list_var_value, is_eqv_to(list.list(ssdb.var_value))).
:- type_representation(pos, is_eqv_to(int)).
:- type_representation(ssdb_event_type, du_repn(enum("ssdb_call", "ssdb_exit", ["ssdb_fail", "ssdb_call_nondet", "ssdb_exit_nondet", "ssdb_redo_nondet", "ssdb_fail_nondet", "ssdb_excp"],  no_c_j_cs))).
:- type_representation(ssdb_proc_id, is_word_aligned_ptr).
:- type_representation(ssdb_retry, du_repn(enum("do_retry", "do_not_retry", [],  no_c_j_cs))).
:- type_representation(ssdb_tracing_level, du_repn(enum("deep", "shallow", [],  no_c_j_cs))).
:- type_representation(var_name, is_eqv_to(string)).
:- implementation.
:- type debugger_state
	where	type_is_abstract_enum(1).
:- type debugging_paused == ssdb.debugger_state.
