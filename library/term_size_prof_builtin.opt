:- module term_size_prof_builtin.
:- use_module builtin, private_builtin, require.
:- pragma foreign_import_module("C", term_size_prof_builtin).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("Erlang", io).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("Erlang", io).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("IL", bitmap).
:- pragma foreign_import_module("Erlang", bitmap).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("IL", bitmap).
:- pragma foreign_import_module("Erlang", bitmap).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
:- pragma foreign_import_module("Erlang", time).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
:- pragma foreign_import_module("Erlang", time).
:- pragma foreign_proc("C", term_size_prof_builtin.measure_size(Term :: (builtin.in), Size :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "{
#ifdef MR_RECORD_TERM_SIZES
    MR_TypeInfo type_info;

    type_info = (MR_TypeInfo) TypeInfo_for_T;
    Size = MR_term_size(type_info, Term);
  #ifdef MR_DEBUG_TERM_SIZES
    if (MR_heapdebug && MR_lld_print_enabled) {
        printf(\"measure_size: %p -> %d\\n\",
            (void *) Term, (int) Size);
    }
  #endif
#else
    MR_fatal_error(\"measure_size: term size profiling not enabled\");
#endif
}").
:- pragma foreign_proc("C", term_size_prof_builtin.measure_size_acc(Term :: (builtin.in), Size0 :: (builtin.in), Size :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "{
#ifdef MR_RECORD_TERM_SIZES
    MR_TypeInfo type_info;

    type_info = (MR_TypeInfo) TypeInfo_for_T;
    Size = MR_term_size(type_info, Term) + Size0;
  #ifdef MR_DEBUG_TERM_SIZES
    if (MR_heapdebug && MR_lld_print_enabled) {
        printf(\"measure_size_acc: %p + %d -> %d\\n\",
            (void *) Term, (int) Size0, (int) Size);
    }
  #endif
#else
    MR_fatal_error(\"measure_size_acc: term size profiling not enabled\");
#endif
}").
:- pragma exceptions(predicate, (term_size_prof_builtin.measure_size), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (term_size_prof_builtin.measure_size_acc), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (term_size_prof_builtin.increment_size), 2, 0, will_not_throw).
:- pragma exceptions(function, (term_size_prof_builtin.term_size_plus), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (term_size_prof_builtin.complexity_is_active), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (term_size_prof_builtin.complexity_call_proc), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (term_size_prof_builtin.complexity_exit_proc), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (term_size_prof_builtin.complexity_fail_proc), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (term_size_prof_builtin.complexity_redo_proc), 1, 0, will_not_throw).
:- pragma termination_info(term_size_prof_builtin.measure_size((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(term_size_prof_builtin.measure_size_acc((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(term_size_prof_builtin.increment_size((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(term_size_prof_builtin.term_size_plus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(term_size_prof_builtin.complexity_is_active((builtin.out)), infinite, cannot_loop).
:- pragma termination_info(term_size_prof_builtin.complexity_call_proc((builtin.out)), infinite, cannot_loop).
:- pragma termination_info(term_size_prof_builtin.complexity_exit_proc((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(term_size_prof_builtin.complexity_fail_proc((builtin.in)), infinite, cannot_loop).
:- pragma termination_info(term_size_prof_builtin.complexity_redo_proc((builtin.in)), infinite, cannot_loop).
