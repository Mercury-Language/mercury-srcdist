:- module hash_table.
:- interface.
:- import_module array.
:- import_module assoc_list.
:- import_module char.
:- type hash_pred(K) == pred(K, int).
:- type hash_table(K, V)
    --->    ht((hash_table.num_occupants) :: int, (hash_table.max_occupants) :: int, (hash_table.hash_pred) :: hash_table.hash_pred(K), (hash_table.buckets) :: array.array(hash_table.hash_table_alist(K, V))).
:- type hash_table(K, V).
:- inst (hash_pred) == (pred((builtin.in), (builtin.out)) is det).
:- inst (hash_table) == bound(ht(ground, ground, (hash_table.hash_pred), (array.array))).
:- mode (hash_table_di) == builtin.di((hash_table.hash_table)).
:- mode (hash_table_ui) == builtin.in((hash_table.hash_table)).
:- mode (hash_table_uo) == builtin.out((hash_table.hash_table)).
:- pragma obsolete((hash_table.new)/3).
:- pragma obsolete((hash_table.new_default)/1).
:- pred char_hash(char.char, int).
:- mode char_hash((builtin.in), (builtin.out)) is det.
:- func copy(hash_table.hash_table(K, V)) = hash_table.hash_table(K, V).
:- mode copy((hash_table.hash_table_ui)) = (hash_table.hash_table_uo) is det.
:- func delete(hash_table.hash_table(K, V), K) = hash_table.hash_table(K, V).
:- mode delete((hash_table.hash_table_di), (builtin.in)) = (hash_table.hash_table_uo) is det.
:- pred delete(K, hash_table.hash_table(K, V), hash_table.hash_table(K, V)).
:- mode delete((builtin.in), (hash_table.hash_table_di), (hash_table.hash_table_uo)) is det.
:- func det_insert(hash_table.hash_table(K, V), K, V) = hash_table.hash_table(K, V).
:- mode det_insert((hash_table.hash_table_di), (builtin.in), (builtin.in)) = (hash_table.hash_table_uo) is det.
:- pred det_insert(K, V, hash_table.hash_table(K, V), hash_table.hash_table(K, V)).
:- mode det_insert((builtin.in), (builtin.in), (hash_table.hash_table_di), (hash_table.hash_table_uo)) is det.
:- func det_update(hash_table.hash_table(K, V), K, V) = hash_table.hash_table(K, V).
:- mode det_update((hash_table.hash_table_di), (builtin.in), (builtin.in)) = (hash_table.hash_table_uo) is det.
:- pred det_update(K, V, hash_table.hash_table(K, V), hash_table.hash_table(K, V)).
:- mode det_update((builtin.in), (builtin.in), (hash_table.hash_table_di), (hash_table.hash_table_uo)) is det.
:- func elem(K, hash_table.hash_table(K, V)) = V.
:- mode elem((builtin.in), (hash_table.hash_table_ui)) = (builtin.out) is det.
:- func 'elem :='(K, hash_table.hash_table(K, V), V) = hash_table.hash_table(K, V).
:- mode 'elem :='((builtin.in), (hash_table.hash_table_di), (builtin.in)) = (hash_table.hash_table_uo) is det.
:- pred float_hash(float, int).
:- mode float_hash((builtin.in), (builtin.out)) is det.
:- func fold((func(K, V, T) = T), hash_table.hash_table(K, V), T) = T.
:- mode fold((func((builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det), (hash_table.hash_table_ui), (builtin.in)) = (builtin.out) is det.
:- mode fold((func((builtin.in), (builtin.in), (builtin.di)) = (builtin.uo) is det), (hash_table.hash_table_ui), (builtin.di)) = (builtin.uo) is det.
:- pred fold(pred(K, V, T, T), hash_table.hash_table(K, V), T, T).
:- mode fold(builtin.in((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (hash_table.hash_table_ui), (builtin.in), (builtin.out)) is det.
:- mode fold(builtin.in((pred((builtin.in), (builtin.in), (builtin.mdi), (builtin.muo)) is det)), (hash_table.hash_table_ui), (builtin.mdi), (builtin.muo)) is det.
:- mode fold(builtin.in((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (hash_table.hash_table_ui), (builtin.di), (builtin.uo)) is det.
:- mode fold(builtin.in((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet)), (hash_table.hash_table_ui), (builtin.in), (builtin.out)) is semidet.
:- mode fold(builtin.in((pred((builtin.in), (builtin.in), (builtin.mdi), (builtin.muo)) is semidet)), (hash_table.hash_table_ui), (builtin.mdi), (builtin.muo)) is semidet.
:- mode fold(builtin.in((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is semidet)), (hash_table.hash_table_ui), (builtin.di), (builtin.uo)) is semidet.
:- func from_assoc_list(hash_table.hash_pred(K), int, float, assoc_list.assoc_list(K, V)) = hash_table.hash_table(K, V).
:- mode from_assoc_list(builtin.in((hash_table.hash_pred)), (builtin.in), (builtin.in), (builtin.in)) = (hash_table.hash_table_uo) is det.
:- func from_assoc_list(hash_table.hash_pred(K), assoc_list.assoc_list(K, V)) = hash_table.hash_table(K, V).
:- mode from_assoc_list(builtin.in((hash_table.hash_pred)), (builtin.in)) = (hash_table.hash_table_uo) is det.
:- pred generic_hash(T, int).
:- mode generic_hash((builtin.in), (builtin.out)) is det.
:- func hash_pred(hash_table.hash_table(K, V)) = hash_table.hash_pred(K).
:- mode hash_pred((hash_table.hash_table_ui)) = builtin.out((hash_table.hash_pred)) is det.
:- func init(hash_table.hash_pred(K), int, float) = hash_table.hash_table(K, V).
:- mode init(builtin.in((hash_table.hash_pred)), (builtin.in), (builtin.in)) = (hash_table.hash_table_uo) is det.
:- func init_default(hash_table.hash_pred(K)) = hash_table.hash_table(K, V).
:- mode init_default(builtin.in((hash_table.hash_pred))) = (hash_table.hash_table_uo) is det.
:- pred int_hash(int, int).
:- mode int_hash((builtin.in), (builtin.out)) is det.
:- func lookup(hash_table.hash_table(K, V), K) = V.
:- mode lookup((hash_table.hash_table_ui), (builtin.in)) = (builtin.out) is det.
:- func new(hash_table.hash_pred(K), int, float) = hash_table.hash_table(K, V).
:- mode new(builtin.in((hash_table.hash_pred)), (builtin.in), (builtin.in)) = (hash_table.hash_table_uo) is det.
:- func new_default(hash_table.hash_pred(K)) = hash_table.hash_table(K, V).
:- mode new_default(builtin.in((hash_table.hash_pred))) = (hash_table.hash_table_uo) is det.
:- func num_buckets(hash_table.hash_table(K, V)) = int.
:- mode num_buckets((hash_table.hash_table_ui)) = (builtin.out) is det.
:- func num_occupants(hash_table.hash_table(K, V)) = int.
:- mode num_occupants((hash_table.hash_table_ui)) = (builtin.out) is det.
:- func search(hash_table.hash_table(K, V), K) = V.
:- mode search((hash_table.hash_table_ui), (builtin.in)) = (builtin.out) is semidet.
:- pred search(hash_table.hash_table(K, V), K, V).
:- mode search((hash_table.hash_table_ui), (builtin.in), (builtin.out)) is semidet.
:- func set(hash_table.hash_table(K, V), K, V) = hash_table.hash_table(K, V).
:- mode set((hash_table.hash_table_di), (builtin.in), (builtin.in)) = (hash_table.hash_table_uo) is det.
:- pred set(K, V, hash_table.hash_table(K, V), hash_table.hash_table(K, V)).
:- mode set((builtin.in), (builtin.in), (hash_table.hash_table_di), (hash_table.hash_table_uo)) is det.
:- pred string_hash(string, int).
:- mode string_hash((builtin.in), (builtin.out)) is det.
:- func to_assoc_list(hash_table.hash_table(K, V)) = assoc_list.assoc_list(K, V).
:- mode to_assoc_list((hash_table.hash_table_ui)) = (builtin.out) is det.
