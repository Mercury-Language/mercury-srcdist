:- module eqvclass.
:- use_module builtin.
:- use_module counter.
:- use_module int.
:- use_module list.
:- use_module map.
:- use_module private_builtin.
:- use_module require.
:- use_module set.

:- type eqvclass(T)
    --->    eqvclass((eqvclass.next_id_counter) :: counter.counter, (eqvclass.partition_map) :: tree234.tree234(int, set_ordlist.set_ordlist(T)), (eqvclass.element_map) :: tree234.tree234(T, int)).
:- type partition_id == int.

:- pred eqvclass.divide_equivalence_classes_2(((func T) = U), int, set_ordlist.set_ordlist(T), counter.counter, counter.counter, tree234.tree234(int, set_ordlist.set_ordlist(T)), tree234.tree234(int, set_ordlist.set_ordlist(T)), tree234.tree234(T, int), tree234.tree234(T, int)).
:- mode divide_equivalence_classes_2((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- pred eqvclass.divide_equivalence_classes_3(((func T) = U), int, T, tree234.tree234(U, int), tree234.tree234(U, int), counter.counter, counter.counter, tree234.tree234(int, set_ordlist.set_ordlist(T)), tree234.tree234(int, set_ordlist.set_ordlist(T)), tree234.tree234(T, int), tree234.tree234(T, int)).
:- mode divide_equivalence_classes_3((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- pred eqvclass.partition_ids(eqvclass.eqvclass(T), list.list(int)).
:- mode partition_ids((builtin.in), (builtin.out)) is det.
:- pred eqvclass.partitions(eqvclass.eqvclass(T), list.list(int), list.list(set_ordlist.set_ordlist(T))).
:- mode partitions((builtin.in), (builtin.in), (builtin.out)) is det.

eqvclass.divide_equivalence_classes(V_4, V_5) = V_6 :-
    V_5 = eqvclass.eqvclass(V_7, V_8, V_9) : eqvclass.eqvclass(T_1),
    V_13 = eqvclass.divide_equivalence_classes_2(V_4) : pred(int, set_ordlist.set_ordlist(T_1), counter.counter, counter.counter, tree234.tree234(int, set_ordlist.set_ordlist(T_1)), tree234.tree234(int, set_ordlist.set_ordlist(T_1)), tree234.tree234(T_1, int), tree234.tree234(T_1, int)),
    V_14 = V_8,
    map.foldl3(V_13, V_8, V_7, V_10, V_14, V_11, V_9, V_12),
    V_6 = eqvclass.eqvclass(V_10, V_11, V_12) : eqvclass.eqvclass(T_1).

eqvclass.divide_equivalence_classes_2(V_10, V_11, V_12, V_22, V_23, V_24, V_25, V_26, V_27) :-
    set.to_sorted_list(V_12, V_16),
    ( % disjunction
      V_16 = list.[] : list.list(T_1),
      V_28 = "predicate `eqvclass.divide_equivalence_classes_2\'/9" : string,
      V_29 = "empty partition" : string,
      require.unexpected(V_28, V_29),
      V_23 = V_22,
      V_25 = V_24,
      V_27 = V_26
    ;
      V_16 = list.[V_17 | V_18] : list.list(T_1),
      V_19 = apply(V_10, V_17),
      V_20 = map.singleton(V_19, V_11),
      V_30 = eqvclass.divide_equivalence_classes_3(V_10, V_11) : pred(T_1, tree234.tree234(U_2, int), tree234.tree234(U_2, int), counter.counter, counter.counter, tree234.tree234(int, set_ordlist.set_ordlist(T_1)), tree234.tree234(int, set_ordlist.set_ordlist(T_1)), tree234.tree234(T_1, int), tree234.tree234(T_1, int)),
      list.foldl4(V_30, V_18, V_20, V_21, V_22, V_23, V_24, V_25, V_26, V_27)
    ).

eqvclass.divide_equivalence_classes_3(V_12, V_13, V_14, V_26, V_27, V_28, V_29, V_30, V_31, V_32, V_33) :-
    V_19 = apply(V_12, V_14),
    ( if
      map.search(V_26, V_19, V_20)
    then
      ( if
        V_20 = V_13
      then
        V_33 = V_32,
        V_31 = V_30
      else
        map.lookup(V_30, V_13, V_21),
        set.delete(V_14, V_21, V_22),
        map.det_update(V_13, V_22, V_30, V_34),
        map.lookup(V_34, V_20, V_23),
        set.insert(V_14, V_23, V_24),
        map.det_update(V_20, V_24, V_34, V_31),
        map.det_update(V_14, V_20, V_32, V_33)
      ),
      V_29 = V_28,
      V_27 = V_26
    else
      counter.allocate(V_25, V_28, V_29),
      map.det_insert(V_19, V_25, V_26, V_27),
      map.lookup(V_30, V_13, V_42),
      set.delete(V_14, V_42, V_43),
      map.det_update(V_13, V_43, V_30, V_39),
      V_44 = set.make_singleton_set(V_14),
      map.det_insert(V_25, V_44, V_39, V_31),
      map.det_update(V_14, V_25, V_32, V_33)
    ).

eqvclass.ensure_corresponding_equivalences(V_5, V_6, V_7) = V_8 :-
    eqvclass.ensure_corresponding_equivalences(V_5, V_6, V_7, V_8).

eqvclass.ensure_element(V_6, V_5) = V_7 :-
    eqvclass.ensure_element(V_5, V_6, V_7).

eqvclass.ensure_element(V_4, V_7, V_8) :-
    eqvclass.ensure_element_partition_id(V_4, V_6, V_7, V_8).

eqvclass.ensure_equivalence(V_8, V_6, V_7) = V_9 :-
    eqvclass.ensure_equivalence(V_6, V_7, V_8, V_9).

eqvclass.get_minimum_element(V_4, V_5) = V_6 :-
    V_7 = eqvclass.get_equivalent_elements(V_4, V_5),
    V_6 = list.det_head(V_8),
    V_8 = set.to_sorted_list(V_7).

eqvclass.init = V_2 :-
    eqvclass.init(V_2).

eqvclass.is_member(V_3, V_4) :-
    V_3 = eqvclass.eqvclass(V_7, V_8, V_5) : eqvclass.eqvclass(T_1),
    map.search(V_5, V_4, V_6).

eqvclass.new_element(V_6, V_5) = V_7 :-
    eqvclass.new_element(V_5, V_6, V_7).

eqvclass.new_equivalence(V_8, V_6, V_7) = V_9 :-
    eqvclass.new_equivalence(V_6, V_7, V_8, V_9).

eqvclass.partition_id(V_4, V_5, V_6) :-
    V_4 = eqvclass.eqvclass(V_8, V_9, V_7) : eqvclass.eqvclass(T_1),
    map.search(V_7, V_5, V_6).

eqvclass.partition_ids(V_3, V_4) :-
    V_3 = eqvclass.eqvclass(V_6, V_5, V_7) : eqvclass.eqvclass(T_1),
    map.keys(V_5, V_4).

eqvclass.partition_list(V_3) = V_4 :-
    eqvclass.partition_list(V_3, V_4).

eqvclass.partition_list(V_3, V_4) :-
    eqvclass.partition_ids(V_3, V_5),
    eqvclass.partitions(V_3, V_5, V_4).

eqvclass.partition_list_to_eqvclass(V_3) = V_4 :-
    eqvclass.partition_list_to_eqvclass(V_3, V_4).

eqvclass.partition_set(V_3) = V_4 :-
    eqvclass.partition_set(V_3, V_4).

eqvclass.partition_set(V_3, V_4) :-
    eqvclass.partition_ids(V_3, V_5),
    eqvclass.partitions(V_3, V_5, V_6),
    set.list_to_set(V_6, V_4).

eqvclass.partition_set_to_eqvclass(V_3) = V_4 :-
    eqvclass.partition_set_to_eqvclass(V_3, V_4).

eqvclass.partition_set_to_eqvclass(V_3, V_4) :-
    set.to_sorted_list(V_3, V_5),
    eqvclass.partition_list_to_eqvclass(V_5, V_4).

eqvclass.remove_equivalent_elements(V_4, V_5) = V_6 :-
    eqvclass.remove_equivalent_elements(V_5, V_4, V_6).

eqvclass.same_eqvclass(V_4, V_5, V_6) :-
    V_4 = eqvclass.eqvclass(V_10, V_11, V_7) : eqvclass.eqvclass(T_1),
    map.search(V_7, V_5, V_8),
    map.search(V_7, V_6, V_9),
    V_8 = V_9.

:- pragma termination_info(eqvclass.divide_equivalence_classes((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.divide_equivalence_classes_2((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.divide_equivalence_classes_3((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.ensure_corresponding_equivalences((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.ensure_corresponding_equivalences((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.ensure_element((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.ensure_element((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.ensure_element_partition_id((builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.ensure_equivalence((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.ensure_equivalence((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.get_equivalent_elements((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.get_minimum_element((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((eqvclass.init) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.init((builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.is_member((builtin.in), (builtin.in)), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(eqvclass.new_element((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.new_element((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.new_equivalence((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.new_equivalence((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_id((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_ids((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_list((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_list((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_list_to_eqvclass((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_list_to_eqvclass((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_set((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_set((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_set_to_eqvclass((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.partition_set_to_eqvclass((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.partitions((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.remove_equivalent_elements((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(eqvclass.remove_equivalent_elements((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(eqvclass.same_eqvclass((builtin.in), (builtin.in), (builtin.in)), finite(0, [no, no, no, no]), can_loop).
:- pragma termination_info(eqvclass.same_eqvclass_list((builtin.in), (builtin.in)), finite(0, [no, no, no]), can_loop).

:- pragma exceptions(function, (eqvclass.divide_equivalence_classes), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.divide_equivalence_classes_2), 9, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.divide_equivalence_classes_3), 11, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.ensure_corresponding_equivalences), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.ensure_corresponding_equivalences), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.ensure_element), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.ensure_element), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.ensure_element_partition_id), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.ensure_equivalence), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.ensure_equivalence), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.get_equivalent_elements), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.get_minimum_element), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.init), 0, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.init), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.is_member), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.new_element), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.new_element), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.new_equivalence), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.new_equivalence), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.partition_id), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.partition_ids), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.partition_list), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.partition_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.partition_list_to_eqvclass), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.partition_list_to_eqvclass), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.partition_set), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.partition_set), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.partition_set_to_eqvclass), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.partition_set_to_eqvclass), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.partitions), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (eqvclass.remove_equivalent_elements), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.remove_equivalent_elements), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.same_eqvclass), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (eqvclass.same_eqvclass_list), 2, 0, may_throw(user_exception)).
