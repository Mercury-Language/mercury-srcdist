:- module array.
:- interface.
:- type array(T).
:- type index_out_of_bounds
    --->    index_out_of_bounds(string).
:- inst (array) == array.array(ground).
:- inst (array(I)) == ground.
:- inst (mostly_uniq_array) == array.mostly_uniq_array(ground).
:- inst (mostly_uniq_array(I)) == array.array(I).
:- inst (uniq_array) == array.uniq_array(ground).
:- inst (uniq_array(I)) == array.array(I).
:- mode (array_di) == builtin.di((array.uniq_array)).
:- mode (array_mdi) == builtin.mdi((array.mostly_uniq_array)).
:- mode (array_mui) == builtin.in((array.mostly_uniq_array)).
:- mode (array_muo) == builtin.out((array.mostly_uniq_array)).
:- mode (array_ui) == builtin.in((array.uniq_array)).
:- mode (array_uo) == builtin.out((array.uniq_array)).
:- type_representation(array.index_out_of_bounds, du_repn(notag("index_out_of_bounds", []))).
:- implementation.
:- pragma foreign_import_module("C", array).
:- pragma foreign_import_module("C#", array).
:- pragma foreign_import_module("Java", array).
:- pragma foreign_import_module("Erlang", array).
:- pragma foreign_type(c, array(T), "MR_ArrayPtr")
    where   type_is_abstract_noncanonical.
:- pragma foreign_type(java, array(T), "/* Array */ java.lang.Object")
    where   type_is_abstract_noncanonical.
:- pragma foreign_type(csharp, array(T), "System.Array")
    where   type_is_abstract_noncanonical.
:- pragma foreign_type(erlang, array(T), "")
    where   type_is_abstract_noncanonical.
