:- module int.
:- use_module array.
:- use_module builtin.
:- use_module enum.
:- use_module exception.
:- use_module pretty_printer.
:- use_module private_builtin.
:- use_module string.
:- use_module uint.

:- pragma foreign_import_module("C", array).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("C", int).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("C", stm_builtin).
:- pragma foreign_import_module("C", store).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("C", (io.stream_ops)).
:- pragma foreign_import_module("C#", array).
:- pragma foreign_import_module("C#", bitmap).
:- pragma foreign_import_module("C#", int).
:- pragma foreign_import_module("C#", io).
:- pragma foreign_import_module("C#", store).
:- pragma foreign_import_module("C#", (io.stream_ops)).
:- pragma foreign_import_module("Java", array).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("Java", int).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("Java", store).
:- pragma foreign_import_module("Java", (io.stream_ops)).

:- instance (enum.enum(int)).

:- pred (int.int_domain_checks).
:- mode int_domain_checks is semidet.
:- pragma inline(pred((int.int_domain_checks)/0)).

:- pragma inline(func((int.(/))/2)).
int.(V_4 / V_5) = V_3 :-
    V_3 = int.(V_4 // V_5).

:- pragma inline(func((int.(//))/2)).
int.(V_4 // V_5) = V_6 :-
    ( if
      int.int_domain_checks,
      V_5 = 0 : int
    then
      V_7 = exception.domain_error(V_8) : exception.domain_error,
      V_8 = "int.\'//\': division by zero" : string,
      exception.throw(V_7)
    else
      V_6 = int.unchecked_quotient(V_4, V_5)
    ).

int.abs(V_3) = V_4 :-
    int.abs(V_3, V_4).

int.all_true_in_range(V_4, V_5, V_6) :-
    ( if
      int.(V_5 =< V_6)
    then
      call(V_4, V_5),
      V_7 = int.(V_5 + V_8),
      V_8 = 1 : int,
      int.all_true_in_range(V_4, V_7, V_6)
    else
      true
    ).

int.bits_per_int = V_2 :-
    int.bits_per_int(V_2).

:- pragma foreign_proc("C", int.bits_per_int(Bits :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    Bits = ML_BITS_PER_INT;
").

:- pragma inline(pred((int.even)/1)).
int.even(V_2) :-
    V_3 = int.(V_2 /\ V_4),
    V_4 = 1 : int,
    V_3 = 0 : int.

:- pragma inline(func((int.floor_to_multiple_of_bits_per_int)/1)).
int.floor_to_multiple_of_bits_per_int(V_3) = V_4 :-
    V_5 = int.quot_bits_per_int(V_3),
    V_6 = int.times_bits_per_int(V_5),
    ( if
      int.(V_6 > V_3)
    then
      V_4 = int.(V_6 - V_7),
      V_7 = int.bits_per_int
    else
      V_4 = V_6
    ).

int.fold_down(V_6, V_7, V_8, V_9) = V_5 :-
    ( if
      int.(V_7 =< V_8)
    then
      V_5 = int.fold_down(V_6, V_7, V_10, V_12),
      V_10 = int.(V_8 - V_11),
      V_11 = 1 : int,
      V_12 = apply(V_6, V_8, V_9)
    else
      V_5 = V_9
    ).

int.fold_down(V_6, V_7, V_8, V_10, V_11) :-
    ( if
      int.(V_7 =< V_8)
    then
      call(V_6, V_8, V_10, V_12),
      V_13 = int.(V_8 - V_15),
      V_15 = 1 : int,
      int.fold_down(V_6, V_7, V_13, V_12, V_11)
    else
      V_11 = V_10
    ).

int.fold_down2(V_8, V_9, V_10, V_13, V_14, V_15, V_16) :-
    ( if
      int.(V_9 =< V_10)
    then
      call(V_8, V_10, V_13, V_17, V_15, V_18),
      V_19 = int.(V_10 - V_22),
      V_22 = 1 : int,
      int.fold_down2(V_8, V_9, V_19, V_17, V_14, V_18, V_16)
    else
      V_16 = V_15,
      V_14 = V_13
    ).

int.fold_down3(V_10, V_11, V_12, V_16, V_17, V_18, V_19, V_20, V_21) :-
    ( if
      int.(V_11 =< V_12)
    then
      call(V_10, V_12, V_16, V_22, V_18, V_23, V_20, V_24),
      V_25 = int.(V_12 - V_29),
      V_29 = 1 : int,
      int.fold_down3(V_10, V_11, V_25, V_22, V_17, V_23, V_19, V_24, V_21)
    else
      V_21 = V_20,
      V_19 = V_18,
      V_17 = V_16
    ).

int.fold_up(V_6, V_7, V_8, V_9) = V_5 :-
    ( if
      int.(V_7 =< V_8)
    then
      V_5 = int.fold_up(V_6, V_10, V_8, V_12),
      V_10 = int.(V_7 + V_11),
      V_11 = 1 : int,
      V_12 = apply(V_6, V_7, V_9)
    else
      V_5 = V_9
    ).

int.fold_up(V_6, V_7, V_8, V_10, V_11) :-
    ( if
      int.(V_7 =< V_8)
    then
      call(V_6, V_7, V_10, V_12),
      V_13 = int.(V_7 + V_15),
      V_15 = 1 : int,
      int.fold_up(V_6, V_13, V_8, V_12, V_11)
    else
      V_11 = V_10
    ).

int.fold_up2(V_8, V_9, V_10, V_13, V_14, V_15, V_16) :-
    ( if
      int.(V_9 =< V_10)
    then
      call(V_8, V_9, V_13, V_17, V_15, V_18),
      V_19 = int.(V_9 + V_22),
      V_22 = 1 : int,
      int.fold_up2(V_8, V_19, V_10, V_17, V_14, V_18, V_16)
    else
      V_16 = V_15,
      V_14 = V_13
    ).

int.fold_up3(V_10, V_11, V_12, V_16, V_17, V_18, V_19, V_20, V_21) :-
    ( if
      int.(V_11 =< V_12)
    then
      call(V_10, V_11, V_16, V_22, V_18, V_23, V_20, V_24),
      V_25 = int.(V_11 + V_29),
      V_29 = 1 : int,
      int.fold_up3(V_10, V_25, V_12, V_22, V_17, V_23, V_19, V_24, V_21)
    else
      V_21 = V_20,
      V_19 = V_18,
      V_17 = V_16
    ).

int.hash(V_3) = V_4 :-
    V_5 = uint.cast_from_int(V_3),
    V_4 = uint.hash(V_5).

int.hash(V_3, V_4) :-
    V_4 = int.hash(V_3).

:- pragma inline(pred((int.int_domain_checks)/0)).
:- pragma foreign_proc("C", int.int_domain_checks, [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
#ifdef ML_OMIT_MATH_DOMAIN_CHECKS
    SUCCESS_INDICATOR = MR_FALSE;
#else
    SUCCESS_INDICATOR = MR_TRUE;
#endif
").

int.int_to_doc(V_3) = pretty_printer.str(V_4) :-
    V_4 = string.int_to_string(V_3).

int.log2(V_3) = V_4 :-
    int.log2(V_3, V_4).

int.max(V_4, V_5) = V_6 :-
    int.max(V_4, V_5, V_6).

int.max(V_4, V_5, V_6) :-
    ( if
      int.(V_4 > V_5)
    then
      V_6 = V_4
    else
      V_6 = V_5
    ).

int.max_int = V_2 :-
    int.max_int(V_2).

:- pragma foreign_proc("C", int.max_int(Max :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    if (sizeof(MR_Integer) == sizeof(int)) {
        Max = INT_MAX;
    } else if (sizeof(MR_Integer) == sizeof(long)) {
        Max = (MR_Integer) LONG_MAX;
    #if defined(LLONG_MAX)
    } else if (sizeof(MR_Integer) == sizeof(long long)) {
        Max = (MR_Integer) LLONG_MAX;
    #endif
    } else {
        MR_fatal_error(\"Unable to figure out max integer size\");
    }
").

int.min(V_4, V_5) = V_6 :-
    int.min(V_4, V_5, V_6).

int.min(V_4, V_5, V_6) :-
    ( if
      int.(V_4 < V_5)
    then
      V_6 = V_4
    else
      V_6 = V_5
    ).

int.min_int = V_2 :-
    int.min_int(V_2).

:- pragma foreign_proc("C", int.min_int(Min :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    if (sizeof(MR_Integer) == sizeof(int)) {
        Min = INT_MIN;
    } else if (sizeof(MR_Integer) == sizeof(long)) {
        Min = (MR_Integer) LONG_MIN;
    #if defined(LLONG_MIN)
    } else if (sizeof(MR_Integer) == sizeof(long long)) {
        Min = (MR_Integer) LLONG_MIN;
    #endif
    } else {
        MR_fatal_error(\"Unable to figure out min integer size\");
    }
").

int.(V_4 mod V_5) = V_3 :-
    V_3 = int.(V_4 - V_6),
    V_6 = int.(V_7 * V_5),
    V_7 = int.(V_4 div V_5).

int.nabs(V_3) = V_2 :-
    ( if
      V_4 = 0 : int,
      int.(V_3 > V_4)
    then
      V_2 = int.(- V_3)
    else
      V_2 = V_3
    ).

:- pragma inline(pred((int.odd)/1)).
int.odd(V_2) :-
    not (
      V_3 = int.(V_2 /\ V_4),
      V_4 = 1 : int,
      V_3 = 0 : int
    ).

int.pow(V_4, V_5) = V_6 :-
    int.pow(V_4, V_5, V_6).

:- promise all [A, B, C] (
  not (
    C = int.(B + A),
    not (
      C = int.(A + B)
    )
  ),
  not (
    C = int.(A + B),
    not (
      C = int.(B + A)
    )
  )
).

:- promise all [A, B, C, ABC] (
  not (
    ABC = int.(V_5 + C),
    V_5 = int.(A + B),
    not (
      ABC = int.(A + V_6),
      V_6 = int.(B + C)
    )
  ),
  not (
    ABC = int.(A + V_8),
    V_8 = int.(B + C),
    not (
      ABC = int.(V_7 + C),
      V_7 = int.(A + B)
    )
  )
).

:- promise all [A, B, C] (
  not (
    C = int.(B * A),
    not (
      C = int.(A * B)
    )
  ),
  not (
    C = int.(A * B),
    not (
      C = int.(B * A)
    )
  )
).

:- promise all [A, B, C, ABC] (
  not (
    ABC = int.(V_5 * C),
    V_5 = int.(A * B),
    not (
      ABC = int.(A * V_6),
      V_6 = int.(B * C)
    )
  ),
  not (
    ABC = int.(A * V_8),
    V_8 = int.(B * C),
    not (
      ABC = int.(V_7 * C),
      V_7 = int.(A * B)
    )
  )
).

:- pragma foreign_proc("C", int.quot_bits_per_int(Int :: (builtin.in)) = (Div :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    Div = Int / ML_BITS_PER_INT;
").

:- pragma inline(func((int.(rem))/2)).
int.(V_4 rem V_5) = V_6 :-
    ( if
      int.int_domain_checks,
      V_5 = 0 : int
    then
      V_7 = exception.domain_error(V_8) : exception.domain_error,
      V_8 = "int.rem: division by zero" : string,
      exception.throw(V_7)
    else
      V_6 = int.unchecked_rem(V_4, V_5)
    ).

:- pragma foreign_proc("C", int.rem_bits_per_int(Int :: (builtin.in)) = (Rem :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    Rem = Int % ML_BITS_PER_INT;
").

:- pragma foreign_proc("C", int.times_bits_per_int(Int :: (builtin.in)) = (Result :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    Result = Int * ML_BITS_PER_INT;
").

:- pragma termination_info(int.'*'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.'+'((builtin.in)) = (builtin.uo), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(int.'+'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.'+'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.'+'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.'-'((builtin.in)) = (builtin.uo), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(int.'-'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.'-'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.'-'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.'/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(int.'//'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(int.'/\\'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.'<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(int.'<<'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(int.'=<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(int.'>'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(int.'>='((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(int.'>>'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(int.'ClassMethod_for_enum__enum____int__arity0______enum__from_int_1'((builtin.in)) = (builtin.out), finite(0, [yes, no]), cannot_loop).
:- pragma termination_info(int.'ClassMethod_for_enum__enum____int__arity0______enum__to_int_1'((builtin.in)) = (builtin.out), finite(0, [yes, no]), cannot_loop).
:- pragma termination_info(int.'\\'((builtin.in)) = (builtin.uo), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(int.'\\/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.abs((builtin.in)) = (builtin.out), finite(0, [yes, no]), can_loop).
:- pragma termination_info(int.abs((builtin.in), (builtin.out)), finite(0, [yes, no]), can_loop).
:- pragma termination_info(int.all_true_in_range(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in)), infinite, can_loop).
:- pragma termination_info((int.bits_per_int) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(int.bits_per_int((builtin.out)), infinite, cannot_loop).
:- pragma termination_info(int.div((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(int.even((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(int.floor_to_multiple_of_bits_per_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(int.fold_down((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.mdi), (builtin.muo)) is det) >> (pred((builtin.in), (builtin.mdi), (builtin.muo)) is det)), (builtin.in), (builtin.in), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (array.array_di), (array.array_uo)) is det) >> (pred((builtin.in), (array.array_di), (array.array_uo)) is det)), (builtin.in), (builtin.in), (array.array_di), (array.array_uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.mdi), (builtin.muo)) is semidet) >> (pred((builtin.in), (builtin.mdi), (builtin.muo)) is semidet)), (builtin.in), (builtin.in), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.di), (builtin.uo)) is semidet) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is semidet)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.in), (builtin.out)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.mdi), (builtin.muo)) is nondet) >> (pred((builtin.in), (builtin.mdi), (builtin.muo)) is nondet)), (builtin.in), (builtin.in), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.in), (builtin.out)) is cc_multi) >> (pred((builtin.in), (builtin.in), (builtin.out)) is cc_multi)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down(((pred((builtin.in), (builtin.di), (builtin.uo)) is cc_multi) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is cc_multi)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_down2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down2(((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down2(((pred((builtin.in), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_down3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_up((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.mdi), (builtin.muo)) is det) >> (pred((builtin.in), (builtin.mdi), (builtin.muo)) is det)), (builtin.in), (builtin.in), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (array.array_di), (array.array_uo)) is det) >> (pred((builtin.in), (array.array_di), (array.array_uo)) is det)), (builtin.in), (builtin.in), (array.array_di), (array.array_uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.mdi), (builtin.muo)) is semidet) >> (pred((builtin.in), (builtin.mdi), (builtin.muo)) is semidet)), (builtin.in), (builtin.in), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.di), (builtin.uo)) is semidet) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is semidet)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.in), (builtin.out)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.mdi), (builtin.muo)) is nondet) >> (pred((builtin.in), (builtin.mdi), (builtin.muo)) is nondet)), (builtin.in), (builtin.in), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.di), (builtin.uo)) is cc_multi) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is cc_multi)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up(((pred((builtin.in), (builtin.in), (builtin.out)) is cc_multi) >> (pred((builtin.in), (builtin.in), (builtin.out)) is cc_multi)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up2(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (array.array_di), (array.array_uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(int.fold_up3(((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is nondet) >> (pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is nondet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)), infinite, can_loop).
:- pragma termination_info(int.hash((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(int.hash((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info((int.int_domain_checks), finite(0, []), cannot_loop).
:- pragma termination_info(int.int_to_doc((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(int.log2((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(int.log2((builtin.in), (builtin.out)), finite(0, [no, no]), can_loop).
:- pragma termination_info(int.max((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info(int.max((builtin.in), (builtin.in), (builtin.out)), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info((int.max_int) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(int.max_int((builtin.out)), infinite, cannot_loop).
:- pragma termination_info(int.min((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info(int.min((builtin.in), (builtin.in), (builtin.out)), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info((int.min_int) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(int.min_int((builtin.out)), infinite, cannot_loop).
:- pragma termination_info(int.minus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.mod((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(int.nabs((builtin.in)) = (builtin.out), finite(0, [yes, no]), cannot_loop).
:- pragma termination_info(int.nondet_int_in_range((builtin.in), (builtin.in), (builtin.out)), finite(0, [yes, no, no]), can_loop).
:- pragma termination_info(int.odd((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(int.plus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.pow((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(int.pow((builtin.in), (builtin.in), (builtin.out)), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(int.quot_bits_per_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(int.rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(int.rem_bits_per_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(int.times((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.times_bits_per_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(int.unchecked_abs((builtin.in)) = (builtin.out), finite(0, [yes, no]), cannot_loop).
:- pragma termination_info(int.unchecked_left_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.unchecked_quotient((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.unchecked_rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.unchecked_right_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.xor((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.xor((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(int.xor((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).

:- pragma exceptions(function, (int.(*)), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.(+)), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.(+)), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.(+)), 2, 1, will_not_throw).
:- pragma exceptions(function, (int.(+)), 2, 2, will_not_throw).
:- pragma exceptions(function, (int.(-)), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.(-)), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.(-)), 2, 1, will_not_throw).
:- pragma exceptions(function, (int.(-)), 2, 2, will_not_throw).
:- pragma exceptions(function, (int.(/)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (int.(//)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (int.(/\)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (int.(<)), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.(<<)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.(=<)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (int.(>)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (int.(>=)), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.(>>)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (int.(\)), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.(\/)), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.abs), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.abs), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.all_true_in_range), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (int.bits_per_int), 0, 0, will_not_throw).
:- pragma exceptions(predicate, (int.bits_per_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.(div)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.even), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.floor_to_multiple_of_bits_per_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.fold_down), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 6, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 7, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 8, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 9, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down), 5, 10, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down2), 7, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down2), 7, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down2), 7, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down2), 7, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down2), 7, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down2), 7, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down2), 7, 6, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down2), 7, 7, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down2), 7, 8, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 6, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 7, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 8, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_down3), 9, 9, may_throw(user_exception)).
:- pragma exceptions(function, (int.fold_up), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 6, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 7, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 8, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 9, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up), 5, 10, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 6, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 7, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 8, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up2), 7, 9, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 6, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 7, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 8, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.fold_up3), 9, 9, may_throw(user_exception)).
:- pragma exceptions(function, (int.hash), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.hash), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.int_domain_checks), 0, 0, will_not_throw).
:- pragma exceptions(function, (int.int_to_doc), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (int.log2), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.log2), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (int.max), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (int.max), 3, 0, will_not_throw).
:- pragma exceptions(function, (int.max_int), 0, 0, will_not_throw).
:- pragma exceptions(predicate, (int.max_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.min), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (int.min), 3, 0, will_not_throw).
:- pragma exceptions(function, (int.min_int), 0, 0, will_not_throw).
:- pragma exceptions(predicate, (int.min_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.minus), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.(mod)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (int.nabs), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (int.nondet_int_in_range), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (int.odd), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.plus), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.pow), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (int.pow), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (int.quot_bits_per_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.(rem)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (int.rem_bits_per_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.times), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.times_bits_per_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.unchecked_abs), 1, 0, will_not_throw).
:- pragma exceptions(function, (int.unchecked_left_shift), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.unchecked_quotient), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.unchecked_rem), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.unchecked_right_shift), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.xor), 2, 0, will_not_throw).
:- pragma exceptions(function, (int.xor), 2, 1, will_not_throw).
:- pragma exceptions(function, (int.xor), 2, 2, will_not_throw).
