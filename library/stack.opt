:- module stack.
:- use_module builtin, list, private_builtin, require.
:- type stack.stack(T)
	--->	stack(list.list(T)).
stack.init(stack.stack(V_2)) :-
    V_2 = list.[] : list.list(T_1).
stack.init = S_2 :-
    stack.init(S_2).
stack.is_empty(stack.stack(V_2)) :-
    V_2 = list.[] : list.list(T_1).
stack.is_full(V_2) :-
    builtin.semidet_fail.
stack.push(stack.stack(Elems_4), Elem_5, stack.stack(V_6)) :-
    V_6 = list.[Elem_5 | Elems_4] : list.list(T_1).
stack.push(S1_4, X_5) = S2_6 :-
    stack.push(S1_4, X_5, S2_6).
stack.push_list(S1_4, Xs_5) = S2_6 :-
    stack.push_list(S1_4, Xs_5, S2_6).
stack.top(stack.stack(V_5), Elem_3) :-
    V_5 = list.[Elem_3 | V_4] : list.list(T_1).
stack.top_det(S_3) = X_4 :-
    stack.top_det(S_3, X_4).
stack.det_top(S_3) = X_4 :-
    stack.top_det(S_3, X_4).
stack.pop(stack.stack(V_6), Elem_4, stack.stack(Elems_5)) :-
    V_6 = list.[Elem_4 | Elems_5] : list.list(T_1).
stack.det_pop(Stack0_4, Elem_5, Stack_6) :-
    stack.pop_det(Stack0_4, Elem_5, Stack_6).
stack.depth(stack.stack(Elems_3), Depth_4) :-
    list.length(Elems_3, Depth_4).
stack.depth(S_3) = N_4 :-
    stack.depth(S_3, N_4).
:- pragma exceptions(predicate, (stack.init), 1, 0, will_not_throw).
:- pragma exceptions(function, (stack.init), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (stack.is_empty), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (stack.is_full), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (stack.push), 3, 0, will_not_throw).
:- pragma exceptions(function, (stack.push), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (stack.push_list), 3, 0, will_not_throw).
:- pragma exceptions(function, (stack.push_list), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (stack.top), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (stack.top_det), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (stack.top_det), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (stack.det_top), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (stack.pop), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (stack.pop_det), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (stack.det_pop), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (stack.depth), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (stack.depth), 2, 0, may_throw(user_exception)).
:- pragma termination_info(stack.init((builtin.out)), finite(1, [no, no]), cannot_loop).
:- pragma termination_info((stack.init) = (builtin.out), finite(1, [no, no]), cannot_loop).
:- pragma termination_info(stack.is_empty((builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(stack.is_full((builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(stack.push((builtin.in), (builtin.in), (builtin.out)), finite(2, [no, yes, yes, no]), cannot_loop).
:- pragma termination_info(stack.push((builtin.in), (builtin.in)) = (builtin.out), finite(2, [no, yes, yes, no]), cannot_loop).
:- pragma termination_info(stack.push_list((builtin.in), (builtin.in), (builtin.out)), finite(0, [no, yes, yes, no]), can_loop).
:- pragma termination_info(stack.push_list((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, yes, yes, no]), can_loop).
:- pragma termination_info(stack.top((builtin.in), (builtin.out)), finite(-3, [no, yes, no]), cannot_loop).
:- pragma termination_info(stack.top_det((builtin.in), (builtin.out)), finite(-3, [no, yes, no]), can_loop).
:- pragma termination_info(stack.top_det((builtin.in)) = (builtin.out), finite(-3, [no, yes, no]), can_loop).
:- pragma termination_info(stack.det_top((builtin.in)) = (builtin.out), finite(-3, [no, yes, no]), can_loop).
:- pragma termination_info(stack.pop((builtin.in), (builtin.out), (builtin.out)), finite(-2, [no, yes, no, no]), cannot_loop).
:- pragma termination_info(stack.pop_det((builtin.in), (builtin.out), (builtin.out)), finite(-2, [no, yes, no, no]), can_loop).
:- pragma termination_info(stack.det_pop((builtin.in), (builtin.out), (builtin.out)), finite(-2, [no, yes, no, no]), can_loop).
:- pragma termination_info(stack.depth((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(stack.depth((builtin.in)) = (builtin.out), infinite, can_loop).
