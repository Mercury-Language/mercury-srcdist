:- module uint8.
:- use_module builtin.
:- use_module exception.
:- use_module int.
:- use_module pretty_printer.
:- use_module private_builtin.
:- use_module require.
:- use_module string.
:- use_module uint.

:- pragma foreign_import_module("C", array).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("C", stm_builtin).
:- pragma foreign_import_module("C", store).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("C", uint8).
:- pragma foreign_import_module("C", (io.stream_ops)).
:- pragma foreign_import_module("C#", array).
:- pragma foreign_import_module("C#", bitmap).
:- pragma foreign_import_module("C#", io).
:- pragma foreign_import_module("C#", store).
:- pragma foreign_import_module("C#", uint8).
:- pragma foreign_import_module("C#", (io.stream_ops)).
:- pragma foreign_import_module("Java", array).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("Java", store).
:- pragma foreign_import_module("Java", uint8).
:- pragma foreign_import_module("Java", (io.stream_ops)).

:- pragma inline(func((uint8.(/))/2)).
uint8.(V_4 / V_5) = V_3 :-
    V_3 = uint8.(V_4 // V_5).

:- pragma inline(func((uint8.(//))/2)).
uint8.(V_4 // V_5) = V_6 :-
    ( if
      V_5 = 0u8 : uint8
    then
      V_7 = exception.domain_error(V_8) : exception.domain_error,
      V_8 = "uint8.\'//\': division by zero" : string,
      exception.throw(V_7)
    else
      V_6 = uint8.unchecked_quotient(V_4, V_5)
    ).

:- pragma foreign_proc("C", uint8.cast_from_int(I :: (builtin.in)) = (U8 :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U8 = (uint8_t) I;
").

:- pragma foreign_proc("C", uint8.cast_from_int8(I8 :: (builtin.in)) = (U8 :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U8 = (uint8_t) I8;
").

:- pragma foreign_proc("C", uint8.cast_from_uint(U :: (builtin.in)) = (U8 :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U8 = (uint8_t) U;
").

:- pragma foreign_proc("C", uint8.cast_to_int(U8 :: (builtin.in)) = (I :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    I = U8;
").

:- pragma foreign_proc("C", uint8.cast_to_uint(U8 :: (builtin.in)) = (U :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U = (MR_Unsigned) U8;
").

uint8.(V_4 div V_5) = V_3 :-
    V_3 = uint8.(V_4 // V_5).

:- pragma inline(pred((uint8.even)/1)).
uint8.even(V_2) :-
    V_3 = uint8.(V_2 /\ V_4),
    V_4 = 1u8 : uint8,
    V_3 = 0u8 : uint8.

uint8.from_uint(V_3, V_4) :-
    V_5 = 255u : uint,
    uint.(V_3 =< V_5),
    V_4 = uint8.cast_from_uint(V_3).

uint8.max(V_4, V_5) = V_3 :-
    ( if
      uint8.(V_4 > V_5)
    then
      V_3 = V_4
    else
      V_3 = V_5
    ).

uint8.max_uint8 = 255u8.

uint8.min(V_4, V_5) = V_3 :-
    ( if
      uint8.(V_4 < V_5)
    then
      V_3 = V_4
    else
      V_3 = V_5
    ).

uint8.(V_4 mod V_5) = V_3 :-
    V_3 = uint8.(V_4 rem V_5).

:- pragma foreign_proc("C", uint8.num_leading_zeros(I :: (builtin.in)) = (N :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    N = ML_uint8_nlz_table[I];
").

:- pragma foreign_proc("C", uint8.num_ones(U :: (builtin.in)) = (N :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    N = ML_uint8_num_ones_table[U];
").

uint8.num_zeros(V_3) = V_2 :-
    V_2 = int.(V_4 - V_5),
    V_4 = 8 : int,
    V_5 = uint8.num_ones(V_3).

:- pragma inline(pred((uint8.odd)/1)).
uint8.odd(V_2) :-
    not (
      V_3 = uint8.(V_2 /\ V_4),
      V_4 = 1u8 : uint8,
      V_3 = 0u8 : uint8
    ).

:- pragma inline(func((uint8.(rem))/2)).
uint8.(V_4 rem V_5) = V_6 :-
    ( if
      V_5 = 0u8 : uint8
    then
      V_7 = exception.domain_error(V_8) : exception.domain_error,
      V_8 = "uint8.rem: division by zero" : string,
      exception.throw(V_7)
    else
      V_6 = uint8.unchecked_rem(V_4, V_5)
    ).

:- pragma foreign_proc("C", uint8.to_int(U8 :: (builtin.in)) = (I :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    I = U8;
").

uint8.uint8_to_doc(V_3) = pretty_printer.str(V_4) :-
    V_4 = string.uint8_to_string(V_3).

uint8.unchecked_clear_bit(V_4, V_5) = V_3 :-
    V_3 = uint8.(V_4 /\ V_6),
    V_6 = uint8.(\ V_7),
    V_7 = uint8.unchecked_left_shift(V_8, V_9),
    V_8 = 1u8 : uint8,
    V_9 = uint.cast_to_int(V_5).

uint8.unchecked_flip_bit(V_4, V_5) = V_3 :-
    V_3 = uint8.xor(V_4, V_6),
    V_6 = uint8.unchecked_left_shift(V_7, V_8),
    V_7 = 1u8 : uint8,
    V_8 = uint.cast_to_int(V_5).

:- pragma foreign_proc("C", uint8.unchecked_rotate_left(X :: (builtin.in), N :: (builtin.in)) = (Result :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "
    N &= 7;
    // XXX clang has intrinsics for rotation -- we should use those instead.
    Result = (X << N) | (X >> (-N & 7));
").

:- pragma foreign_proc("C", uint8.unchecked_rotate_right(X :: (builtin.in), N :: (builtin.in)) = (Result :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "
    N &= 7;
    Result = (X >> N) | (X << (-N & 7));
").

uint8.unchecked_set_bit(V_4, V_5) = V_3 :-
    V_3 = uint8.(V_4 \/ V_6),
    V_6 = uint8.unchecked_left_shift(V_7, V_8),
    V_7 = 1u8 : uint8,
    V_8 = uint.cast_to_int(V_5).

:- pragma termination_info(uint8.'*'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.'+'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.'+'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.'+'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.'-'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.'-'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.'-'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.'/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.'//'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.'/\\'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.'<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint8.'<<'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.'=<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint8.'>'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint8.'>='((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint8.'>>'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.'\\'((builtin.in)) = (builtin.uo), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint8.'\\/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.bit_is_clear((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(uint8.bit_is_set((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(uint8.cast_from_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.cast_from_int8((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.cast_from_uint((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.cast_to_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.cast_to_uint((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.clear_bit((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.det_from_int((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(uint8.det_from_uint((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(uint8.div((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.even((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint8.flip_bit((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.from_int((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(uint8.from_uint((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(uint8.max((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info((uint8.max_uint8) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint8.min((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info(uint8.minus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.mod((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.num_leading_zeros((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.num_ones((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.num_trailing_zeros((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint8.num_zeros((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint8.odd((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint8.plus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.reverse_bits((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(uint8.rotate_left((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(uint8.rotate_right((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(uint8.set_bit((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.times((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.to_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.uint8_to_doc((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(uint8.unchecked_bit_is_clear((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(uint8.unchecked_bit_is_set((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(uint8.unchecked_clear_bit((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.unchecked_flip_bit((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.unchecked_left_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.unchecked_quotient((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.unchecked_rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.unchecked_right_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.unchecked_rotate_left((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.unchecked_rotate_right((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint8.unchecked_set_bit((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint8.xor((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.xor((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint8.xor((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).

:- pragma exceptions(function, (uint8.(*)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.(+)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.(+)), 2, 1, will_not_throw).
:- pragma exceptions(function, (uint8.(+)), 2, 2, will_not_throw).
:- pragma exceptions(function, (uint8.(-)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.(-)), 2, 1, will_not_throw).
:- pragma exceptions(function, (uint8.(-)), 2, 2, will_not_throw).
:- pragma exceptions(function, (uint8.(/)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.(//)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.(/\)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint8.(<)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.(<<)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint8.(=<)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint8.(>)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint8.(>=)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.(>>)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.(\)), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.(\/)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint8.bit_is_clear), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint8.bit_is_set), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.cast_from_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.cast_from_int8), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.cast_from_uint), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.cast_to_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.cast_to_uint), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.clear_bit), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.det_from_int), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.det_from_uint), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.(div)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint8.even), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.flip_bit), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint8.from_int), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint8.from_uint), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.max), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.max_uint8), 0, 0, will_not_throw).
:- pragma exceptions(function, (uint8.min), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.minus), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.(mod)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.num_leading_zeros), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.num_ones), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.num_trailing_zeros), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.num_zeros), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (uint8.odd), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.plus), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.(rem)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.reverse_bits), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.rotate_left), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.rotate_right), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.set_bit), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.times), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.to_int), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint8.uint8_to_doc), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint8.unchecked_bit_is_clear), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint8.unchecked_bit_is_set), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.unchecked_clear_bit), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.unchecked_flip_bit), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.unchecked_left_shift), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.unchecked_quotient), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.unchecked_rem), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.unchecked_right_shift), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.unchecked_rotate_left), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.unchecked_rotate_right), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.unchecked_set_bit), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint8.xor), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint8.xor), 2, 1, will_not_throw).
:- pragma exceptions(function, (uint8.xor), 2, 2, will_not_throw).
