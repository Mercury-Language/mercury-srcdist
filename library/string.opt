:- module string.
:- use_module assoc_list.
:- use_module builtin.
:- use_module char.
:- use_module deconstruct.
:- use_module int.
:- use_module list.
:- use_module maybe.
:- use_module ops.
:- use_module pair.
:- use_module pretty_printer.
:- use_module private_builtin.
:- use_module require.
:- use_module std_util.
:- use_module (string.format).
:- use_module (string.parse_util).
:- use_module (string.to_string).

:- type justify_sense
    --->    just_left 
    ;       just_right .

:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("C#", io).
:- pragma foreign_import_module("C#", string).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("Java", string).
:- pragma foreign_import_module("Erlang", io).
:- pragma foreign_import_module("Erlang", string).

:- pred string.accumulate_int(int, character, int, int).
:- mode string.accumulate_int((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- pred string.accumulate_negative_int(int, character, int, int).
:- mode string.accumulate_negative_int((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- pred string.all_empty(list.list(list.list(string))).
:- mode string.all_empty((builtin.in)) is semidet.
:- pred string.all_match_loop((pred character), string, int).
:- mode string.all_match_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in)) is semidet.
:- pred string.append_iii(string, string, string).
:- mode string.append_iii((builtin.in), (builtin.in), (builtin.in)) is semidet.
:- pred string.append_iio(string, string, string).
:- mode string.append_iio((builtin.in), (builtin.in), (builtin.uo)) is det.
:- pred string.append_ioi(string, string, string).
:- mode string.append_ioi((builtin.in), (builtin.uo), (builtin.in)) is semidet.
:- pred string.append_ooi(string, string, string).
:- mode string.append_ooi((builtin.out), (builtin.out), (builtin.in)) is multi.
:- pred string.append_ooi_2(int, int, string, string, string).
:- mode string.append_ooi_2((builtin.in), (builtin.in), (builtin.out), (builtin.out), (builtin.in)) is multi.
:- pred string.char_list_to_lower(list.list(character), list.list(character)).
:- mode string.char_list_to_lower((builtin.in), (builtin.out)) is det.
:- pred string.char_list_to_upper(list.list(character), list.list(character)).
:- mode string.char_list_to_upper((builtin.in), (builtin.out)) is det.
:- pred string.convert_endpoints(int, int, int, int).
:- mode string.convert_endpoints((builtin.in), (builtin.in), (builtin.out), (builtin.out)) is det.
:- pred string.foldl2_between_2(pred(character, A_1, A_1, B_2, B_2), string, int, int, A_1, A_1, B_2, B_2).
:- mode string.foldl2_between_2((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det.
:- mode string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det.
:- mode string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- mode string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet.
:- mode string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet.
:- mode string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi.
:- pred string.foldl_between_2(pred(character, A_1, A_1), string, int, int, A_1, A_1).
:- mode string.foldl_between_2((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode string.foldl_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode string.foldl_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- mode string.foldl_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is nondet.
:- mode string.foldl_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is multi.
:- pred string.foldr_between_2(pred(character, T_1, T_1), string, int, int, T_1, T_1).
:- mode string.foldr_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode string.foldr_between_2((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode string.foldr_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- mode string.foldr_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is nondet.
:- mode string.foldr_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is multi.
:- pred string.index_check(int, int).
:- mode string.index_check((builtin.in), (builtin.in)) is semidet.
:- pred (string.internal_encoding_is_utf8).
:- mode (string.internal_encoding_is_utf8) is semidet.
:- func string.join_rev_columns(string, string, string) = string.
:- mode string.join_rev_columns((builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- func string.lpad(character, int, string) = string.
:- mode string.lpad((builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- func (string.max_precision) = int.
:- mode (string.max_precision) = (builtin.out) is det.
:- pred string.mercury_append(string, string, string).
:- mode string.mercury_append((builtin.in), (builtin.in), (builtin.in)) is semidet.
:- mode string.mercury_append((builtin.in), (builtin.uo), (builtin.in)) is semidet.
:- mode string.mercury_append((builtin.in), (builtin.in), (builtin.uo)) is det.
:- mode string.mercury_append((builtin.uo), (builtin.uo), (builtin.in)) is multi.
:- func (string.min_precision) = int.
:- mode (string.min_precision) = (builtin.out) is det.
:- pred string.next_boundary((pred character), string, int, int).
:- mode string.next_boundary(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.out)) is det.
:- pred string.prefix_length_loop((pred character), string, int, int).
:- mode string.prefix_length_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.out)) is det.
:- func string.rpad(character, int, string) = string.
:- mode string.rpad((builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- pred string.set_char_non_null(character, int, string, string).
:- mode string.set_char_non_null((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- pred string.split_at_separator_loop((pred character), string, int, int, list.list(string), list.list(string)).
:- mode string.split_at_separator_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- func string.split_at_string_loop(int, int, string, string) = list.list(string).
:- mode string.split_at_string_loop((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- pred string.suffix_2_ioii(string, string, int, int).
:- mode string.suffix_2_ioii((builtin.in), (builtin.out), (builtin.in), (builtin.in)) is multi.
:- pred string.suffix_length_loop((pred character), string, int, int).
:- mode string.suffix_length_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.out)) is det.
:- pred string.to_char_list_forward(string, list.list(character)).
:- mode string.to_char_list_forward((builtin.in), (builtin.out)) is det.
:- pred string.to_code_unit_list_loop(string, int, int, list.list(int)).
:- mode string.to_code_unit_list_loop((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- pred string.unsafe_index_2(string, int, character).
:- mode string.unsafe_index_2((builtin.in), (builtin.in), (builtin.uo)) is semidet.
:- pred string.unsafe_set_char_non_null(character, int, string, string).
:- mode string.unsafe_set_char_non_null((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- pred string.utf8_is_trail_byte(int).
:- mode string.utf8_is_trail_byte((builtin.in)) is semidet.
:- pred string.words_loop((pred character), string, int, list.list(string)).
:- mode string.words_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.out)) is det.

string.(V_4 ++ V_5) = V_3 :-
    V_3 = string.append(V_4, V_5).

string.accumulate_int(V_5, V_6, V_7, V_8) :-
    char.base_digit_to_int(V_5, V_6, V_9),
    V_8 = int.(V_10 + V_9),
    V_10 = int.(V_5 * V_7),
    int.(V_7 =< V_8).

string.accumulate_negative_int(V_5, V_6, V_7, V_8) :-
    char.base_digit_to_int(V_5, V_6, V_9),
    V_8 = int.(V_10 - V_9),
    V_10 = int.(V_5 * V_7),
    int.(V_8 =< V_7).

string.all_empty(list.[]).
string.all_empty(list.[V_2 | V_3]) :-
    V_2 = list.[] : list.list(string),
    string.all_empty(V_3).

string.all_match(V_3, V_4) :-
    V_5 = 0 : int,
    string.all_match_loop(V_3, V_4, V_5).

string.all_match_loop(V_4, V_5, V_6) :-
    (if
      string.unsafe_index_next(V_5, V_6, V_7, V_8)
    then
      call(V_4, V_8),
      string.all_match_loop(V_4, V_5, V_7)
    else
      true
    ).

string.append(V_4, V_5) = V_6 :-
    string.append(V_4, V_5, V_6).

:- pragma foreign_proc("C", string.append_iii(S1 :: (builtin.in), S2 :: (builtin.in), S3 :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    size_t len_1 = strlen(S1);
    SUCCESS_INDICATOR = (
        strncmp(S1, S3, len_1) == 0 &&
        strcmp(S2, S3 + len_1) == 0
    );
}").

:- pragma foreign_proc("C", string.append_iio(S1 :: (builtin.in), S2 :: (builtin.in), S3 :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    size_t len_1, len_2;
    len_1 = strlen(S1);
    len_2 = strlen(S2);
    MR_allocate_aligned_string_msg(S3, len_1 + len_2, MR_ALLOC_ID);
    strcpy(S3, S1);
    strcpy(S3 + len_1, S2);
}").

:- pragma foreign_proc("C", string.append_ioi(S1 :: (builtin.in), S2 :: (builtin.uo), S3 :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    size_t len_1, len_2, len_3;

    len_1 = strlen(S1);
    if (strncmp(S1, S3, len_1) != 0) {
        SUCCESS_INDICATOR = MR_FALSE;
    } else {
        len_3 = strlen(S3);
        len_2 = len_3 - len_1;
        /*
        ** We need to make a copy to ensure that the pointer is word-aligned.
        */
        MR_allocate_aligned_string_msg(S2, len_2, MR_ALLOC_ID);
        strcpy(S2, S3 + len_1);
        SUCCESS_INDICATOR = MR_TRUE;
    }
}").

string.append_list(V_3, V_2) :-
    V_2 = string.append_list(V_3).

string.append_ooi(V_4, V_5, V_6) :-
    V_7 = string.length(V_6),
    V_8 = 0 : int,
    string.append_ooi_2(V_8, V_7, V_4, V_5, V_6).

string.between(V_5, V_6, V_7) = V_8 :-
    string.between(V_5, V_6, V_7, V_8).

string.between_codepoints(V_5, V_6, V_7) = V_8 :-
    string.between_codepoints(V_5, V_6, V_7, V_8).

string.c_pointer_to_string(V_3) = V_4 :-
    string.c_pointer_to_string(V_3, V_4).

string.capitalize_first(V_3) = V_4 :-
    string.capitalize_first(V_3, V_4).

string.char_to_string(V_3, V_4) :-
    V_5 = list.[V_3 | V_6] : list.list(character),
    V_6 = list.[] : list.list(character),
    string.to_char_list(V_4, V_5).

string.char_to_string(V_3) = V_4 :-
    string.char_to_string(V_3, V_4).

string.codepoint_offset(V_4, V_5, V_6) :-
    V_7 = 0 : int,
    string.codepoint_offset(V_4, V_7, V_5, V_6).

:- pragma foreign_proc("C", string.contains_char(Str :: (builtin.in), Ch :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "
    char    buf[5];
    size_t  len;
    if (MR_is_ascii(Ch)) {
        /* Fast path. */
        SUCCESS_INDICATOR = (strchr(Str, Ch) != NULL) && Ch != \'\\0\';
    } else {
        len = MR_utf8_encode(buf, Ch);
        buf[len] = \'\\0\';
        SUCCESS_INDICATOR = (strstr(Str, buf) != NULL);
    }
").

string.count_code_units(V_3, V_4) :-
    string.length(V_3, V_4).

string.count_code_units(V_3) = V_2 :-
    V_2 = string.length(V_3).

string.count_codepoints(V_3) = V_4 :-
    string.count_codepoints(V_3, V_4).

:- pragma foreign_proc("C", string.count_utf8_code_units(Str :: (builtin.in)) = (Length :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "
    Length = strlen(Str);
").

:- pragma inline((string.det_index)/3).
string.det_index(V_4, V_5, V_6) :-
    (if
      string.index(V_4, V_5, V_7)
    then
      V_6 = V_7
    else
      V_8 = "string.det_index: index out of range" : string,
      require.error(V_8)
    ).

string.det_index(V_4, V_5) = V_6 :-
    string.det_index(V_4, V_5, V_6).

string.det_set_char(V_5, V_6, V_7) = V_8 :-
    string.det_set_char(V_5, V_6, V_7, V_8).

string.det_to_int(V_3) = V_2 :-
    V_2 = string.det_base_string_to_int(V_4, V_3),
    V_4 = 10 : int.

string.duplicate_char(V_4, V_5, V_6) :-
    V_6 = string.from_char_list(V_7),
    V_7 = list.duplicate(V_5, V_4).

string.duplicate_char(V_4, V_5) = V_6 :-
    string.duplicate_char(V_4, V_5, V_6).

string.elem(V_5, V_4) = V_3 :-
    V_3 = string.det_index(V_4, V_5).

:- pragma foreign_proc("C", string.first_char(Str :: (builtin.uo), First :: (builtin.in), Rest :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    size_t firstw = MR_utf8_width(First);
    size_t len = firstw + strlen(Rest);
    MR_allocate_aligned_string_msg(Str, len, MR_ALLOC_ID);
    MR_utf8_encode(Str, First);
    strcpy(Str + firstw, Rest);
}").
:- pragma foreign_proc("C", string.first_char(Str :: (builtin.in), First :: (builtin.uo), Rest :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Integer pos = 0;
    First = MR_utf8_get_next(Str, &pos);
    if (First < 1) {
        SUCCESS_INDICATOR = MR_FALSE;
    } else {
        Str += pos;
        /*
        ** We need to make a copy to ensure that the pointer is word-aligned.
        */
        MR_allocate_aligned_string_msg(Rest, strlen(Str), MR_ALLOC_ID);
        strcpy(Rest, Str);
        SUCCESS_INDICATOR = MR_TRUE;
    }
}").
:- pragma foreign_proc("C", string.first_char(Str :: (builtin.in), First :: (builtin.in), Rest :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Integer pos = 0;
    int c = MR_utf8_get_next(Str, &pos);
    if (c != First || First == \'\\0\') {
        SUCCESS_INDICATOR = MR_FALSE;
    } else {
        Str += pos;
        /*
        ** We need to make a copy to ensure that the pointer is word-aligned.
        */
        MR_allocate_aligned_string_msg(Rest, strlen(Str), MR_ALLOC_ID);
        strcpy(Rest, Str);
        SUCCESS_INDICATOR = MR_TRUE;
    }
}").
:- pragma foreign_proc("C", string.first_char(Str :: (builtin.in), First :: (builtin.uo), Rest :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "
    MR_Integer pos = 0;
    First = MR_utf8_get_next(Str, &pos);
    SUCCESS_INDICATOR = (First > 0 && strcmp(Str + pos, Rest) == 0);
").
:- pragma foreign_proc("C", string.first_char(Str :: (builtin.in), First :: (builtin.in), Rest :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "
    MR_Integer pos = 0;
    int c = MR_utf8_get_next(Str, &pos);
    SUCCESS_INDICATOR = (
        c == First &&
        First != \'\\0\' &&
        strcmp(Str + pos, Rest) == 0
    );
").

:- pragma foreign_proc("C", string.float_to_string(Flt :: (builtin.in), Str :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    /*
    ** For efficiency reasons we duplicate the C implementation
    ** of string.lowlevel_float_to_string.
    */
    MR_float_to_string(Flt, Str, MR_ALLOC_ID);
}").

string.float_to_string(V_3) = V_4 :-
    string.float_to_string(V_3, V_4).

string.foldl(V_5, V_6, V_9, V_10) :-
    string.length(V_6, V_8),
    V_11 = 0 : int,
    string.foldl_between(V_5, V_6, V_11, V_8, V_9, V_10).

string.foldl(V_5, V_6, V_7) = V_8 :-
    V_9 = (pred(V_13::(builtin.in), V_14::(builtin.in), V_15::(builtin.out)) is det :-
      some [] (
        V_13 = V_16,
        V_14 = V_17,
        V_18 = apply(V_5, V_16, V_17),
        V_15 = V_18
      )
    )
 : pred(character, A_1, A_1),
    string.foldl(V_9, V_6, V_7, V_8).

string.foldl2(V_7, V_8, V_12, V_13, V_14, V_15) :-
    string.length(V_8, V_11),
    V_16 = 0 : int,
    string.foldl2_between(V_7, V_8, V_16, V_11, V_12, V_13, V_14, V_15).

string.foldl2_between(V_9, V_10, V_11, V_12, V_17, V_18, V_19, V_20) :-
    V_15 = int.max(V_21, V_11),
    V_21 = 0 : int,
    V_16 = int.min(V_12, V_22),
    V_22 = string.length(V_10),
    string.foldl2_between_2(V_9, V_10, V_15, V_16, V_17, V_18, V_19, V_20).

string.foldl2_between_2(V_9, V_10, V_11, V_12, V_17, V_18, V_19, V_20) :-
    (if
      int.(V_11 < V_12),
      string.unsafe_index_next(V_10, V_11, V_15, V_16),
      int.(V_15 =< V_12)
    then
      call(V_9, V_16, V_17, V_21, V_19, V_22),
      string.foldl2_between_2(V_9, V_10, V_15, V_12, V_21, V_18, V_22, V_20)
    else
      V_20 = V_19,
      V_18 = V_17
    ).

string.foldl2_substring(V_9, V_10, V_11, V_12, V_17, V_18, V_19, V_20) :-
    string.convert_endpoints(V_11, V_12, V_15, V_16),
    string.foldl2_between(V_9, V_10, V_15, V_16, V_17, V_18, V_19, V_20).

string.foldl_between(V_7, V_8, V_9, V_10, V_14, V_15) :-
    V_12 = int.max(V_16, V_9),
    V_16 = 0 : int,
    V_13 = int.min(V_10, V_17),
    V_17 = string.length(V_8),
    string.foldl_between_2(V_7, V_8, V_12, V_13, V_14, V_15).

string.foldl_between(V_7, V_8, V_9, V_10, V_11) = V_12 :-
    V_13 = (pred(V_17::(builtin.in), V_18::(builtin.in), V_19::(builtin.out)) is det :-
      some [] (
        V_17 = V_20,
        V_18 = V_21,
        V_22 = apply(V_7, V_20, V_21),
        V_19 = V_22
      )
    )
 : pred(character, A_1, A_1),
    string.foldl_between(V_13, V_8, V_9, V_10, V_11, V_12).

string.foldl_between_2(V_7, V_8, V_9, V_10, V_14, V_15) :-
    (if
      int.(V_9 < V_10),
      string.unsafe_index_next(V_8, V_9, V_12, V_13),
      int.(V_12 =< V_10)
    then
      call(V_7, V_13, V_14, V_16),
      string.foldl_between_2(V_7, V_8, V_12, V_10, V_16, V_15)
    else
      V_15 = V_14
    ).

string.foldl_substring(V_7, V_8, V_9, V_10, V_14, V_15) :-
    string.convert_endpoints(V_9, V_10, V_12, V_13),
    string.foldl_between(V_7, V_8, V_12, V_13, V_14, V_15).

string.foldl_substring(V_7, V_8, V_9, V_10, V_11) = V_12 :-
    string.convert_endpoints(V_9, V_10, V_13, V_14),
    V_12 = string.foldl_between(V_7, V_8, V_13, V_14, V_11).

string.foldr(V_5, V_6, V_8, V_9) :-
    V_10 = 0 : int,
    V_11 = string.length(V_6),
    string.foldr_between(V_5, V_6, V_10, V_11, V_8, V_9).

string.foldr(V_5, V_6, V_7) = V_8 :-
    V_9 = (pred(V_13::(builtin.in), V_14::(builtin.in), V_15::(builtin.out)) is det :-
      some [] (
        V_13 = V_16,
        V_14 = V_17,
        V_18 = apply(V_5, V_16, V_17),
        V_15 = V_18
      )
    )
 : pred(character, T_1, T_1),
    string.foldr(V_9, V_6, V_7, V_8).

string.foldr_between(V_7, V_8, V_9, V_10, V_14, V_15) :-
    V_12 = int.max(V_16, V_9),
    V_16 = 0 : int,
    V_13 = int.min(V_10, V_17),
    V_17 = string.length(V_8),
    string.foldr_between_2(V_7, V_8, V_12, V_13, V_14, V_15).

string.foldr_between(V_7, V_8, V_9, V_10, V_11) = V_12 :-
    V_13 = (pred(V_17::(builtin.in), V_18::(builtin.in), V_19::(builtin.out)) is det :-
      some [] (
        V_17 = V_20,
        V_18 = V_21,
        V_22 = apply(V_7, V_20, V_21),
        V_19 = V_22
      )
    )
 : pred(character, T_1, T_1),
    string.foldr_between(V_13, V_8, V_9, V_10, V_11, V_12).

string.foldr_between_2(V_7, V_8, V_9, V_10, V_14, V_15) :-
    (if
      int.(V_10 > V_9),
      string.unsafe_prev_index(V_8, V_10, V_12, V_13),
      int.(V_12 >= V_9)
    then
      call(V_7, V_13, V_14, V_16),
      string.foldr_between_2(V_7, V_8, V_9, V_12, V_16, V_15)
    else
      V_15 = V_14
    ).

string.foldr_substring(V_7, V_8, V_9, V_10, V_14, V_15) :-
    string.convert_endpoints(V_9, V_10, V_12, V_13),
    string.foldr_between(V_7, V_8, V_12, V_13, V_14, V_15).

string.foldr_substring(V_7, V_8, V_9, V_10, V_11) = V_12 :-
    string.convert_endpoints(V_9, V_10, V_13, V_14),
    V_12 = string.foldr_between(V_7, V_8, V_13, V_14, V_11).

string.format(V_4, V_5, V_6) :-
    (string.format).format_impl(V_4, V_5, V_6).

string.format(V_4, V_5) = V_6 :-
    string.format(V_4, V_5, V_6).

string.from_c_pointer(V_3) = V_4 :-
    string.c_pointer_to_string(V_3, V_4).

string.from_char(V_3) = V_2 :-
    V_2 = string.char_to_string(V_3).

string.from_char_list(V_3) = V_4 :-
    string.from_char_list(V_3, V_4).

string.from_float(V_3) = V_2 :-
    V_2 = string.float_to_string(V_3).

string.from_int(V_3) = V_2 :-
    V_2 = string.int_to_string(V_3).

string.from_rev_char_list(V_3) = V_4 :-
    string.from_rev_char_list(V_3, V_4).

string.hash(V_3, V_4) :-
    V_4 = string.hash(V_3).

:- pragma inline((string.index)/3).
string.index(V_4, V_5, V_6) :-
    V_7 = string.length(V_4),
    (if
      string.index_check(V_5, V_7)
    then
      string.unsafe_index(V_4, V_5, V_6)
    else
      fail
    ).

:- pragma foreign_proc("C", string.index_check(Index :: (builtin.in), Length :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "
    /*
    ** We do not test for negative values of Index because (a) MR_Unsigned
    ** is unsigned and hence a negative argument will appear as a very large
    ** positive one after the cast and (b) anybody dealing with the case
    ** where strlen(Str) > MAXINT is clearly barking mad (and one may well get
    ** an integer overflow error in this case).
    */
    SUCCESS_INDICATOR = ((MR_Unsigned) Index < (MR_Unsigned) Length);
").

:- pragma inline((string.index_next)/4).
string.index_next(V_5, V_6, V_7, V_8) :-
    V_9 = string.length(V_5),
    (if
      string.index_check(V_6, V_9)
    then
      string.unsafe_index_next(V_5, V_6, V_7, V_8)
    else
      fail
    ).

string.int_to_base_string(V_4, V_5) = V_6 :-
    string.int_to_base_string(V_4, V_5, V_6).

string.int_to_string(V_3, V_4) :-
    V_5 = 10 : int,
    string.int_to_base_string(V_3, V_5, V_4).

string.int_to_string(V_3) = V_4 :-
    string.int_to_string(V_3, V_4).

string.int_to_string_thousands(V_3) = V_2 :-
    V_2 = string.int_to_base_string_group(V_3, V_4, V_5, V_6),
    V_4 = 10 : int,
    V_5 = 3 : int,
    V_6 = "," : string.

:- pragma foreign_proc("C", string.internal_encoding_is_utf8, [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "
    SUCCESS_INDICATOR = MR_TRUE;
").

string.is_all_alnum(V_2) :-
    V_3 = char.is_alnum : (pred character),
    string.all_match(V_3, V_2).

:- pragma foreign_proc("C", string.is_all_alnum_or_underscore(S :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness, may_duplicate], "
    const char  *p;

    SUCCESS_INDICATOR = MR_TRUE;
    for (p = S; *p != \'\\0\'; p++) {
        switch (*p) {
            case \'0\': case \'1\': case \'2\': case \'3\': case \'4\':
            case \'5\': case \'6\': case \'7\': case \'8\': case \'9\':

            case \'a\': case \'b\': case \'c\': case \'d\': case \'e\':
            case \'f\': case \'g\': case \'h\': case \'i\': case \'j\':
            case \'k\': case \'l\': case \'m\': case \'n\': case \'o\':
            case \'p\': case \'q\': case \'r\': case \'s\': case \'t\':
            case \'u\': case \'v\': case \'w\': case \'x\': case \'y\':
            case \'z\':

            case \'A\': case \'B\': case \'C\': case \'D\': case \'E\':
            case \'F\': case \'G\': case \'H\': case \'I\': case \'J\':
            case \'K\': case \'L\': case \'M\': case \'N\': case \'O\':
            case \'P\': case \'Q\': case \'R\': case \'S\': case \'T\':
            case \'U\': case \'V\': case \'W\': case \'X\': case \'Y\':
            case \'Z\':

            case \'_\':
                continue;

            default:
                SUCCESS_INDICATOR = MR_FALSE;
                break;
        }
    }
").

:- pragma foreign_proc("C", string.is_all_alpha(S :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness, may_duplicate], "
    const char  *p;

    SUCCESS_INDICATOR = MR_TRUE;
    for (p = S; *p != \'\\0\'; p++) {
        switch (*p) {
            case \'a\': case \'b\': case \'c\': case \'d\': case \'e\':
            case \'f\': case \'g\': case \'h\': case \'i\': case \'j\':
            case \'k\': case \'l\': case \'m\': case \'n\': case \'o\':
            case \'p\': case \'q\': case \'r\': case \'s\': case \'t\':
            case \'u\': case \'v\': case \'w\': case \'x\': case \'y\':
            case \'z\':

            case \'A\': case \'B\': case \'C\': case \'D\': case \'E\':
            case \'F\': case \'G\': case \'H\': case \'I\': case \'J\':
            case \'K\': case \'L\': case \'M\': case \'N\': case \'O\':
            case \'P\': case \'Q\': case \'R\': case \'S\': case \'T\':
            case \'U\': case \'V\': case \'W\': case \'X\': case \'Y\':
            case \'Z\':
                continue;

            default:
                SUCCESS_INDICATOR = MR_FALSE;
                break;
        }
    }
").

:- pragma foreign_proc("C", string.is_all_alpha_or_underscore(S :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness, may_duplicate], "
    const char  *p;

    SUCCESS_INDICATOR = MR_TRUE;
    for (p = S; *p != \'\\0\'; p++) {
        switch (*p) {
            case \'a\': case \'b\': case \'c\': case \'d\': case \'e\':
            case \'f\': case \'g\': case \'h\': case \'i\': case \'j\':
            case \'k\': case \'l\': case \'m\': case \'n\': case \'o\':
            case \'p\': case \'q\': case \'r\': case \'s\': case \'t\':
            case \'u\': case \'v\': case \'w\': case \'x\': case \'y\':
            case \'z\':

            case \'A\': case \'B\': case \'C\': case \'D\': case \'E\':
            case \'F\': case \'G\': case \'H\': case \'I\': case \'J\':
            case \'K\': case \'L\': case \'M\': case \'N\': case \'O\':
            case \'P\': case \'Q\': case \'R\': case \'S\': case \'T\':
            case \'U\': case \'V\': case \'W\': case \'X\': case \'Y\':
            case \'Z\':

            case \'_\':
                continue;

            default:
                SUCCESS_INDICATOR = MR_FALSE;
                break;
        }
    }
").

:- pragma foreign_proc("C", string.is_all_digits(S :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness, may_duplicate], "
    const char  *p;

    SUCCESS_INDICATOR = MR_TRUE;
    for (p = S; *p != \'\\0\'; p++) {
        switch (*p) {
            case \'0\': case \'1\': case \'2\': case \'3\': case \'4\':
            case \'5\': case \'6\': case \'7\': case \'8\': case \'9\':
                continue;

            default:
                SUCCESS_INDICATOR = MR_FALSE;
                break;
        }
    }
").

string.is_empty("").

string.join_rev_columns(V_5, V_6, V_7) = V_4 :-
    V_4 = string.(V_7 ++ V_8),
    V_8 = string.(V_5 ++ V_6).

string.left(V_4, V_5, V_6) :-
    string.split(V_4, V_5, V_6, V_7).

string.left(V_4, V_5) = V_6 :-
    string.left(V_4, V_5, V_6).

string.left_by_codepoint(V_4, V_5, V_6) :-
    string.split_by_codepoint(V_4, V_5, V_6, V_7).

string.left_by_codepoint(V_4, V_5) = V_6 :-
    string.left_by_codepoint(V_4, V_5, V_6).

:- pragma promise_equivalent_clauses((string.length)/2).
:- pragma foreign_proc("C", string.length(Str :: (builtin.ui), Length :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "
    Length = strlen(Str);
").
:- pragma foreign_proc("C", string.length(Str :: (builtin.in), Length :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "
    Length = strlen(Str);
").

string.length(V_3) = V_4 :-
    string.length(V_3, V_4).

string.lpad(V_5, V_6, V_7) = V_4 :-
    V_4 = string.pad_left(V_7, V_5, V_6).

string.lstrip(V_3) = V_2 :-
    V_2 = string.lstrip_pred(V_4, V_3),
    V_4 = char.is_whitespace : (pred character).

string.lstrip_pred(V_4, V_5) = V_3 :-
    V_3 = string.right(V_5, V_6),
    V_6 = int.(V_7 - V_8),
    V_7 = string.length(V_5),
    V_8 = string.prefix_length(V_4, V_5).

string.max_precision = V_1 :-
    V_1 = int.(V_2 + V_3),
    V_2 = string.min_precision,
    V_3 = 2 : int.

string.mercury_append(V_4, V_5, V_6) :-
    string.to_char_list(V_4, V_7),
    string.to_char_list(V_5, V_8),
    string.to_char_list(V_6, V_9),
    list.append(V_7, V_8, V_9).

string.min_precision = 15.

string.next_boundary(V_5, V_6, V_7, V_8) :-
    (if
      string.unsafe_index_next(V_6, V_7, V_9, V_10),
      call(V_5, V_10)
    then
      string.next_boundary(V_5, V_6, V_9, V_8)
    else
      V_8 = V_7
    ).

string.pad_left(V_5, V_6, V_7) = V_8 :-
    string.pad_left(V_5, V_6, V_7, V_8).

string.pad_right(V_5, V_6, V_7) = V_8 :-
    string.pad_right(V_5, V_6, V_7, V_8).

string.prefix_length(V_4, V_5) = V_6 :-
    V_7 = 0 : int,
    string.prefix_length_loop(V_4, V_5, V_7, V_6).

string.prefix_length_loop(V_5, V_6, V_7, V_8) :-
    (if
      string.unsafe_index_next(V_6, V_7, V_9, V_10),
      call(V_5, V_10)
    then
      string.prefix_length_loop(V_5, V_6, V_9, V_8)
    else
      V_8 = V_7
    ).

:- pragma inline((string.prev_index)/4).
string.prev_index(V_5, V_6, V_7, V_8) :-
    V_9 = string.length(V_5),
    (if
      V_10 = int.(V_6 - V_11),
      V_11 = 1 : int,
      string.index_check(V_10, V_9)
    then
      string.unsafe_prev_index(V_5, V_6, V_7, V_8)
    else
      fail
    ).

string.remove_prefix(V_4, V_5, V_6) :-
    string.append(V_4, V_6, V_5).

string.remove_prefix_if_present(V_4, V_5) = V_6 :-
    (if
      string.remove_prefix(V_4, V_5, V_7)
    then
      V_6 = V_7
    else
      V_6 = V_5
    ).

string.replace_all(V_5, V_6, V_7) = V_8 :-
    string.replace_all(V_5, V_6, V_7, V_8).

string.right(V_4, V_5, V_6) :-
    string.length(V_4, V_7),
    V_8 = int.(V_7 - V_5),
    string.split(V_4, V_8, V_9, V_6).

string.right(V_4, V_5) = V_6 :-
    string.right(V_4, V_5, V_6).

string.right_by_codepoint(V_4, V_5, V_6) :-
    string.count_codepoints(V_4, V_7),
    V_8 = int.(V_7 - V_5),
    string.split_by_codepoint(V_4, V_8, V_9, V_6).

string.right_by_codepoint(V_4, V_5) = V_6 :-
    string.right_by_codepoint(V_4, V_5, V_6).

string.rpad(V_5, V_6, V_7) = V_4 :-
    V_4 = string.pad_right(V_7, V_5, V_6).

string.rstrip(V_3) = V_2 :-
    V_2 = string.rstrip_pred(V_4, V_3),
    V_4 = char.is_whitespace : (pred character).

string.rstrip_pred(V_4, V_5) = V_3 :-
    V_3 = string.left(V_5, V_6),
    V_6 = int.(V_7 - V_8),
    V_7 = string.length(V_5),
    V_8 = string.suffix_length(V_4, V_5).

:- pragma foreign_proc("C", string.set_char_non_null(Ch :: (builtin.in), Index :: (builtin.in), Str0 :: (builtin.in), Str :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    size_t len = strlen(Str0);
    if ((MR_Unsigned) Index >= len) {
        SUCCESS_INDICATOR = MR_FALSE;
    } else if (MR_is_ascii(Str0[Index]) && MR_is_ascii(Ch)) {
        /* Fast path. */
        SUCCESS_INDICATOR = MR_TRUE;
        MR_allocate_aligned_string_msg(Str, len, MR_ALLOC_ID);
        strcpy(Str, Str0);
        Str[Index] = Ch;
    } else {
        int oldc = MR_utf8_get(Str0, Index);
        if (oldc < 0) {
            SUCCESS_INDICATOR = MR_FALSE;
        } else {
            size_t oldwidth = MR_utf8_width(oldc);
            size_t newwidth = MR_utf8_width(Ch);
            size_t newlen;

            newlen = len - oldwidth + newwidth;
            MR_allocate_aligned_string_msg(Str, newlen, MR_ALLOC_ID);
            MR_memcpy(Str, Str0, Index);
            MR_utf8_encode(Str + Index, Ch);
            strcpy(Str + Index + newwidth, Str0 + Index + oldwidth);
            SUCCESS_INDICATOR = MR_TRUE;
        }
    }
").

string.split_at_char(V_4, V_5) = V_3 :-
    V_3 = string.split_at_separator(V_6, V_5),
    V_6 = builtin.unify(V_4) : (pred character).

string.split_at_separator(V_4, V_5) = V_6 :-
    V_7 = string.length(V_5),
    V_8 = V_7,
    V_9 = list.[] : list.list(string),
    string.split_at_separator_loop(V_4, V_5, V_7, V_8, V_9, V_6).

string.split_at_separator_loop(V_7, V_8, V_9, V_10, V_11, V_12) :-
    (if
      string.unsafe_prev_index(V_8, V_9, V_13, V_14)
    then
      (if
        call(V_7, V_14)
      then
        V_15 = V_9,
        V_16 = string.unsafe_between(V_8, V_15, V_10),
        V_17 = V_13,
        V_18 = list.[V_16 | V_11] : list.list(string),
        string.split_at_separator_loop(V_7, V_8, V_13, V_17, V_18, V_12)
      else
        string.split_at_separator_loop(V_7, V_8, V_13, V_10, V_11, V_12)
      )
    else
      V_20 = string.unsafe_between(V_8, V_19, V_10),
      V_19 = 0 : int,
      V_12 = list.[V_20 | V_11] : list.list(string)
    ).

string.split_at_string(V_4, V_5) = V_3 :-
    V_3 = string.split_at_string_loop(V_6, V_7, V_4, V_5),
    V_6 = 0 : int,
    V_7 = string.length(V_4).

string.string(V_3) = V_2 :-
    V_2 = (string.to_string).string_impl(V_3).

string.string_ops(V_4, V_5) = V_3 :-
    V_3 = (string.to_string).string_ops_impl(V_4, V_5).

string.string_ops_noncanon(V_5, V_6, V_7, V_8) :-
    (string.to_string).string_ops_noncanon_impl(V_5, V_6, V_7, V_8).

string.string_to_doc(V_3) = pretty_printer.docs(V_4) :-
    V_4 = list.[V_5 | V_7] : list.list(pretty_printer.doc),
    V_5 = pretty_printer.str(V_6) : pretty_printer.doc,
    V_6 = "\"" : string,
    V_7 = list.[V_8 | V_9] : list.list(pretty_printer.doc),
    V_8 = pretty_printer.str(V_3) : pretty_printer.doc,
    V_9 = list.[V_10 | V_12] : list.list(pretty_printer.doc),
    V_10 = pretty_printer.str(V_11) : pretty_printer.doc,
    V_11 = "\"" : string,
    V_12 = list.[] : list.list(pretty_printer.doc).

string.sub_string_search(V_4, V_5, V_6) :-
    V_7 = 0 : int,
    string.sub_string_search_start(V_4, V_5, V_7, V_6).

:- pragma foreign_proc("C", string.sub_string_search_start(WholeString :: (builtin.in), Pattern :: (builtin.in), BeginAt :: (builtin.in), Index :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    char *match;
    if ((MR_Unsigned) BeginAt > strlen(WholeString)) {
        SUCCESS_INDICATOR = MR_FALSE;
    } else {
        match = strstr(WholeString + BeginAt, Pattern);
        if (match) {
            Index = match - WholeString;
            SUCCESS_INDICATOR = MR_TRUE;
        } else {
            SUCCESS_INDICATOR = MR_FALSE;
        }
    }
}").

string.substring(V_5, V_6, V_7, V_8) :-
    string.convert_endpoints(V_6, V_7, V_9, V_10),
    string.between(V_5, V_9, V_10, V_8).

string.substring(V_5, V_6, V_7) = V_8 :-
    string.substring(V_5, V_6, V_7, V_8).

string.suffix_2_ioii(V_5, V_6, V_7, V_8) :-
    ( % disjunction
      string.unsafe_between(V_5, V_7, V_8, V_6)
    ;
      string.unsafe_prev_index(V_5, V_7, V_9, V_10),
      string.suffix_2_ioii(V_5, V_6, V_9, V_8)
    ).

string.suffix_length(V_4, V_5) = V_3 :-
    V_3 = int.(V_6 - V_7),
    V_6 = string.length(V_5),
    string.suffix_length_loop(V_4, V_5, V_6, V_7).

string.suffix_length_loop(V_5, V_6, V_7, V_8) :-
    (if
      string.unsafe_prev_index(V_6, V_7, V_9, V_10),
      call(V_5, V_10)
    then
      string.suffix_length_loop(V_5, V_6, V_9, V_8)
    else
      V_8 = V_7
    ).

string.to_char_list(V_3) = V_4 :-
    string.to_char_list(V_3, V_4).

:- pragma foreign_proc("C", string.to_char_list_forward(Str :: (builtin.in), CharList :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Integer pos = strlen(Str);
    int c;

    CharList = MR_list_empty_msg(MR_ALLOC_ID);
    for (;;) {
        c = MR_utf8_prev_get(Str, &pos);
        if (c <= 0) {
            break;
        }
        CharList = MR_char_list_cons_msg((MR_UnsignedChar) c, CharList,
            MR_ALLOC_ID);
    }
}").

string.to_code_unit_list(V_3, V_4) :-
    V_5 = 0 : int,
    V_6 = string.length(V_3),
    string.to_code_unit_list_loop(V_3, V_5, V_6, V_4).

:- pragma foreign_proc("C", string.to_float(FloatString :: (builtin.in), FloatVal :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    /*
    ** The %c checks for any erroneous characters appearing after the float;
    ** if there are then sscanf() will return 2 rather than 1.
    */
    char    tmpc;
    SUCCESS_INDICATOR =
        (!MR_isspace(FloatString[0])) &&
        (sscanf(FloatString, MR_FLT_FMT \"%c\", &FloatVal, &tmpc) == 1);
        /* MR_TRUE if sscanf succeeds, MR_FALSE otherwise */
}").

string.to_int(V_3, V_4) :-
    V_5 = 10 : int,
    string.base_string_to_int(V_5, V_3, V_4).

string.to_lower(V_3, V_4) :-
    string.to_char_list(V_3, V_5),
    string.char_list_to_lower(V_5, V_6),
    string.from_char_list(V_6, V_4).

string.to_lower(V_3) = V_4 :-
    string.to_lower(V_3, V_4).

string.to_upper(V_3, V_4) :-
    string.to_char_list(V_3, V_5),
    string.char_list_to_upper(V_5, V_6),
    string.from_char_list(V_6, V_4).

string.to_upper(V_3) = V_4 :-
    string.to_upper(V_3, V_4).

string.uncapitalize_first(V_3) = V_4 :-
    string.uncapitalize_first(V_3, V_4).

:- pragma foreign_proc("C", string.unsafe_between(Str :: (builtin.in), Start :: (builtin.in), End :: (builtin.in), SubString :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Integer Count;

    Count = End - Start;
    MR_allocate_aligned_string_msg(SubString, Count, MR_ALLOC_ID);
    MR_memcpy(SubString, Str + Start, Count);
    SubString[Count] = \'\\0\';
}").

string.unsafe_between(V_5, V_6, V_7) = V_8 :-
    string.unsafe_between(V_5, V_6, V_7, V_8).

string.unsafe_elem(V_5, V_4) = V_3 :-
    V_3 = string.unsafe_index(V_4, V_5).

string.unsafe_index(V_4, V_5) = V_6 :-
    string.unsafe_index(V_4, V_5, V_6).

:- pragma foreign_proc("C", string.unsafe_index_2(Str :: (builtin.in), Index :: (builtin.in), Ch :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "
    Ch = Str[Index];
    if (!MR_is_ascii(Ch)) {
        int width;
        Ch = MR_utf8_get_mb(Str, Index, &width);
    }
    SUCCESS_INDICATOR = (Ch > 0);
").

:- pragma foreign_proc("C", string.unsafe_index_code_unit(Str :: (builtin.in), Index :: (builtin.in), Code :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "
    const unsigned char *s = (const unsigned char *) Str;
    Code = s[Index];
").

:- pragma foreign_proc("C", string.unsafe_index_next(Str :: (builtin.in), Index :: (builtin.in), NextIndex :: (builtin.out), Ch :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "
    Ch = Str[Index];
    if (MR_is_ascii(Ch)) {
        NextIndex = Index + 1;
        SUCCESS_INDICATOR = (Ch != 0);
    } else {
        NextIndex = Index;
        Ch = MR_utf8_get_next_mb(Str, &NextIndex);
        SUCCESS_INDICATOR = (Ch > 0);
    }
").

:- pragma foreign_proc("C", string.unsafe_prev_index(Str :: (builtin.in), Index :: (builtin.in), PrevIndex :: (builtin.out), Ch :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, no_sharing, will_not_modify_trail, doesnt_affect_liveness], "
    if (Index > 0) {
        PrevIndex = Index - 1;
        Ch = Str[PrevIndex];
        if (MR_is_ascii(Ch)) {
            SUCCESS_INDICATOR = (Ch != 0);
        } else {
            Ch = MR_utf8_prev_get(Str, &PrevIndex);
            SUCCESS_INDICATOR = (Ch > 0);
        }
    } else {
        SUCCESS_INDICATOR = MR_FALSE;
    }
").

string.unsafe_set_char(V_5, V_6, V_7) = V_8 :-
    string.unsafe_set_char(V_5, V_6, V_7, V_8).

:- pragma foreign_proc("C", string.unsafe_set_char_non_null(Ch :: (builtin.in), Index :: (builtin.in), Str0 :: (builtin.in), Str :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    size_t len = strlen(Str0);
    if (MR_is_ascii(Str0[Index]) && MR_is_ascii(Ch)) {
        /* Fast path. */
        MR_allocate_aligned_string_msg(Str, len, MR_ALLOC_ID);
        strcpy(Str, Str0);
        Str[Index] = Ch;
    } else {
        int oldc = MR_utf8_get(Str0, Index);
        size_t oldwidth = MR_utf8_width(oldc);
        size_t newwidth = MR_utf8_width(Ch);
        size_t newlen;
        size_t tailofs;

        newlen = len - oldwidth + newwidth;
        MR_allocate_aligned_string_msg(Str, newlen, MR_ALLOC_ID);
        MR_memcpy(Str, Str0, Index);
        MR_utf8_encode(Str + Index, Ch);
        strcpy(Str + Index + newwidth, Str0 + Index + oldwidth);
    }
").

string.unsafe_substring(V_5, V_6, V_7, V_8) :-
    V_9 = int.(V_6 + V_7),
    string.unsafe_between(V_5, V_6, V_9, V_8).

string.unsafe_substring(V_5, V_6, V_7) = V_8 :-
    V_8 = string.unsafe_between(V_5, V_6, V_9),
    V_9 = int.(V_6 + V_7).

string.utf8_is_trail_byte(V_2) :-
    V_3 = int.(V_2 /\ V_4),
    V_4 = 192 : int,
    V_3 = 128 : int.

string.word_wrap(V_4, V_5) = V_3 :-
    V_3 = string.word_wrap_separator(V_4, V_5, V_6),
    V_6 = "" : string.

string.words(V_3) = V_2 :-
    V_2 = string.words_separator(V_4, V_3),
    V_4 = char.is_whitespace : (pred character).

string.words_loop(V_5, V_6, V_7, V_8) :-
    V_13 = std_util.isnt(V_5) : (pred character),
    string.next_boundary(V_13, V_6, V_7, V_9),
    (if
      V_9 = V_7
    then
      V_8 = list.[] : list.list(string)
    else
      string.unsafe_between(V_6, V_7, V_9, V_10),
      string.next_boundary(V_5, V_6, V_9, V_11),
      (if
        V_9 = V_11
      then
        V_8 = list.[V_10 | V_14] : list.list(string),
        V_14 = list.[] : list.list(string)
      else
        string.words_loop(V_5, V_6, V_11, V_12),
        V_8 = list.[V_10 | V_12] : list.list(string)
      )
    ).

string.words_separator(V_4, V_5) = V_6 :-
    V_8 = 0 : int,
    string.next_boundary(V_4, V_5, V_8, V_7),
    string.words_loop(V_4, V_5, V_7, V_6).

:- pragma exceptions(function, (string.(++)), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.accumulate_int), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.accumulate_negative_int), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.all_empty), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (string.all_match), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.all_match_loop), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.append), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append), 3, 1, will_not_throw).
:- pragma exceptions(predicate, (string.append), 3, 2, will_not_throw).
:- pragma exceptions(predicate, (string.append), 3, 3, will_not_throw).
:- pragma exceptions(function, (string.append), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append_iii), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append_iio), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append_ioi), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append_list), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.append_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append_ooi), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append_ooi_2), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append_ooi_3), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (string.base_string_to_int), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.between), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.between), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.between_codepoints), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.between_codepoints), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.between_loop), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.break_up_string_reverse), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.c_pointer_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.c_pointer_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.capitalize_first), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.capitalize_first), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.char_list_to_lower), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.char_list_to_upper), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.char_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.char_to_string), 2, 1, will_not_throw).
:- pragma exceptions(function, (string.char_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.chomp), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.codepoint_offset), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.codepoint_offset), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.codepoint_offset_loop), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (string.contains_char), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.contains_char), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.convert_endpoints), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.count_code_units), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.count_code_units), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.count_codepoints), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.count_codepoints), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.count_codepoints_loop), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.count_utf8_code_units), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.count_utf8_code_units_2), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.decode_utf16), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.decode_utf8), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.det_base_string_to_int), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.det_index), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.det_index), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.det_remove_suffix), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.det_set_char), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.det_set_char), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.det_to_float), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.det_to_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.duplicate_char), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.duplicate_char), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.elem), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.encode_utf16), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.encode_utf8), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.find_max_length), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.find_max_length_with_limit), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.first_char), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.first_char), 3, 1, will_not_throw).
:- pragma exceptions(predicate, (string.first_char), 3, 2, will_not_throw).
:- pragma exceptions(predicate, (string.first_char), 3, 3, will_not_throw).
:- pragma exceptions(predicate, (string.first_char), 3, 4, will_not_throw).
:- pragma exceptions(predicate, (string.float_to_string), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.float_to_string), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.float_to_string_loop), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 4, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldl), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between), 8, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between), 8, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between), 8, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between), 8, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between), 8, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between), 8, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between_2), 8, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between_2), 8, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between_2), 8, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between_2), 8, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between_2), 8, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_between_2), 8, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between), 6, 4, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldl_between), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between_2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between_2), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between_2), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between_2), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_between_2), 6, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 4, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldl_substring), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 4, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldr), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between), 6, 4, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldr_between), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between_2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between_2), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between_2), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between_2), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_between_2), 6, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 4, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldr_substring), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.format), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.format), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.format_table), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.format_table_max), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.from_c_pointer), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.from_char), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.from_char_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.from_char_list), 2, 1, will_not_throw).
:- pragma exceptions(function, (string.from_char_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.from_code_unit_list), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.from_float), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.from_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.from_rev_char_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.from_rev_char_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.from_utf16_code_unit_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.from_utf8_code_unit_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.generate_rows), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.get_next_line), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.hash), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.hash), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.hash2), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.hash2_loop), 5, 0, will_not_throw).
:- pragma exceptions(function, (string.hash3), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.hash3_loop), 5, 0, will_not_throw).
:- pragma exceptions(function, (string.hash4), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.hash4_loop), 5, 0, will_not_throw).
:- pragma exceptions(function, (string.hash5), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.hash5_loop), 5, 0, will_not_throw).
:- pragma exceptions(function, (string.hash6), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.hash6_loop), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (string.hash_loop), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (string.index), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.index_check), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.index_next), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.int_to_base_string), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.int_to_base_string), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.int_to_base_string_1), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.int_to_base_string_2), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.int_to_base_string_group), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.int_to_base_string_group_1), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.int_to_base_string_group_2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.int_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.int_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.int_to_string_thousands), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.internal_encoding_is_utf8), 0, 0, will_not_throw).
:- pragma exceptions(predicate, (string.is_all_alnum), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.is_all_alnum_or_underscore), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (string.is_all_alpha), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (string.is_all_alpha_or_underscore), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (string.is_all_digits), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (string.is_empty), 1, 0, will_not_throw).
:- pragma exceptions(function, (string.join_list), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.join_list_loop), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.join_rev_columns), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.keep_30_bits), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.left), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.left), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.left_by_codepoint), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.left_by_codepoint), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.length), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.length), 2, 1, will_not_throw).
:- pragma exceptions(function, (string.length), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.lpad), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.lstrip), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.lstrip_pred), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.max_precision), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (string.max_str_length), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.mercury_append), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.mercury_append), 3, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.mercury_append), 3, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.mercury_append), 3, 3, may_throw(user_exception)).
:- pragma exceptions(function, (string.min_precision), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (string.next_boundary), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.pad_column), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.pad_left), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.pad_left), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.pad_right), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.pad_right), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.pad_row), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.prefix), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.prefix), 2, 1, will_not_throw).
:- pragma exceptions(predicate, (string.prefix_2_iii), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.prefix_2_ioi), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.prefix_length), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.prefix_length_loop), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.prev_index), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.project_column_strings), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.remove_prefix), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.remove_prefix_if_present), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.remove_suffix), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.remove_suffix_if_present), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.replace), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.replace_all), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.replace_all), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.replace_all_loop), 7, 0, will_not_throw).
:- pragma exceptions(predicate, (string.right), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.right), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.right_by_codepoint), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.right_by_codepoint), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.rpad), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.rstrip), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.rstrip_pred), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.semidet_from_char_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.semidet_from_rev_char_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.set_char), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.set_char_non_null), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.split), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.split_at_char), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.split_at_separator), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.split_at_separator_loop), 6, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.split_at_string), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.split_at_string_loop), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (string.split_by_codepoint), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.string_ops), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.string_ops_noncanon), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.string_ops_noncanon), 4, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.string_ops_noncanon), 4, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.string_ops_noncanon), 4, 3, may_throw(user_exception)).
:- pragma exceptions(function, (string.string_to_doc), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.strip), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.sub_string_search), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.sub_string_search_start), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.sub_string_search_start_loop), 6, 0, will_not_throw).
:- pragma exceptions(predicate, (string.substring), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.substring), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.suffix), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.suffix), 2, 1, will_not_throw).
:- pragma exceptions(predicate, (string.suffix_2_iiii), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (string.suffix_2_ioii), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.suffix_length), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.suffix_length_loop), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_char_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.to_char_list), 2, 1, may_throw(user_exception)).
:- pragma exceptions(function, (string.to_char_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.to_char_list_forward), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.to_code_unit_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.to_code_unit_list_loop), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.to_float), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.to_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_lower), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_lower), 2, 1, may_throw(user_exception)).
:- pragma exceptions(function, (string.to_lower), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_upper), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_upper), 2, 1, may_throw(user_exception)).
:- pragma exceptions(function, (string.to_upper), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_utf16_code_unit_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_utf8_code_unit_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.uncapitalize_first), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.uncapitalize_first), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.unsafe_between), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.unsafe_between), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.unsafe_elem), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.unsafe_index), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.unsafe_index), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.unsafe_index_2), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.unsafe_index_code_unit), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.unsafe_index_next), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.unsafe_prev_index), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.unsafe_set_char), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.unsafe_set_char), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.unsafe_set_char_non_null), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.unsafe_substring), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.unsafe_substring), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.utf8_is_trail_byte), 1, 0, will_not_throw).
:- pragma exceptions(function, (string.word_wrap), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.word_wrap_loop), 7, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.word_wrap_separator), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.words), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.words_loop), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.words_separator), 3, 0, may_throw(user_exception)).

:- pragma termination_info(string.'++'((builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.accumulate_int((builtin.in), (builtin.in), (builtin.in), (builtin.out)), finite(0, [no, no, no, no]), can_loop).
:- pragma termination_info(string.accumulate_negative_int((builtin.in), (builtin.in), (builtin.in), (builtin.out)), finite(0, [no, no, no, no]), can_loop).
:- pragma termination_info(string.all_empty((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(string.all_match(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.all_match_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.append((builtin.in), (builtin.in), (builtin.in)), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(string.append((builtin.in), (builtin.uo), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.append((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.append((builtin.out), (builtin.out), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.append((builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.append_iii((builtin.in), (builtin.in), (builtin.in)), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(string.append_iio((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.append_ioi((builtin.in), (builtin.uo), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.append_list((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.append_list((builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.append_ooi((builtin.out), (builtin.out), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.append_ooi_2((builtin.in), (builtin.in), (builtin.out), (builtin.out), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.base_string_to_int((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.between((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.between((builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.between_codepoints((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.between_codepoints((builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.c_pointer_to_string((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.c_pointer_to_string((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.capitalize_first((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.capitalize_first((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.char_list_to_lower((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.char_list_to_upper((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.char_to_string((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.char_to_string((builtin.out), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.char_to_string((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.chomp((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.codepoint_offset((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.codepoint_offset((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.contains_char((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(string.convert_endpoints((builtin.in), (builtin.in), (builtin.out), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.count_code_units((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.count_code_units((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.count_codepoints((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.count_codepoints((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.count_utf8_code_units((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.det_base_string_to_int((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.det_index((builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.det_index((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.det_remove_suffix((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.det_set_char((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.det_set_char((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.det_to_float((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.det_to_int((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.duplicate_char((builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.duplicate_char((builtin.in), (builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.elem((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.first_char((builtin.in), (builtin.in), (builtin.in)), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(string.first_char((builtin.in), (builtin.uo), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.first_char((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.first_char((builtin.in), (builtin.uo), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.first_char((builtin.uo), (builtin.in), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.float_to_string((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.float_to_string((builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between_2((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_between_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_between((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_between((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl_between((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_between((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_between((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_between((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldl_between_2((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldr_between((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_between((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldr_between((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_between((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_between((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_between((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldr_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_between_2((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldr_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_between_2((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.format((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.format((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.format_table((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.format_table_max((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.from_c_pointer((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.from_char((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.from_char_list((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.from_char_list((builtin.out), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.from_char_list((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.from_code_unit_list((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.from_float((builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.from_int((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.from_rev_char_list((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.from_rev_char_list((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.from_utf16_code_unit_list((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.from_utf8_code_unit_list((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.hash((builtin.in), (builtin.out)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.hash((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.hash2((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.hash3((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.hash4((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.hash5((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.hash6((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.index((builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.index_check((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(string.index_next((builtin.in), (builtin.in), (builtin.out), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.int_to_base_string((builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.int_to_base_string((builtin.in), (builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.int_to_base_string_group((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.int_to_string((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.int_to_string((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.int_to_string_thousands((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info((string.internal_encoding_is_utf8), finite(0, []), cannot_loop).
:- pragma termination_info(string.is_all_alnum((builtin.in)), infinite, can_loop).
:- pragma termination_info(string.is_all_alnum_or_underscore((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(string.is_all_alpha((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(string.is_all_alpha_or_underscore((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(string.is_all_digits((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(string.is_empty((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(string.join_list((builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.join_rev_columns((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.left((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.left((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.left_by_codepoint((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.left_by_codepoint((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.length((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.length((builtin.ui), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.length((builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.lpad((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.lstrip((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.lstrip_pred(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((string.max_precision) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(string.mercury_append((builtin.in), (builtin.in), (builtin.in)), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(string.mercury_append((builtin.in), (builtin.uo), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.mercury_append((builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.mercury_append((builtin.uo), (builtin.uo), (builtin.in)), infinite, can_loop).
:- pragma termination_info((string.min_precision) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(string.next_boundary(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.pad_left((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.pad_left((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.pad_right((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.pad_right((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.prefix((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.prefix((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.prefix_length(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.prefix_length_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.prev_index((builtin.in), (builtin.in), (builtin.out), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.remove_prefix((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.remove_prefix_if_present((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.remove_suffix((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.remove_suffix_if_present((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.replace((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.replace_all((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.replace_all((builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.right((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.right((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.right_by_codepoint((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.right_by_codepoint((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.rpad((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.rstrip((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.rstrip_pred(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.semidet_from_char_list((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.semidet_from_rev_char_list((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.set_char((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.set_char_non_null((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.split((builtin.in), (builtin.in), (builtin.out), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.split_at_char((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.split_at_separator((pred((builtin.in)) is semidet), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.split_at_separator_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.split_at_string((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.split_at_string_loop((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.split_by_codepoint((builtin.in), (builtin.in), (builtin.out), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.string((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.string_ops((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.string_ops_noncanon(builtin.in((deconstruct.do_not_allow)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.string_ops_noncanon(builtin.in((deconstruct.canonicalize)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.string_ops_noncanon(builtin.in((deconstruct.include_details_cc)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.string_ops_noncanon((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.string_to_doc((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.strip((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.sub_string_search((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.sub_string_search_start((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.substring((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.substring((builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.suffix((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.suffix((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.suffix_2_ioii((builtin.in), (builtin.out), (builtin.in), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.suffix_length(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.suffix_length_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.to_char_list((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.to_char_list((builtin.uo), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.to_char_list((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.to_char_list_forward((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.to_code_unit_list((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.to_code_unit_list_loop((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.to_float((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.to_int((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.to_lower((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.to_lower((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.to_lower((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.to_upper((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.to_upper((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.to_upper((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.to_utf16_code_unit_list((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.to_utf8_code_unit_list((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.uncapitalize_first((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.uncapitalize_first((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.unsafe_between((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_between((builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_elem((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.unsafe_index((builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.unsafe_index((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.unsafe_index_2((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_index_code_unit((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_index_next((builtin.in), (builtin.in), (builtin.out), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_prev_index((builtin.in), (builtin.in), (builtin.out), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_set_char((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.unsafe_set_char((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.unsafe_set_char_non_null((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_substring((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_substring((builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.utf8_is_trail_byte((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(string.word_wrap((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.word_wrap_separator((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.words((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.words_loop(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.words_separator((pred((builtin.in)) is semidet), (builtin.in)) = (builtin.out), infinite, can_loop).
