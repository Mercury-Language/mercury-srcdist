:- module string.
:- use_module array, assoc_list, bool, builtin, char, deconstruct, float, int, integer, list, maybe, ops, pair, private_builtin, require, rtti_implementation, std_util, term_io, type_desc, univ.
:- type (string.specifier)
	--->	conv((string.flags) :: (list.list(character)), (string.width) :: (maybe.maybe((list.list(character)))), (string.precision) :: (maybe.maybe((list.list(character)))), (string.spec) :: (string.spec))
	;	string((list.list(character))).
:- type (string.spec)
	--->	d(int)
	;	i(int)
	;	o(int)
	;	u(int)
	;	x(int)
	;	cX(int)
	;	p(int)
	;	e(float)
	;	cE(float)
	;	f(float)
	;	cF(float)
	;	g(float)
	;	cG(float)
	;	c(character)
	;	s(string)
	;	percent .
:- type (string.revstrings) == (list.list(string)).
:- type (string.maybe_width) == (maybe.maybe(int)).
:- type (string.maybe_precision) == (maybe.maybe(int)).
:- type (string.justify_sense)
	--->	just_left 
	;	just_right .
:- type (string.flags) == (list.list(character)).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C#", string).
:- pragma foreign_import_module("Java", string).
:- pragma foreign_import_module("IL", string).
:- pragma foreign_import_module("C", array).
:- pragma foreign_import_module("Java", array).
:- pragma foreign_import_module("IL", array).
:- pragma foreign_import_module("C", array).
:- pragma foreign_import_module("Java", array).
:- pragma foreign_import_module("IL", array).
:- pragma foreign_import_module("Java", rtti_implementation).
:- pragma foreign_import_module("Java", rtti_implementation).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
:- pred string.foldl_substring_2(pred(character, A_1, A_1), string, int, int, A_1, A_1).
:- mode string.foldl_substring_2((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode string.foldl_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode string.foldl_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- mode string.foldl_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is nondet.
:- mode string.foldl_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is multi.
:- pred string.foldl2_substring_2(pred(character, A_1, A_1, B_2, B_2), string, int, int, A_1, A_1, B_2, B_2).
:- mode string.foldl2_substring_2((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det.
:- mode string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det.
:- mode string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- mode string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet.
:- mode string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet.
:- mode string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi.
:- pred string.foldr_substring_2(pred(character, T_1, T_1), string, int, int, T_1, T_1).
:- mode string.foldr_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode string.foldr_substring_2((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode string.foldr_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- mode string.foldr_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is nondet.
:- mode string.foldr_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is multi.
:- pred string.char_list_to_upper((list.list(character)), (list.list(character))).
:- mode string.char_list_to_upper((builtin.in), (builtin.out)) is det.
:- pred string.char_list_to_lower((list.list(character)), (list.list(character))).
:- mode string.char_list_to_lower((builtin.in), (builtin.out)) is det.
:- pred string.all_match((pred character), string).
:- mode string.all_match(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) is semidet.
:- pred string.all_match_2(int, (pred character), string).
:- mode string.all_match_2((builtin.in), builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) is semidet.
:- pred string.index_check(int, int).
:- mode string.index_check((builtin.in), (builtin.in)) is semidet.
:- func string.words_2((pred character), string, int, (list.list(string))) = (list.list(string)).
:- mode string.words_2(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- pred string.split_at_separator2((pred character), string, int, int, (list.list(string)), (list.list(string))).
:- mode string.split_at_separator2(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- func string.split_at_string(int, int, string, string) = (list.list(string)).
:- mode string.split_at_string((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- func string.preceding_boundary((pred character), string, int) = int.
:- mode string.preceding_boundary(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- func string.prefix_length_2(int, int, (pred character), string) = int.
:- mode string.prefix_length_2((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out) is det.
:- func string.suffix_length_2(int, int, (pred character), string) = int.
:- mode string.suffix_length_2((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out) is det.
:- pred string.value_to_revstrings((deconstruct.noncanon_handling), (ops.mercury_op_table), T_1, (list.list(string)), (list.list(string))).
:- mode string.value_to_revstrings(builtin.in((deconstruct.do_not_allow)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode string.value_to_revstrings(builtin.in((deconstruct.canonicalize)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode string.value_to_revstrings(builtin.in((deconstruct.include_details_cc)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is cc_multi.
:- mode string.value_to_revstrings((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is cc_multi.
:- pred string.char_list_remove_suffix((list.list(character)), (list.list(character)), (list.list(character))).
:- mode string.char_list_remove_suffix((builtin.in), (builtin.in), (builtin.out)) is semidet.
string.length(S_3) = L_4 :-
    string.length(S_3, L_4).
:- pragma promise_equivalent_clauses((string.length)/2).
:- pragma foreign_proc("C", string.length(Str :: (builtin.ui), Length :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    Length = strlen(Str);
").
:- pragma foreign_proc("C", string.length(Str :: (builtin.in), Length :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    Length = strlen(Str);
").
string.append(S1_4, S2_5) = S3_6 :-
    string.append(S1_4, S2_5, S3_6).
string.(S1_4 ++ S2_5) = HeadVar__3_3 :-
    HeadVar__3_3 = string.append(S1_4, S2_5).
string.remove_suffix(A_4, B_5, C_6) :-
    string.to_char_list(A_4, LA_7),
    string.to_char_list(B_5, LB_8),
    string.to_char_list(C_6, LC_9),
    string.char_list_remove_suffix(LA_7, LB_8, LC_9).
string.string(Univ_3) = String_4 :-
    V_5 = deconstruct.canonicalize : (deconstruct.noncanon_handling),
    V_6 = ops.init_mercury_op_table,
    string.string_ops_noncanon(V_5, V_6, Univ_3, String_4).
string.string_ops(OpsTable_4, Univ_5) = String_6 :-
    V_7 = deconstruct.canonicalize : (deconstruct.noncanon_handling),
    string.string_ops_noncanon(V_7, OpsTable_4, Univ_5, String_6).
string.string_ops_noncanon(NonCanon_5, OpsTable_6, X_7, String_8) :-
    V_10 = list.[] : (list.list(string)),
    string.value_to_revstrings(NonCanon_5, OpsTable_6, X_7, V_10, RevStrings_9),
    String_8 = string.append_list(V_11),
    V_11 = list.reverse(RevStrings_9).
string.char_to_string(C_3) = S1_4 :-
    string.char_to_string(C_3, S1_4).
string.char_to_string(Char_3, String_4) :-
    V_5 = list.[Char_3 | V_6] : (list.list(character)),
    V_6 = list.[] : (list.list(character)),
    string.to_char_list(String_4, V_5).
string.from_char(Char_3) = HeadVar__2_2 :-
    HeadVar__2_2 = string.char_to_string(Char_3).
string.int_to_string(N_3) = S1_4 :-
    string.int_to_string(N_3, S1_4).
string.int_to_string(N_3, Str_4) :-
    V_5 = 10 : int,
    string.int_to_base_string(N_3, V_5, Str_4).
string.from_int(N_3) = HeadVar__2_2 :-
    HeadVar__2_2 = string.int_to_string(N_3).
string.int_to_string_thousands(N_3) = HeadVar__2_2 :-
    HeadVar__2_2 = string.int_to_base_string_group(N_3, V_4, V_5, V_6),
    V_4 = 10 : int,
    V_5 = 3 : int,
    V_6 = "," : string.
string.int_to_base_string(N1_4, N2_5) = S2_6 :-
    string.int_to_base_string(N1_4, N2_5, S2_6).
string.float_to_string(R_3) = S2_4 :-
    string.float_to_string(R_3, S2_4).
:- pragma foreign_proc("C", string.float_to_string(Flt :: (builtin.in), Str :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    /*
    ** For efficiency reasons we duplicate the C implementation
    ** of string.lowlevel_float_to_string.
    */
    MR_float_to_string(Flt, Str);
}").
string.from_float(Flt_3) = HeadVar__2_2 :-
    HeadVar__2_2 = string.float_to_string(Flt_3).
string.c_pointer_to_string(P_3) = S_4 :-
    string.c_pointer_to_string(P_3, S_4).
string.from_c_pointer(P_3) = S_4 :-
    string.c_pointer_to_string(P_3, S_4).
:- pragma foreign_proc("C", string.first_char(Str :: (builtin.uo), First :: (builtin.in), Rest :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    size_t len = strlen(Rest) + 1;
    MR_allocate_aligned_string_msg(Str, len, MR_PROC_LABEL);
    Str[0] = First;
    strcpy(Str + 1, Rest);
}").
:- pragma foreign_proc("C", string.first_char(Str :: (builtin.in), First :: (builtin.uo), Rest :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    First = Str[0];
    if (First == \'\\0\') {
        SUCCESS_INDICATOR = MR_FALSE;
    } else {
        Str++;
        /*
        ** We need to make a copy to ensure that the pointer is word-aligned.
        */
        MR_allocate_aligned_string_msg(Rest, strlen(Str), MR_PROC_LABEL);
        strcpy(Rest, Str);
        SUCCESS_INDICATOR = MR_TRUE;
    }
}").
:- pragma foreign_proc("C", string.first_char(Str :: (builtin.in), First :: (builtin.in), Rest :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    if (Str[0] != First || First == \'\\0\') {
        SUCCESS_INDICATOR = MR_FALSE;
    } else {
        Str++;
        /*
        ** We need to make a copy to ensure that the pointer is word-aligned.
        */
        MR_allocate_aligned_string_msg(Rest, strlen(Str), MR_PROC_LABEL);
        strcpy(Rest, Str);
        SUCCESS_INDICATOR = MR_TRUE;
    }
}").
:- pragma foreign_proc("C", string.first_char(Str :: (builtin.in), First :: (builtin.uo), Rest :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    First = Str[0];
    SUCCESS_INDICATOR = (First != \'\\0\' && strcmp(Str + 1, Rest) == 0);
").
:- pragma foreign_proc("C", string.first_char(Str :: (builtin.in), First :: (builtin.in), Rest :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    SUCCESS_INDICATOR = (
        Str[0] == First &&
        First != \'\\0\' &&
        strcmp(Str + 1, Rest) == 0
    );
").
string.replace_all(S1_5, S2_6, S3_7) = S4_8 :-
    string.replace_all(S1_5, S2_6, S3_7, S4_8).
string.to_lower(S1_3) = S2_4 :-
    string.to_lower(S1_3, S2_4).
string.to_lower(StrIn_3, StrOut_4) :-
    string.to_char_list(StrIn_3, List_5),
    string.char_list_to_lower(List_5, ListLow_6),
    string.from_char_list(ListLow_6, StrOut_4).
string.to_upper(S1_3) = S2_4 :-
    string.to_upper(S1_3, S2_4).
string.to_upper(StrIn_3, StrOut_4) :-
    string.to_char_list(StrIn_3, List_5),
    string.char_list_to_upper(List_5, ListUpp_6),
    string.from_char_list(ListUpp_6, StrOut_4).
string.capitalize_first(S1_3) = S2_4 :-
    string.capitalize_first(S1_3, S2_4).
string.uncapitalize_first(S1_3) = S2_4 :-
    string.uncapitalize_first(S1_3, S2_4).
string.to_char_list(S_3) = Cs_4 :-
    string.to_char_list(S_3, Cs_4).
string.from_char_list(Cs_3) = S_4 :-
    string.from_char_list(Cs_3, S_4).
:- pragma promise_equivalent_clauses((string.semidet_from_char_list)/2).
:- pragma foreign_proc("C", string.semidet_from_char_list(CharList :: (builtin.in), Str :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    /* mode (uo, in) is det */
    MR_Word char_list_ptr;
    size_t size;

    /*
    ** Loop to calculate list length + sizeof(MR_Word) in `size\'
    ** using list in `char_list_ptr\'.
    */
    size = 0;
    char_list_ptr = CharList;
    while (! MR_list_is_empty(char_list_ptr)) {
        size++;
        char_list_ptr = MR_list_tail(char_list_ptr);
    }

    /*
    ** Allocate heap space for string
    */
    MR_allocate_aligned_string_msg(Str, size, MR_PROC_LABEL);

    /*
    ** Loop to copy the characters from the char_list to the string.
    */
    SUCCESS_INDICATOR = MR_TRUE;
    size = 0;
    char_list_ptr = CharList;
    while (! MR_list_is_empty(char_list_ptr)) {
        MR_Char c;
        c = (MR_Char) MR_list_head(char_list_ptr);
        /*
        ** It is an error to put a null character in a string
        ** (see the comments at the top of this file).
        */
        if (c == \'\\0\') {
            SUCCESS_INDICATOR = MR_FALSE;
            break;
        }
        Str[size++] = c;
        char_list_ptr = MR_list_tail(char_list_ptr);
    }

    Str[size] = \'\\0\';
}").
string.from_rev_char_list(Cs_3) = S_4 :-
    string.from_rev_char_list(Cs_3, S_4).
:- pragma foreign_proc("C", string.semidet_from_rev_char_list(Chars :: (builtin.in), Str :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Word list_ptr;
    MR_Word size;

    /*
    ** Loop to calculate list length in `size\' using list in `list_ptr\'
    */
    size = 0;
    list_ptr = Chars;
    while (!MR_list_is_empty(list_ptr)) {
        size++;
        list_ptr = MR_list_tail(list_ptr);
    }

    /*
    ** Allocate heap space for string
    */
    MR_allocate_aligned_string_msg(Str, size, MR_PROC_LABEL);

    /*
    ** Set size to be the offset of the end of the string
    ** (ie the \\0) and null terminate the string.
    */
    Str[size] = \'\\0\';

    /*
    ** Loop to copy the characters from the list_ptr to the string
    ** in reverse order.
    */
    list_ptr = Chars;
    SUCCESS_INDICATOR = MR_TRUE;
    while (!MR_list_is_empty(list_ptr)) {
        MR_Char c;
        c = (MR_Char) MR_list_head(list_ptr);
        if (c == \'\\0\') {
            SUCCESS_INDICATOR = MR_FALSE;
            break;
        }
        Str[--size] = c;
        list_ptr = MR_list_tail(list_ptr);
    }
}").
string.det_to_int(S_3) = HeadVar__2_2 :-
    HeadVar__2_2 = string.det_base_string_to_int(V_4, S_3),
    V_4 = 10 : int.
string.to_int(String_3, Int_4) :-
    V_5 = 10 : int,
    string.base_string_to_int(V_5, String_3, Int_4).
string.det_to_float(FloatString_3) = HeadVar__2_2 :-
    (if
      string.to_float(FloatString_3, FloatVal_4)
    then
      HeadVar__2_2 = FloatVal_4
    else
      HeadVar__2_2 = require.func_error(V_5),
      V_5 = "string.det_to_float/1 - conversion failed." : string
    ).
:- pragma foreign_proc("C", string.to_float(FloatString :: (builtin.in), FloatVal :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    /*
    ** The %c checks for any erroneous characters appearing after the float;
    ** if there are then sscanf() will return 2 rather than 1.
    */
    char    tmpc;
    SUCCESS_INDICATOR =
        (!MR_isspace(FloatString[0])) &&
        (sscanf(FloatString, MR_FLT_FMT \"%c\", &FloatVal, &tmpc) == 1);
        /* MR_TRUE if sscanf succeeds, MR_FALSE otherwise */
}").
string.is_all_alpha(S_2) :-
    V_3 = char.is_alpha : (pred character),
    string.all_match(V_3, S_2).
string.is_all_alpha_or_underscore(S_2) :-
    V_3 = char.is_alpha_or_underscore : (pred character),
    string.all_match(V_3, S_2).
string.is_all_alnum_or_underscore(S_2) :-
    V_3 = char.is_alnum_or_underscore : (pred character),
    string.all_match(V_3, S_2).
string.pad_left(S1_5, C_6, N_7) = S2_8 :-
    string.pad_left(S1_5, C_6, N_7, S2_8).
string.pad_right(S1_5, C_6, N_7) = S2_8 :-
    string.pad_right(S1_5, C_6, N_7, S2_8).
string.duplicate_char(C_4, N_5) = S_6 :-
    string.duplicate_char(C_4, N_5, S_6).
string.duplicate_char(Char_4, Count_5, String_6) :-
    String_6 = string.from_char_list(V_7),
    V_7 = list.duplicate(Count_5, Char_4).
:- pragma foreign_proc("C", string.contains_char(Str :: (builtin.in), Ch :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    SUCCESS_INDICATOR = (strchr(Str, Ch) != NULL) && Ch != \'\\0\';
").
:- pragma inline((string.index)/3).
string.index(Str_4, Index_5, Char_6) :-
    Len_7 = string.length(Str_4),
    (if
      string.index_check(Index_5, Len_7)
    then
      string.unsafe_index(Str_4, Index_5, Char_6)
    else
      fail
    ).
string.index_det(S_4, N_5) = C_6 :-
    string.index_det(S_4, N_5, C_6).
:- pragma inline((string.index_det)/3).
string.index_det(String_4, Int_5, Char_6) :-
    (if
      string.index(String_4, Int_5, Char0_7)
    then
      Char_6 = Char0_7
    else
      V_8 = "string.index_det: index out of range" : string,
      require.error(V_8)
    ).
string.elem(Index_5, String_4) = HeadVar__3_3 :-
    HeadVar__3_3 = string.index_det(String_4, Index_5).
string.unsafe_index(S_4, N_5) = C_6 :-
    string.unsafe_index(S_4, N_5, C_6).
:- pragma foreign_proc("C", string.unsafe_index(Str :: (builtin.in), Index :: (builtin.in), Ch :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    Ch = Str[Index];
").
string.unsafe_elem(Index_5, String_4) = HeadVar__3_3 :-
    HeadVar__3_3 = string.unsafe_index(String_4, Index_5).
string.lstrip(S_3) = HeadVar__2_2 :-
    HeadVar__2_2 = string.lstrip_pred(V_4, S_3),
    V_4 = char.is_whitespace : (pred character).
string.rstrip(S_3) = HeadVar__2_2 :-
    HeadVar__2_2 = string.rstrip_pred(V_4, S_3),
    V_4 = char.is_whitespace : (pred character).
string.lstrip_pred(P_4, S_5) = HeadVar__3_3 :-
    HeadVar__3_3 = string.right(S_5, V_6),
    V_6 = int.(V_7 - V_8),
    V_7 = string.length(S_5),
    V_8 = string.prefix_length(P_4, S_5).
string.rstrip_pred(P_4, S_5) = HeadVar__3_3 :-
    HeadVar__3_3 = string.left(S_5, V_6),
    V_6 = int.(V_7 - V_8),
    V_7 = string.length(S_5),
    V_8 = string.suffix_length(P_4, S_5).
string.prefix_length(P_4, S_5) = HeadVar__3_3 :-
    HeadVar__3_3 = string.prefix_length_2(V_6, V_7, P_4, S_5),
    V_6 = 0 : int,
    V_7 = string.length(S_5).
string.suffix_length(P_4, S_5) = HeadVar__3_3 :-
    HeadVar__3_3 = string.suffix_length_2(V_6, V_7, P_4, S_5),
    V_6 = int.(V_8 - V_9),
    V_8 = string.length(S_5),
    V_9 = 1 : int,
    V_7 = string.length(S_5).
string.set_char_det(C_5, N_6, S0_7) = S_8 :-
    string.set_char_det(C_5, N_6, S0_7, S_8).
string.unsafe_set_char(C_5, N_6, S0_7) = S_8 :-
    string.unsafe_set_char(C_5, N_6, S0_7, S_8).
string.foldl(F_5, S_6, A_7) = B_8 :-
    P_9 = (pred(V_15::(builtin.in), V_14::(builtin.in), V_13::(builtin.out)) is det :-
      some [] (
        V_15 = X_16,
        V_14 = Y_17,
        Z_18 = apply(F_5, X_16, Y_17),
        V_13 = Z_18
      )
    ) : pred(character, A_1, A_1),
    string.foldl(P_9, S_6, A_7, B_8).
string.foldl(Closure_5, String_6, STATE_VARIABLE_Acc_0_9, STATE_VARIABLE_Acc_10) :-
    string.length(String_6, Length_8),
    V_12 = 0 : int,
    string.foldl_substring(Closure_5, String_6, V_12, Length_8, STATE_VARIABLE_Acc_0_9, STATE_VARIABLE_Acc_1_11),
    STATE_VARIABLE_Acc_10 = STATE_VARIABLE_Acc_1_11.
string.foldl2(Closure_7, String_8, STATE_VARIABLE_Acc1_0_12, STATE_VARIABLE_Acc1_13, STATE_VARIABLE_Acc2_0_14, STATE_VARIABLE_Acc2_15) :-
    string.length(String_8, Length_11),
    V_18 = 0 : int,
    string.foldl2_substring(Closure_7, String_8, V_18, Length_11, STATE_VARIABLE_Acc1_0_12, STATE_VARIABLE_Acc1_1_16, STATE_VARIABLE_Acc2_0_14, STATE_VARIABLE_Acc2_1_17),
    STATE_VARIABLE_Acc2_15 = STATE_VARIABLE_Acc2_1_17,
    STATE_VARIABLE_Acc1_13 = STATE_VARIABLE_Acc1_1_16.
string.foldl_substring(F_7, S_8, Start_9, Count_10, A_11) = B_12 :-
    P_13 = (pred(V_19::(builtin.in), V_18::(builtin.in), V_17::(builtin.out)) is det :-
      some [] (
        V_19 = X_20,
        V_18 = Y_21,
        Z_22 = apply(F_7, X_20, Y_21),
        V_17 = Z_22
      )
    ) : pred(character, A_1, A_1),
    string.foldl_substring(P_13, S_8, Start_9, Count_10, A_11, B_12).
string.foldl_substring(Closure_7, String_8, Start0_9, Count0_10, STATE_VARIABLE_Acc_0_14, STATE_VARIABLE_Acc_15) :-
    Start_12 = int.max(V_17, Start0_9),
    V_17 = 0 : int,
    Count_13 = int.min(Count0_10, V_18),
    V_18 = int.(V_19 - Start_12),
    V_19 = string.length(String_8),
    string.foldl_substring_2(Closure_7, String_8, Start_12, Count_13, STATE_VARIABLE_Acc_0_14, STATE_VARIABLE_Acc_1_16),
    STATE_VARIABLE_Acc_15 = STATE_VARIABLE_Acc_1_16.
string.foldl2_substring(Closure_9, String_10, Start0_11, Count0_12, STATE_VARIABLE_Acc1_0_17, STATE_VARIABLE_Acc1_18, STATE_VARIABLE_Acc2_0_19, STATE_VARIABLE_Acc2_20) :-
    Start_15 = int.max(V_23, Start0_11),
    V_23 = 0 : int,
    Count_16 = int.min(Count0_12, V_24),
    V_24 = int.(V_25 - Start_15),
    V_25 = string.length(String_10),
    string.foldl2_substring_2(Closure_9, String_10, Start_15, Count_16, STATE_VARIABLE_Acc1_0_17, STATE_VARIABLE_Acc1_1_21, STATE_VARIABLE_Acc2_0_19, STATE_VARIABLE_Acc2_1_22),
    STATE_VARIABLE_Acc2_20 = STATE_VARIABLE_Acc2_1_22,
    STATE_VARIABLE_Acc1_18 = STATE_VARIABLE_Acc1_1_21.
string.foldr(F_5, String_6, Acc0_7) = Acc_8 :-
    Closure_9 = (pred(V_15::(builtin.in), V_14::(builtin.in), V_13::(builtin.out)) is det :-
      some [] (
        V_15 = X_16,
        V_14 = Y_17,
        Z_18 = apply(F_5, X_16, Y_17),
        V_13 = Z_18
      )
    ) : pred(character, T_1, T_1),
    string.foldr(Closure_9, String_6, Acc0_7, Acc_8).
string.foldr(Closure_5, String_6, Acc0_7, Acc_8) :-
    V_9 = 0 : int,
    V_10 = string.length(String_6),
    string.foldr_substring(Closure_5, String_6, V_9, V_10, Acc0_7, Acc_8).
string.foldr_substring(F_7, String_8, Start_9, Count_10, Acc0_11) = Acc_12 :-
    Closure_13 = (pred(V_19::(builtin.in), V_18::(builtin.in), V_17::(builtin.out)) is det :-
      some [] (
        V_19 = X_20,
        V_18 = Y_21,
        Z_22 = apply(F_7, X_20, Y_21),
        V_17 = Z_22
      )
    ) : pred(character, T_1, T_1),
    string.foldr_substring(Closure_13, String_8, Start_9, Count_10, Acc0_11, Acc_12).
string.foldr_substring(Closure_7, String_8, Start0_9, Count0_10, Acc0_11, Acc_12) :-
    Start_13 = int.max(V_15, Start0_9),
    V_15 = 0 : int,
    Count_14 = int.min(Count0_10, V_16),
    V_16 = int.(V_17 - Start_13),
    V_17 = string.length(String_8),
    string.foldr_substring_2(Closure_7, String_8, Start_13, Count_14, Acc0_11, Acc_12).
string.words_separator(SepP_4, String_5) = Words_6 :-
    I_7 = string.preceding_boundary(V_8, String_5, V_9),
    V_8 = std_util.isnt(SepP_4) : (pred character),
    V_9 = int.(V_10 - V_11),
    V_10 = string.length(String_5),
    V_11 = 1 : int,
    Words_6 = string.words_2(SepP_4, String_5, I_7, V_12),
    V_12 = list.[] : (list.list(string)).
string.words(String_3) = HeadVar__2_2 :-
    HeadVar__2_2 = string.words_separator(V_4, String_3),
    V_4 = char.is_whitespace : (pred character).
string.split_at_separator(DelimPred_4, InStr_5) = OutStrs_6 :-
    Count_7 = string.length(InStr_5),
    V_8 = Count_7,
    V_9 = list.[] : (list.list(string)),
    string.split_at_separator2(DelimPred_4, InStr_5, Count_7, V_8, V_9, OutStrs_6).
string.split_at_char(C_4, String_5) = HeadVar__3_3 :-
    HeadVar__3_3 = string.split_at_separator(V_6, String_5),
    V_6 = builtin.unify(C_4) : (pred character).
string.split_at_string(Needle_4, Total_5) = HeadVar__3_3 :-
    HeadVar__3_3 = string.split_at_string(V_6, V_7, Needle_4, Total_5),
    V_6 = 0 : int,
    V_7 = string.length(Needle_4).
:- pragma foreign_proc("C", string.split(Str :: (builtin.in), Count :: (builtin.in), Left :: (builtin.uo), Right :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Integer  len;
    MR_Word     tmp;

    if (Count <= 0) {
        MR_make_aligned_string(Left, \"\");
        Right = Str;
    } else {
        len = strlen(Str);

        if (Count > len) {
            Count = len;
        }

        MR_allocate_aligned_string_msg(Left, Count, MR_PROC_LABEL);
        MR_memcpy(Left, Str, Count);
        Left[Count] = \'\\0\';
        /*
        ** We need to make a copy to ensure that the pointer is word-aligned.
        */
        MR_allocate_aligned_string_msg(Right, len - Count, MR_PROC_LABEL);
        strcpy(Right, Str + Count);
    }
}").
string.left(S1_4, N_5) = S2_6 :-
    string.left(S1_4, N_5, S2_6).
string.left(String_4, Count_5, LeftString_6) :-
    string.split(String_4, Count_5, LeftString_6, _RightString_7).
string.right(S1_4, N_5) = S2_6 :-
    string.right(S1_4, N_5, S2_6).
string.right(String_4, RightCount_5, RightString_6) :-
    string.length(String_4, Length_7),
    LeftCount_8 = int.(Length_7 - RightCount_5),
    string.split(String_4, LeftCount_8, _LeftString_9, RightString_6).
string.substring(S1_5, N1_6, N2_7) = S2_8 :-
    string.substring(S1_5, N1_6, N2_7, S2_8).
:- pragma foreign_proc("C", string.substring(Str :: (builtin.in), Start :: (builtin.in), Count :: (builtin.in), SubString :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Integer  len;
    MR_Word     tmp;

    if (Start < 0) Start = 0;
    if (Count <= 0) {
        MR_make_aligned_string(SubString, \"\");
    } else {
        len = strlen(Str);
        if (Start > len) Start = len;
        if (Count > len - Start) Count = len - Start;
        MR_allocate_aligned_string_msg(SubString, Count, MR_PROC_LABEL);
        MR_memcpy(SubString, Str + Start, Count);
        SubString[Count] = \'\\0\';
    }
}").
string.unsafe_substring(S1_5, N1_6, N2_7) = S2_8 :-
    string.unsafe_substring(S1_5, N1_6, N2_7, S2_8).
:- pragma foreign_proc("C", string.unsafe_substring(Str :: (builtin.in), Start :: (builtin.in), Count :: (builtin.in), SubString :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Integer len;

    MR_allocate_aligned_string_msg(SubString, Count, MR_PROC_LABEL);
    MR_memcpy(SubString, Str + Start, Count);
    SubString[Count] = \'\\0\';
}").
:- pragma foreign_proc("C", string.append_list(Strs :: (builtin.in)) = (Str :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Word list = Strs;
    MR_Word tmp;
    size_t  len;

    /* Determine the total length of all strings */
    len = 0;
    while (!MR_list_is_empty(list)) {
        len += strlen((MR_String) MR_list_head(list));
        list = MR_list_tail(list);
    }

    /* Allocate enough word aligned memory for the string */
    MR_allocate_aligned_string_msg(Str, len, MR_PROC_LABEL);

    /* Copy the strings into the new memory */
    len = 0;
    list = Strs;
    while (!MR_list_is_empty(list)) {
        strcpy((MR_String) Str + len, (MR_String) MR_list_head(list));
        len += strlen((MR_String) MR_list_head(list));
        list = MR_list_tail(list);
    }

    Str[len] = \'\\0\';
}").
string.append_list(Lists_3, HeadVar__2_2) :-
    HeadVar__2_2 = string.append_list(Lists_3).
:- pragma foreign_proc("C", string.join_list(Sep :: (builtin.in), Strs :: (builtin.in)) = (Str :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    MR_Word list;
    MR_Word tmp;
    size_t  len;
    size_t  sep_len;
    MR_bool add_sep;

    list = Strs;
    len = 0;
    sep_len = strlen(Sep);

    /* Determine the total length of all strings */
    len = 0;
    add_sep = MR_FALSE;
    while (!MR_list_is_empty(list)) {
        if (add_sep) {
            len += sep_len;
        }

        len += strlen((MR_String) MR_list_head(list));
        list = MR_list_tail(list);
        add_sep = MR_TRUE;
    }

    MR_allocate_aligned_string_msg(Str, len, MR_PROC_LABEL);

    /* Copy the strings into the new memory */
    len = 0;
    list = Strs;
    add_sep = MR_FALSE;
    while (!MR_list_is_empty(list)) {
        if (add_sep) {
            strcpy((MR_String) Str + len, Sep);
            len += sep_len;
        }

        strcpy((MR_String) Str + len, (MR_String) MR_list_head(list));
        len += strlen((MR_String) MR_list_head(list));
        list = MR_list_tail(list);
        add_sep = MR_TRUE;
    }

    Str[len] = \'\\0\';
}").
string.hash(S_3) = N_4 :-
    string.hash(S_3, N_4).
string.sub_string_search(WholeString_4, Pattern_5, Index_6) :-
    V_7 = 0 : int,
    string.sub_string_search_start(WholeString_4, Pattern_5, V_7, Index_6).
:- pragma foreign_proc("C", string.sub_string_search_start(WholeString :: (builtin.in), Pattern :: (builtin.in), BeginAt :: (builtin.in), Index :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "{
    char *match;
    match = strstr(WholeString + BeginAt, Pattern);
    if (match) {
        Index = match - WholeString;
        SUCCESS_INDICATOR = MR_TRUE;
    } else {
        SUCCESS_INDICATOR = MR_FALSE;
    }
}").
string.format(S1_4, PT_5) = S2_6 :-
    string.format(S1_4, PT_5, S2_6).
string.word_wrap(Str_4, N_5) = HeadVar__3_3 :-
    HeadVar__3_3 = string.word_wrap_separator(Str_4, N_5, V_6),
    V_6 = "" : string.
string.foldl_substring_2(Closure_7, String_8, I_9, Count_10, STATE_VARIABLE_Acc_0_12, STATE_VARIABLE_Acc_13) :-
    (if
      V_15 = 0 : int,
      int.(V_15 < Count_10)
    then
      V_16 = string.unsafe_index(String_8, I_9),
      call(Closure_7, V_16, STATE_VARIABLE_Acc_0_12, STATE_VARIABLE_Acc_1_14),
      V_18 = int.(I_9 + V_20),
      V_20 = 1 : int,
      V_19 = int.(Count_10 - V_21),
      V_21 = 1 : int,
      string.foldl_substring_2(Closure_7, String_8, V_18, V_19, STATE_VARIABLE_Acc_1_14, STATE_VARIABLE_Acc_3_17)
    else
      STATE_VARIABLE_Acc_3_17 = STATE_VARIABLE_Acc_0_12
    ),
    STATE_VARIABLE_Acc_13 = STATE_VARIABLE_Acc_3_17.
string.foldl2_substring_2(Closure_9, String_10, I_11, Count_12, STATE_VARIABLE_Acc1_0_15, STATE_VARIABLE_Acc1_16, STATE_VARIABLE_Acc2_0_17, STATE_VARIABLE_Acc2_18) :-
    (if
      V_21 = 0 : int,
      int.(V_21 < Count_12)
    then
      V_22 = string.unsafe_index(String_10, I_11),
      call(Closure_9, V_22, STATE_VARIABLE_Acc1_0_15, STATE_VARIABLE_Acc1_1_19, STATE_VARIABLE_Acc2_0_17, STATE_VARIABLE_Acc2_1_20),
      V_25 = int.(I_11 + V_27),
      V_27 = 1 : int,
      V_26 = int.(Count_12 - V_28),
      V_28 = 1 : int,
      string.foldl2_substring_2(Closure_9, String_10, V_25, V_26, STATE_VARIABLE_Acc1_1_19, STATE_VARIABLE_Acc1_3_23, STATE_VARIABLE_Acc2_1_20, STATE_VARIABLE_Acc2_3_24)
    else
      STATE_VARIABLE_Acc2_3_24 = STATE_VARIABLE_Acc2_0_17,
      STATE_VARIABLE_Acc1_3_23 = STATE_VARIABLE_Acc1_0_15
    ),
    STATE_VARIABLE_Acc2_18 = STATE_VARIABLE_Acc2_3_24,
    STATE_VARIABLE_Acc1_16 = STATE_VARIABLE_Acc1_3_23.
string.foldr_substring_2(Closure_7, String_8, I_9, Count_10, STATE_VARIABLE_Acc_0_12, STATE_VARIABLE_Acc_13) :-
    (if
      V_15 = 0 : int,
      int.(V_15 < Count_10)
    then
      V_16 = string.unsafe_index(String_8, V_17),
      V_17 = int.(V_18 - V_19),
      V_18 = int.(I_9 + Count_10),
      V_19 = 1 : int,
      call(Closure_7, V_16, STATE_VARIABLE_Acc_0_12, STATE_VARIABLE_Acc_1_14),
      V_21 = int.(Count_10 - V_22),
      V_22 = 1 : int,
      string.foldr_substring_2(Closure_7, String_8, I_9, V_21, STATE_VARIABLE_Acc_1_14, STATE_VARIABLE_Acc_3_20)
    else
      STATE_VARIABLE_Acc_3_20 = STATE_VARIABLE_Acc_0_12
    ),
    STATE_VARIABLE_Acc_13 = STATE_VARIABLE_Acc_3_20.
string.all_match(P_3, String_4) :-
    V_5 = int.(V_6 - V_7),
    V_6 = string.length(String_4),
    V_7 = 1 : int,
    string.all_match_2(V_5, P_3, String_4).
string.all_match_2(I_4, P_5, String_6) :-
    (if
      V_7 = 0 : int,
      int.(I_4 >= V_7)
    then
      V_8 = string.unsafe_index(String_6, I_4),
      call(P_5, V_8),
      V_9 = int.(I_4 - V_10),
      V_10 = 1 : int,
      string.all_match_2(V_9, P_5, String_6)
    else
      true
    ).
:- pragma foreign_proc("C", string.index_check(Index :: (builtin.in), Length :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    /*
    ** We do not test for negative values of Index because (a) MR_Unsigned
    ** is unsigned and hence a negative argument will appear as a very large
    ** positive one after the cast and (b) anybody dealing with the case
    ** where strlen(Str) > MAXINT is clearly barking mad (and one may well get
    ** an integer overflow error in this case).
    */
    SUCCESS_INDICATOR = ((MR_Unsigned) Index < (MR_Unsigned) Length);
").
string.words_2(SepP_6, String_7, WordEnd_8, Words0_9) = Words_10 :-
    (if
      V_14 = 0 : int,
      int.(WordEnd_8 < V_14)
    then
      Words_10 = Words0_9
    else
      WordPre_11 = string.preceding_boundary(SepP_6, String_7, WordEnd_8),
      Word_12 = string.unsafe_substring(String_7, V_15, V_16),
      V_15 = int.(WordPre_11 + V_17),
      V_17 = 1 : int,
      V_16 = int.(WordEnd_8 - WordPre_11),
      PrevWordEnd_13 = string.preceding_boundary(V_18, String_7, WordPre_11),
      V_18 = std_util.isnt(SepP_6) : (pred character),
      Words_10 = string.words_2(SepP_6, String_7, PrevWordEnd_13, V_19),
      V_19 = list.[Word_12 | Words0_9] : (list.list(string))
    ).
string.split_at_separator2(DelimPred_7, Str_8, I_9, ThisSegEnd_10, ITail_11, OTail_12) :-
    (if
      V_16 = 0 : int,
      int.(I_9 < V_16)
    then
      (if
        V_17 = 0 : int,
        int.(ThisSegEnd_10 < V_17)
      then
        OTail_12 = list.[V_18 | ITail_11] : (list.list(string)),
        V_18 = "" : string
      else
        ThisSeg_13 = string.unsafe_substring(Str_8, V_19, V_20),
        V_19 = 0 : int,
        V_20 = int.(ThisSegEnd_10 + V_21),
        V_21 = 1 : int,
        OTail_12 = list.[ThisSeg_13 | ITail_11] : (list.list(string))
      )
    else
      C_14 = string.unsafe_index(Str_8, I_9),
      (if
        call(DelimPred_7, C_14)
      then
        ThisSeg_31 = string.unsafe_substring(Str_8, V_22, V_23),
        V_22 = int.(I_9 + V_24),
        V_24 = 1 : int,
        V_23 = int.(ThisSegEnd_10 - I_9),
        TTail_15 = list.[ThisSeg_31 | ITail_11] : (list.list(string)),
        V_25 = int.(I_9 - V_27),
        V_27 = 1 : int,
        V_26 = int.(I_9 - V_28),
        V_28 = 1 : int,
        string.split_at_separator2(DelimPred_7, Str_8, V_25, V_26, TTail_15, OTail_12)
      else
        V_29 = int.(I_9 - V_30),
        V_30 = 1 : int,
        string.split_at_separator2(DelimPred_7, Str_8, V_29, ThisSegEnd_10, ITail_11, OTail_12)
      )
    ).
string.preceding_boundary(SepP_5, String_6, I_7) = HeadVar__4_4 :-
    (if
      V_8 = 0 : int,
      int.(I_7 < V_8)
    then
      HeadVar__4_4 = I_7
    else
      (if
        V_9 = string.unsafe_index(String_6, I_7),
        call(SepP_5, V_9)
      then
        HeadVar__4_4 = I_7
      else
        HeadVar__4_4 = string.preceding_boundary(SepP_5, String_6, V_10),
        V_10 = int.(I_7 - V_11),
        V_11 = 1 : int
      )
    ).
string.prefix_length_2(I_6, N_7, P_8, S_9) = HeadVar__5_5 :-
    (if
      int.(I_6 < N_7)
    then
      (if
        V_10 = string.unsafe_elem(I_6, S_9),
        call(P_8, V_10)
      then
        HeadVar__5_5 = string.prefix_length_2(V_11, N_7, P_8, S_9),
        V_11 = int.(I_6 + V_12),
        V_12 = 1 : int
      else
        HeadVar__5_5 = I_6
      )
    else
      HeadVar__5_5 = I_6
    ).
string.suffix_length_2(I_6, N_7, P_8, S_9) = HeadVar__5_5 :-
    (if
      V_10 = 0 : int,
      int.(V_10 =< I_6)
    then
      (if
        V_11 = string.unsafe_elem(I_6, S_9),
        call(P_8, V_11)
      then
        HeadVar__5_5 = string.suffix_length_2(V_12, N_7, P_8, S_9),
        V_12 = int.(I_6 - V_13),
        V_13 = 1 : int
      else
        HeadVar__5_5 = int.(N_7 - V_14),
        V_14 = int.(I_6 + V_15),
        V_15 = 1 : int
      )
    else
      HeadVar__5_5 = int.(N_7 - V_16),
      V_16 = int.(I_6 + V_17),
      V_17 = 1 : int
    ).
:- pragma exceptions(function, (string.length), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.length), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.length), 2, 1, will_not_throw).
:- pragma exceptions(function, (string.append), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append), 3, 1, will_not_throw).
:- pragma exceptions(predicate, (string.append), 3, 2, will_not_throw).
:- pragma exceptions(predicate, (string.append), 3, 3, will_not_throw).
:- pragma exceptions(function, (string.(++)), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.remove_suffix), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.remove_suffix_if_present), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.prefix), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.prefix), 2, 1, will_not_throw).
:- pragma exceptions(predicate, (string.suffix), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.suffix), 2, 1, will_not_throw).
:- pragma exceptions(function, (string.string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.string_ops), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.string_ops_noncanon), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.string_ops_noncanon), 4, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.string_ops_noncanon), 4, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.string_ops_noncanon), 4, 3, may_throw(user_exception)).
:- pragma exceptions(function, (string.char_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.char_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.char_to_string), 2, 1, will_not_throw).
:- pragma exceptions(function, (string.from_char), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.int_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.int_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.from_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.int_to_string_thousands), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.int_to_base_string), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.int_to_base_string), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.int_to_base_string_group), 5, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.float_to_string), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.float_to_string), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.from_float), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.c_pointer_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.c_pointer_to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.from_c_pointer), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.first_char), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.first_char), 3, 1, will_not_throw).
:- pragma exceptions(predicate, (string.first_char), 3, 2, will_not_throw).
:- pragma exceptions(predicate, (string.first_char), 3, 3, will_not_throw).
:- pragma exceptions(predicate, (string.first_char), 3, 4, will_not_throw).
:- pragma exceptions(predicate, (string.replace), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.replace_all), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.replace_all), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.to_lower), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_lower), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_lower), 2, 1, may_throw(user_exception)).
:- pragma exceptions(function, (string.to_upper), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_upper), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_upper), 2, 1, may_throw(user_exception)).
:- pragma exceptions(function, (string.capitalize_first), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.capitalize_first), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.uncapitalize_first), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.uncapitalize_first), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.to_char_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.to_char_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.to_char_list), 2, 1, may_throw(user_exception)).
:- pragma exceptions(function, (string.from_char_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.from_char_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.from_char_list), 2, 1, will_not_throw).
:- pragma exceptions(predicate, (string.semidet_from_char_list), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.from_rev_char_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.from_rev_char_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.semidet_from_rev_char_list), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.det_to_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.base_string_to_int), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.det_base_string_to_int), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.det_to_float), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.to_float), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.is_all_alpha), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.is_all_alpha_or_underscore), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.is_all_alnum_or_underscore), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.pad_left), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.pad_left), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.pad_right), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.pad_right), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.duplicate_char), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.duplicate_char), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.contains_char), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.index), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.index_det), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.index_det), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.elem), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.unsafe_index), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.unsafe_index), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.unsafe_elem), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.chomp), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.lstrip), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.rstrip), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.strip), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.lstrip_pred), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.rstrip_pred), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.prefix_length), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.suffix_length), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.set_char), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.set_char_det), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.set_char_det), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.unsafe_set_char), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.unsafe_set_char), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldl), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl), 4, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2), 6, 5, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldl_substring), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring), 6, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring), 8, 5, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldr), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr), 4, 4, may_throw(user_exception)).
:- pragma exceptions(function, (string.foldr_substring), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring), 6, 4, may_throw(user_exception)).
:- pragma exceptions(function, (string.words_separator), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.words), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.split_at_separator), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.split_at_char), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.split_at_string), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.split), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.left), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.left), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.right), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.right), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.substring), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.substring), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.unsafe_substring), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (string.unsafe_substring), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.append_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (string.append_list), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.join_list), 3, 0, will_not_throw).
:- pragma exceptions(function, (string.hash), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.hash), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.sub_string_search), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (string.sub_string_search_start), 4, 0, will_not_throw).
:- pragma exceptions(function, (string.format), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.format), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.format_table), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.format_table_max), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.word_wrap), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.word_wrap_separator), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring_2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring_2), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring_2), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring_2), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl_substring_2), 6, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring_2), 8, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring_2), 8, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring_2), 8, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring_2), 8, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring_2), 8, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldl2_substring_2), 8, 5, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring_2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring_2), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring_2), 6, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring_2), 6, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.foldr_substring_2), 6, 4, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.char_list_to_upper), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.char_list_to_lower), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.all_match), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.all_match_2), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.index_check), 2, 0, will_not_throw).
:- pragma exceptions(function, (string.words_2), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.split_at_separator2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.split_at_string), 5, 0, will_not_throw).
:- pragma exceptions(function, (string.preceding_boundary), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.prefix_length_2), 5, 0, may_throw(user_exception)).
:- pragma exceptions(function, (string.suffix_length_2), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.value_to_revstrings), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.value_to_revstrings), 5, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.value_to_revstrings), 5, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.value_to_revstrings), 5, 3, may_throw(user_exception)).
:- pragma exceptions(predicate, (string.char_list_remove_suffix), 3, 0, may_throw(user_exception)).
:- pragma termination_info(string.length((builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.length((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.length((builtin.ui), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.append((builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.append((builtin.in), (builtin.in), (builtin.in)), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(string.append((builtin.in), (builtin.uo), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.append((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.append((builtin.out), (builtin.out), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.'++'((builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.remove_suffix((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.remove_suffix_if_present((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.prefix((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.prefix((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.suffix((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.suffix((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.string((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.string_ops((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.string_ops_noncanon(builtin.in((deconstruct.do_not_allow)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.string_ops_noncanon(builtin.in((deconstruct.canonicalize)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.string_ops_noncanon(builtin.in((deconstruct.include_details_cc)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.string_ops_noncanon((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.char_to_string((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.char_to_string((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.char_to_string((builtin.out), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.from_char((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.int_to_string((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.int_to_string((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.from_int((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.int_to_string_thousands((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.int_to_base_string((builtin.in), (builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.int_to_base_string((builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.int_to_base_string_group((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.float_to_string((builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.float_to_string((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.from_float((builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.c_pointer_to_string((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.c_pointer_to_string((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.from_c_pointer((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.first_char((builtin.in), (builtin.in), (builtin.in)), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(string.first_char((builtin.in), (builtin.uo), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.first_char((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.first_char((builtin.in), (builtin.uo), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.first_char((builtin.uo), (builtin.in), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.replace((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.replace_all((builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.replace_all((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.to_lower((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.to_lower((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.to_lower((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.to_upper((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.to_upper((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.to_upper((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.capitalize_first((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.capitalize_first((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.uncapitalize_first((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.uncapitalize_first((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.to_char_list((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.to_char_list((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.to_char_list((builtin.uo), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.from_char_list((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.from_char_list((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.from_char_list((builtin.out), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(string.semidet_from_char_list((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.from_rev_char_list((builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.from_rev_char_list((builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.semidet_from_rev_char_list((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.det_to_int((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.to_int((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.base_string_to_int((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.det_base_string_to_int((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.det_to_float((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.to_float((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.is_all_alpha((builtin.in)), infinite, can_loop).
:- pragma termination_info(string.is_all_alpha_or_underscore((builtin.in)), infinite, can_loop).
:- pragma termination_info(string.is_all_alnum_or_underscore((builtin.in)), infinite, can_loop).
:- pragma termination_info(string.pad_left((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.pad_left((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.pad_right((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.pad_right((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.duplicate_char((builtin.in), (builtin.in)) = (builtin.uo), infinite, can_loop).
:- pragma termination_info(string.duplicate_char((builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.contains_char((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(string.index((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.index_det((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.index_det((builtin.in), (builtin.in), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.elem((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.unsafe_index((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_index((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_elem((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.chomp((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(string.lstrip((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.rstrip((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.strip((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.lstrip_pred(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.rstrip_pred(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.prefix_length(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.suffix_length(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.set_char((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.set_char_det((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.set_char_det((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.unsafe_set_char((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.unsafe_set_char((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.words_separator((pred((builtin.in)) is semidet), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.words((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.split_at_separator((pred((builtin.in)) is semidet), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.split_at_char((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.split_at_string((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.split((builtin.in), (builtin.in), (builtin.uo), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.left((builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.left((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.right((builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.right((builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.substring((builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.substring((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_substring((builtin.in), (builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.unsafe_substring((builtin.in), (builtin.in), (builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.append_list((builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.append_list((builtin.in), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(string.join_list((builtin.in), (builtin.in)) = (builtin.uo), infinite, cannot_loop).
:- pragma termination_info(string.hash((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.hash((builtin.in), (builtin.out)), finite(0, [no, no]), can_loop).
:- pragma termination_info(string.sub_string_search((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.sub_string_search_start((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(string.format((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.format((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.format_table((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.format_table_max((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.word_wrap((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.word_wrap_separator((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.foldl_substring_2((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring_2((pred((builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldl2_substring_2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring_2((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is nondet), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.foldr_substring_2((pred((builtin.in), (builtin.in), (builtin.out)) is multi), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.char_list_to_upper((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.char_list_to_lower((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.all_match(builtin.in((pred((builtin.in)) is semidet)), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.all_match_2((builtin.in), builtin.in((pred((builtin.in)) is semidet)), (builtin.in)), infinite, can_loop).
:- pragma termination_info(string.index_check((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(string.words_2(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.split_at_separator2(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.split_at_string((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.preceding_boundary(builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.prefix_length_2((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.suffix_length_2((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(string.value_to_revstrings(builtin.in((deconstruct.do_not_allow)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.value_to_revstrings(builtin.in((deconstruct.canonicalize)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.value_to_revstrings(builtin.in((deconstruct.include_details_cc)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.value_to_revstrings((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(string.char_list_remove_suffix((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
