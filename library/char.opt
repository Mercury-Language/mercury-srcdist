:- module char.
:- use_module builtin, enum, private_builtin, require.
:- instance (enum.enum(character)).
:- pragma foreign_import_module("C", char).
:- pragma foreign_import_module("C#", char).
:- pragma foreign_import_module("Java", char).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
char.to_int(C_3) = N_4 :-
    char.to_int(C_3, N_4).
:- pragma foreign_proc("C", char.to_int(Character :: (builtin.out), Int :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail, doesnt_affect_liveness], "
    /*
    ** If the integer doesn\'t fit into a char, then the assignment
    ** `Character = Int\' below will truncate it. SUCCESS_INDICATOR will be set
    ** to true only if the result was not truncated.
    */
    Character = Int;
    SUCCESS_INDICATOR = ((MR_UnsignedChar) Character == Int);
").
:- pragma foreign_proc("C", char.to_int(Character :: (builtin.in), Int :: (builtin.in)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    SUCCESS_INDICATOR = ((MR_UnsignedChar) Character == Int);
").
:- pragma foreign_proc("C", char.to_int(Character :: (builtin.in), Int :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    Int = (MR_UnsignedChar) Character;
").
char.from_int(Int_3, Char_4) :-
    char.to_int(Char_4, Int_3).
char.det_from_int(Int_3) = Char_4 :-
    char.det_from_int(Int_3, Char_4).
char.max_char_value = N_2 :-
    char.max_char_value(N_2).
:- pragma foreign_proc("C", char.max_char_value(Max :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail, doesnt_affect_liveness], "
    Max = UCHAR_MAX;
").
char.min_char_value = N_2 :-
    char.min_char_value(N_2).
char.min_char_value(0).
char.to_upper(C1_3) = C2_4 :-
    char.to_upper(C1_3, C2_4).
char.to_upper(Char_3, Upper_4) :-
    (if
      char.lower_upper(Char_3, UpperChar_5)
    then
      Upper_4 = UpperChar_5
    else
      Upper_4 = Char_3
    ).
char.to_lower(C1_3) = C2_4 :-
    char.to_lower(C1_3, C2_4).
char.to_lower(Char_3, Lower_4) :-
    (if
      char.lower_upper(LowerChar_5, Char_3)
    then
      Lower_4 = LowerChar_5
    else
      Lower_4 = Char_3
    ).
char.is_upper(Upper_2) :-
    (if
      char.lower_upper(V_3, Upper_2)
    then
      true
    else
      fail
    ).
char.is_lower(Lower_2) :-
    char.lower_upper(Lower_2, V_3).
char.is_alpha_or_underscore(Char_2) :-
    (if
      Char_2 = '_' : character
    then
      true
    else
      char.is_alpha(Char_2)
    ).
char.is_binary_digit('0').
char.is_binary_digit('1').
char.is_hex_digit(X_2) :-
    char.is_hex_digit(X_2, V_3).
char.digit_to_int(Digit_3, Int_4) :-
    (if
      char.lower_upper(Digit_3, Upper_5)
    then
      char.int_to_digit(Int_4, Upper_5)
    else
      char.int_to_digit(Int_4, Digit_3)
    ).
char.det_int_to_digit(N_3) = C_4 :-
    char.det_int_to_digit(N_3, C_4).
:- pragma exceptions(function, (char.to_int), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.to_int), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.to_int), 2, 1, will_not_throw).
:- pragma exceptions(predicate, (char.to_int), 2, 2, will_not_throw).
:- pragma exceptions(predicate, (char.from_int), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.det_from_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (char.det_from_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (char.max_char_value), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.max_char_value), 1, 0, will_not_throw).
:- pragma exceptions(function, (char.min_char_value), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.min_char_value), 1, 0, will_not_throw).
:- pragma exceptions(function, (char.to_upper), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.to_upper), 2, 0, will_not_throw).
:- pragma exceptions(function, (char.to_lower), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.to_lower), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.lower_upper), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.lower_upper), 2, 1, will_not_throw).
:- pragma exceptions(predicate, (char.is_whitespace), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_upper), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_lower), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_alpha), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_alnum), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_alpha_or_underscore), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_alnum_or_underscore), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_digit), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_binary_digit), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_octal_digit), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_hex_digit), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (char.is_hex_digit), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.int_to_hex_char), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.digit_to_int), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.int_to_digit), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (char.int_to_digit), 2, 1, will_not_throw).
:- pragma exceptions(function, (char.det_int_to_digit), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (char.det_int_to_digit), 2, 0, may_throw(user_exception)).
:- pragma termination_info(char.to_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(char.to_int((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(char.to_int((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(char.to_int((builtin.out), (builtin.in)), infinite, cannot_loop).
:- pragma termination_info(char.from_int((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(char.det_from_int((builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(char.det_from_int((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((char.max_char_value) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(char.max_char_value((builtin.out)), infinite, cannot_loop).
:- pragma termination_info((char.min_char_value) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.min_char_value((builtin.out)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.to_upper((builtin.in)) = (builtin.out), finite(0, [yes, no]), cannot_loop).
:- pragma termination_info(char.to_upper((builtin.in), (builtin.out)), finite(0, [yes, no]), cannot_loop).
:- pragma termination_info(char.to_lower((builtin.in)) = (builtin.out), finite(0, [yes, no]), cannot_loop).
:- pragma termination_info(char.to_lower((builtin.in), (builtin.out)), finite(0, [yes, no]), cannot_loop).
:- pragma termination_info(char.lower_upper((builtin.in), (builtin.out)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(char.lower_upper((builtin.out), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(char.is_whitespace((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_upper((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_lower((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_alpha((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_alnum((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_alpha_or_underscore((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_alnum_or_underscore((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_digit((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_binary_digit((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_octal_digit((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_hex_digit((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(char.is_hex_digit((builtin.in), (builtin.out)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(char.int_to_hex_char((builtin.in), (builtin.out)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(char.digit_to_int((builtin.in), (builtin.out)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(char.int_to_digit((builtin.in), (builtin.out)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(char.int_to_digit((builtin.out), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(char.det_int_to_digit((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(char.det_int_to_digit((builtin.in), (builtin.out)), finite(0, [no, no]), can_loop).
:- pragma termination_info(char.'ClassMethod_for_enum__enum____character__arity0______enum__to_int_1'((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(char.'ClassMethod_for_enum__enum____character__arity0______enum__from_int_1'((builtin.in)) = (builtin.out), infinite, cannot_loop).
