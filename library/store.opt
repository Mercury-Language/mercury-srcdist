:- module store.
:- use_module builtin.
:- use_module deconstruct.
:- use_module io.
:- use_module private_builtin.
:- use_module require.

:- type generic_mutvar(T, S)
    --->    mutvar(private_builtin.ref(T)).
:- pragma foreign_type(java, generic_mutvar(T, S), "mutvar.Mutvar").
:- pragma foreign_type(csharp, generic_mutvar(T, S), "object[]").
:- pragma foreign_type(erlang, generic_mutvar(T, S), "").
:- type generic_ref(T, S)
    --->    ref(private_builtin.ref(T)).
:- pragma foreign_type(java, generic_ref(T, S), "store.Ref").
:- pragma foreign_type(csharp, generic_ref(T, S), "store.Ref").
:- type store(S).
:- pragma foreign_type(c, store(S), "MR_Word", [can_pass_as_mercury_type])
	where	equality is (store.store_equal),
		comparison is (store.store_compare).
:- pragma foreign_type(java, store(S), "int", [can_pass_as_mercury_type])
	where	equality is (store.store_equal),
		comparison is (store.store_compare).
:- pragma foreign_type(csharp, store(S), "int", [can_pass_as_mercury_type])
	where	equality is (store.store_equal),
		comparison is (store.store_compare).
:- pragma foreign_type(erlang, store(S), "", [can_pass_as_mercury_type])
	where	equality is (store.store_equal),
		comparison is (store.store_compare).

:- instance (store.store(io.state)) where [

].
:- instance (store.store(store.store(S))) where [

].

:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("C", store).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("C#", io).
:- pragma foreign_import_module("C#", store).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("Java", store).
:- pragma foreign_import_module("Erlang", io).
:- pragma foreign_import_module("Erlang", store).

:- some [S] (pred store.do_init(store.store(S))).
:- mode store.do_init((builtin.uo)) is det.
:- pred store.store_compare(builtin.comparison_result, store.store(S_1), store.store(S_1)).
:- mode store.store_compare((builtin.uo), (builtin.in), (builtin.in)) is det.
:- pred store.store_equal(store.store(S_1), store.store(S_1)).
:- mode store.store_equal((builtin.in), (builtin.in)) is semidet.
:- pred store.unsafe_new_uninitialized_mutvar(store.generic_mutvar(T, S), S, S) <= (store.store(S)).
:- mode store.unsafe_new_uninitialized_mutvar((builtin.out), (builtin.di), (builtin.uo)) is det.
:- pred store.unsafe_ref_value(store.generic_ref(T, S), T, S, S) <= (store.store(S)).
:- mode store.unsafe_ref_value((builtin.in), (builtin.uo), (builtin.di), (builtin.uo)) is det.

store.copy_mutvar(V_5, V_6, V_9, V_10) :-
    store.get_mutvar(V_5, V_8, V_9, V_11),
    store.new_mutvar(V_8, V_6, V_11, V_10).

store.copy_ref_value(V_5, V_6, V_7, V_8) :-
    store.unsafe_ref_value(V_5, V_6, V_7, V_8).

:- pragma foreign_proc("C", store.do_init(_S0 :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    TypeInfo_for_S = 0;
").

:- pragma foreign_proc("C", store.extract_ref_value(_S :: (builtin.di), Ref :: (builtin.in), Val :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "
    Val = * (MR_Word *) Ref;
").

:- pragma foreign_proc("C", store.get_mutvar(Mutvar :: (builtin.in), Val :: (builtin.out), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    Val = * (MR_Word *) Mutvar;
    S = S0;
").

store.init(V_2) :-
    store.do_init(V_2).

store.new_cyclic_mutvar(V_5, V_6, V_9, V_10) :-
    store.unsafe_new_uninitialized_mutvar(V_6, V_9, V_11),
    V_8 = apply(V_5, V_6),
    store.set_mutvar(V_6, V_8, V_11, V_10).

:- pragma foreign_proc("C", store.new_mutvar(Val :: (builtin.in), Mutvar :: (builtin.out), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    MR_offset_incr_hp_msg(Mutvar, MR_SIZE_SLOT_SIZE, MR_SIZE_SLOT_SIZE + 1,
        MR_ALLOC_ID, \"store.mutvar/2\");
    MR_define_size_slot(0, Mutvar, 1);
    * (MR_Word *) Mutvar = Val;
    S = S0;
").

:- pragma foreign_proc("C", store.new_ref(Val :: (builtin.di), Ref :: (builtin.out), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    MR_offset_incr_hp_msg(Ref, MR_SIZE_SLOT_SIZE, MR_SIZE_SLOT_SIZE + 1,
        MR_ALLOC_ID, \"store.ref/2\");
    MR_define_size_slot(0, Ref, 1);
    * (MR_Word *) Ref = Val;
    S = S0;
").

store.ref_functor(V_6, V_7, V_8, V_11, V_12) :-
    store.unsafe_ref_value(V_6, V_10, V_11, V_12),
    V_14 = deconstruct.canonicalize : deconstruct.noncanon_handling,
    deconstruct.functor(V_10, V_14, V_7, V_8).

:- pragma foreign_proc("C", store.set_mutvar(Mutvar :: (builtin.in), Val :: (builtin.in), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    * (MR_Word *) Mutvar = Val;
    S = S0;
").

:- pragma foreign_proc("C", store.set_ref(Ref :: (builtin.in), ValRef :: (builtin.in), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "
    * (MR_Word *) Ref = * (MR_Word *) ValRef;
    S = S0;
").

:- pragma foreign_proc("C", store.set_ref_value(Ref :: (builtin.in), Val :: (builtin.di), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "
    * (MR_Word *) Ref = Val;
    S = S0;
").

:- pragma foreign_proc("C", store.unsafe_arg_ref(Ref :: (builtin.in), Arg :: (builtin.in), ArgRef :: (builtin.out), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "{
    // Unsafe - does not check type & arity, won\'t handle no_tag types.
    MR_Word *Ptr;

    Ptr = (MR_Word *) MR_strip_tag((MR_Word) Ref);
    ArgRef = (MR_Word) &Ptr[Arg];
    S = S0;
}").

:- pragma foreign_proc("C", store.unsafe_new_arg_ref(Val :: (builtin.di), Arg :: (builtin.in), ArgRef :: (builtin.out), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, may_modify_trail], "{
    // Unsafe - does not check type & arity, won\'t handle no_tag types.
    MR_Word *Ptr;

    Ptr = (MR_Word *) MR_strip_tag((MR_Word) Val);
    ArgRef = (MR_Word) &Ptr[Arg];
    S = S0;
}").

:- pragma foreign_proc("C", store.unsafe_new_uninitialized_mutvar(Mutvar :: (builtin.out), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    MR_offset_incr_hp_msg(Mutvar, MR_SIZE_SLOT_SIZE, MR_SIZE_SLOT_SIZE + 1,
        MR_ALLOC_ID, \"store.mutvar/2\");
    MR_define_size_slot(0, Mutvar, 1);
    S = S0;
").

:- pragma foreign_proc("C", store.unsafe_ref_value(Ref :: (builtin.in), Val :: (builtin.uo), S0 :: (builtin.di), S :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    Val = * (MR_Word *) Ref;
    S = S0;
").

:- pragma exceptions(predicate, (store.arg_ref), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (store.copy_mutvar), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (store.copy_ref_value), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (store.do_init), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (store.extract_ref_value), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (store.get_mutvar), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (store.init), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (store.new_arg_ref), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (store.new_cyclic_mutvar), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (store.new_mutvar), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (store.new_ref), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (store.ref_functor), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (store.set_mutvar), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (store.set_ref), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (store.set_ref_value), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (store.store_compare), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (store.store_equal), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (store.unsafe_arg_ref), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (store.unsafe_new_arg_ref), 5, 0, will_not_throw).
:- pragma exceptions(predicate, (store.unsafe_new_uninitialized_mutvar), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (store.unsafe_ref_value), 4, 0, will_not_throw).

:- pragma termination_info(store.arg_ref((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.copy_mutvar((builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.copy_ref_value((builtin.in), (builtin.uo), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.do_init((builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.extract_ref_value((builtin.di), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(store.get_mutvar((builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.init((builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.new_arg_ref((builtin.di), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.new_cyclic_mutvar((builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(store.new_mutvar((builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.new_ref((builtin.di), (builtin.out), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.ref_functor((builtin.in), (builtin.out), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(store.set_mutvar((builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.set_ref((builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.set_ref_value((builtin.in), (builtin.di), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.store_compare((builtin.uo), (builtin.in), (builtin.in)), infinite, can_loop).
:- pragma termination_info(store.store_equal((builtin.in), (builtin.in)), infinite, can_loop).
:- pragma termination_info(store.unsafe_arg_ref((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.unsafe_new_arg_ref((builtin.di), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.unsafe_new_uninitialized_mutvar((builtin.out), (builtin.di), (builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(store.unsafe_ref_value((builtin.in), (builtin.uo), (builtin.di), (builtin.uo)), infinite, cannot_loop).
