:- module uint16.

:- pragma termination_info(uint16.'*'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'+'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'+'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'+'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'-'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'-'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'-'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'//'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'/\\'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'<<'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'=<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'>'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'>='((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'>>'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'\\'((builtin.in)) = (builtin.uo), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'\\/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.cast_from_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.cast_from_int16((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.det_from_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.div((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.even((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint16.from_bytes_be((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.from_bytes_le((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.from_int((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(uint16.max((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info((uint16.max_uint16) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint16.min((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info(uint16.minus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.mod((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.num_leading_zeros((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.num_ones((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.num_trailing_zeros((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.num_zeros((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.odd((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint16.plus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.reverse_bits((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.reverse_bytes((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.times((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.to_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.uint16_to_doc((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.unchecked_left_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.unchecked_quotient((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.unchecked_rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.unchecked_right_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.xor((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.xor((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.xor((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).

:- pragma exceptions(function, (uint16.(*)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(+)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(+)), 3, 1, will_not_throw).
:- pragma exceptions(function, (uint16.(+)), 3, 2, will_not_throw).
:- pragma exceptions(function, (uint16.(-)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(-)), 3, 1, will_not_throw).
:- pragma exceptions(function, (uint16.(-)), 3, 2, will_not_throw).
:- pragma exceptions(function, (uint16.(/)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.(//)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.(/\)), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.(<)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(<<)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint16.(=<)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.(>)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.(>=)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(>>)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.(\)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(\/)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.cast_from_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.cast_from_int16), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.det_from_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.(div)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint16.even), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint16.from_bytes_be), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.from_bytes_le), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.from_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.max), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.max_uint16), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint16.min), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.minus), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(mod)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.num_leading_zeros), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.num_ones), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.num_trailing_zeros), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.num_zeros), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.odd), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint16.plus), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(rem)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.reverse_bits), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.reverse_bytes), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.times), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.to_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.uint16_to_doc), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.unchecked_left_shift), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.unchecked_quotient), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.unchecked_rem), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.unchecked_right_shift), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.xor), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.xor), 3, 1, will_not_throw).
:- pragma exceptions(function, (uint16.xor), 3, 2, will_not_throw).
