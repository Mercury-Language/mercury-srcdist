:- module version_array.
:- use_module builtin, int, list, private_builtin, require.
:- type (version_array.version_array(T))
	--->	version_array(T).
:- pragma foreign_type(c, (version_array.version_array(T)), "struct ML_va *")
	where	equality is (version_array.eq_version_array),
		comparison is (version_array.cmp_version_array).
:- pragma foreign_import_module("C", version_array).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("Erlang", io).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("Erlang", io).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("IL", bitmap).
:- pragma foreign_import_module("Erlang", bitmap).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("IL", bitmap).
:- pragma foreign_import_module("Erlang", bitmap).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
:- pragma foreign_import_module("Erlang", time).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
:- pragma foreign_import_module("Erlang", time).
:- pragma foreign_import_module("C", array).
:- pragma foreign_import_module("Java", array).
:- pragma foreign_import_module("IL", array).
:- pragma foreign_import_module("Erlang", array).
:- pragma foreign_import_module("C", array).
:- pragma foreign_import_module("Java", array).
:- pragma foreign_import_module("IL", array).
:- pragma foreign_import_module("Erlang", array).
:- func version_array.foldl_2((func(T1_1, T2_2) = T2_2), (version_array.version_array(T1_1)), T2_2, int, int) = T2_2.
:- mode version_array.foldl_2((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- func version_array.foldr_2((func(T1_1, T2_2) = T2_2), (version_array.version_array(T1_1)), T2_2, int) = T2_2.
:- mode version_array.foldr_2((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- pred version_array.eq_version_array((version_array.version_array(T_1)), (version_array.version_array(T_1))).
:- mode version_array.eq_version_array((builtin.in), (builtin.in)) is semidet.
:- pragma terminates((version_array.eq_version_array)/2).
:- pred version_array.cmp_version_array((builtin.comparison_result), (version_array.version_array(T_1)), (version_array.version_array(T_1))).
:- mode version_array.cmp_version_array((builtin.uo), (builtin.in), (builtin.in)) is det.
:- pragma terminates((version_array.cmp_version_array)/3).
:- pred version_array.get_if_in_range((version_array.version_array(T)), int, T).
:- mode version_array.get_if_in_range((builtin.in), (builtin.in), (builtin.out)) is semidet.
:- pred version_array.set_if_in_range((version_array.version_array(T)), int, T, (version_array.version_array(T))).
:- mode version_array.set_if_in_range((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- pragma foreign_proc("C", version_array.empty = (VA :: (builtin.out)), [will_not_call_mercury, not_thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    VA = MR_GC_NEW(struct ML_va);

    VA->index            = -1;
    VA->value            = (MR_Word) NULL;
    VA->rest.array       = (MR_ArrayPtr) MR_GC_NEW_ARRAY(MR_Word, 1);
    VA->rest.array->size = 0;
").
:- pragma foreign_proc("C", version_array.new(N :: (builtin.in), X :: (builtin.in)) = (VA :: (builtin.out)), [will_not_call_mercury, not_thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    MR_Integer  i;
    
    VA = MR_GC_NEW(struct ML_va);
    VA->index            = -1;
    VA->value            = (MR_Word) NULL;
    VA->rest.array       = (MR_ArrayPtr) MR_GC_NEW_ARRAY(MR_Word, N + 1);
    VA->rest.array->size = N;

    for (i = 0; i < N; i++) {
        VA->rest.array->elements[i] = X;
    }
").
version_array.init(N_4, X_5) = HeadVar__3_3 :-
    HeadVar__3_3 = version_array.new(N_4, X_5).
version_array.from_list(Xs_3) = HeadVar__2_2 :-
    HeadVar__2_2 = version_array.version_array(Xs_3).
version_array.elem(I_5, VA_4) = HeadVar__3_3 :-
    (if
      version_array.get_if_in_range(VA_4, I_5, X_6)
    then
      HeadVar__3_3 = X_6
    else
      HeadVar__3_3 = require.func_error(V_7),
      V_7 = "version_array.elem: index out of range" : string
    ).
version_array.lookup(VA_4, I_5) = HeadVar__3_3 :-
    HeadVar__3_3 = version_array.elem(I_5, VA_4).
version_array.'elem :='(I_6, VA0_5, X_7) = HeadVar__4_4 :-
    (if
      version_array.set_if_in_range(VA0_5, I_6, X_7, VA_8)
    then
      HeadVar__4_4 = VA_8
    else
      HeadVar__4_4 = require.func_error(V_9),
      V_9 = "version_array.\'elem :=\': index out of range" : string
    ).
version_array.set(I_5, X_6, VA_7, HeadVar__4_4) :-
    HeadVar__4_4 = version_array.'elem :='(I_5, VA_7, X_6).
:- pragma foreign_proc("C", version_array.size(VA :: (builtin.in)) = (N :: (builtin.out)), [will_not_call_mercury, not_thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    N = ML_va_size(VA);
").
version_array.max(VA_3) = HeadVar__2_2 :-
    HeadVar__2_2 = int.(V_4 - V_5),
    V_4 = version_array.size(VA_3),
    V_5 = 1 : int.
:- pragma foreign_proc("C", version_array.resize(VA0 :: (builtin.in), N :: (builtin.in), X :: (builtin.in)) = (VA :: (builtin.out)), [will_not_call_mercury, not_thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    MR_Integer  i;
    MR_Integer  size_VA0;
    MR_Integer  min;
    
    size_VA0 = ML_va_size(VA0);
    min      = (N <= size_VA0 ? N : size_VA0);
    VA       = MR_GC_NEW(struct ML_va);

    VA->index            = -1;
    VA->value            = (MR_Word) NULL;
    VA->rest.array       = (MR_ArrayPtr) MR_GC_NEW_ARRAY(MR_Word, N + 1);
    VA->rest.array->size = N;

    for (i = 0; i < min; i++) {
        (void) ML_va_get(VA0, i, &VA->rest.array->elements[i]);
    }

    for (i = min; i < N; i++) {
        VA->rest.array->elements[i] = X;
    }
").
version_array.resize(N_5, X_6, VA_7, HeadVar__4_4) :-
    HeadVar__4_4 = version_array.resize(VA_7, N_5, X_6).
version_array.list(VA_3) = HeadVar__2_2 :-
    HeadVar__2_2 = version_array.foldr(V_4, VA_3, V_5),
    V_4 = list.cons : (func(T_1, (list.list(T_1))) = (list.list(T_1))),
    V_5 = list.[] : (list.list(T_1)).
version_array.to_list(VA_3) = HeadVar__2_2 :-
    HeadVar__2_2 = version_array.list(VA_3).
version_array.foldl(F_5, VA_6, Acc_7) = HeadVar__4_4 :-
    HeadVar__4_4 = version_array.foldl_2(F_5, VA_6, Acc_7, V_8, V_9),
    V_8 = 0 : int,
    V_9 = version_array.size(VA_6).
version_array.foldr(F_5, VA_6, Acc_7) = HeadVar__4_4 :-
    HeadVar__4_4 = version_array.foldr_2(F_5, VA_6, Acc_7, V_8),
    V_8 = int.(V_9 - V_10),
    V_9 = version_array.size(VA_6),
    V_10 = 1 : int.
:- pragma foreign_proc("C", version_array.unsafe_rewind(VA0 :: (builtin.in)) = (VA :: (builtin.out)), [will_not_call_mercury, not_thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    VA = ML_va_rewind(VA0);
").
version_array.unsafe_rewind(VA_3, HeadVar__2_2) :-
    HeadVar__2_2 = version_array.unsafe_rewind(VA_3).
version_array.foldl_2(F_7, VA_8, Acc_9, Lo_10, Hi_11) = HeadVar__6_6 :-
    (if
      int.(Lo_10 < Hi_11)
    then
      HeadVar__6_6 = version_array.foldl_2(F_7, VA_8, V_12, V_13, Hi_11),
      V_12 = apply(F_7, V_14, Acc_9),
      V_14 = version_array.elem(Lo_10, VA_8),
      V_13 = int.(Lo_10 + V_15),
      V_15 = 1 : int
    else
      HeadVar__6_6 = Acc_9
    ).
version_array.foldr_2(F_6, VA_7, Acc_8, Hi_9) = HeadVar__5_5 :-
    (if
      V_10 = 0 : int,
      int.(V_10 =< Hi_9)
    then
      HeadVar__5_5 = version_array.foldr_2(F_6, VA_7, V_11, V_12),
      V_11 = apply(F_6, V_13, Acc_8),
      V_13 = version_array.elem(Hi_9, VA_7),
      V_12 = int.(Hi_9 - V_14),
      V_14 = 1 : int
    else
      HeadVar__5_5 = Acc_8
    ).
:- pragma foreign_proc("C", version_array.get_if_in_range(VA :: (builtin.in), I :: (builtin.in), X :: (builtin.out)), [will_not_call_mercury, not_thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    SUCCESS_INDICATOR = ML_va_get(VA, I, &X);
").
:- pragma foreign_proc("C", version_array.set_if_in_range(VA0 :: (builtin.in), I :: (builtin.in), X :: (builtin.in), VA :: (builtin.out)), [will_not_call_mercury, not_thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    SUCCESS_INDICATOR = ML_va_set(VA0, I, X, &VA);
").
:- pragma exceptions(function, (version_array.empty), 1, 0, will_not_throw).
:- pragma exceptions(function, (version_array.new), 3, 0, will_not_throw).
:- pragma exceptions(function, (version_array.init), 3, 0, will_not_throw).
:- pragma exceptions(function, (version_array.version_array), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.from_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.elem), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.lookup), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.'elem :='), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (version_array.set), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.size), 2, 0, will_not_throw).
:- pragma exceptions(function, (version_array.max), 2, 0, will_not_throw).
:- pragma exceptions(function, (version_array.resize), 4, 0, will_not_throw).
:- pragma exceptions(predicate, (version_array.resize), 4, 0, will_not_throw).
:- pragma exceptions(function, (version_array.list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.to_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.foldl), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.foldr), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.copy), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.unsafe_rewind), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (version_array.unsafe_rewind), 2, 0, will_not_throw).
:- pragma exceptions(function, (version_array.foldl_2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(function, (version_array.foldr_2), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (version_array.eq_version_array), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (version_array.cmp_version_array), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (version_array.get_if_in_range), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (version_array.set_if_in_range), 4, 0, will_not_throw).
:- pragma termination_info((version_array.empty) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(version_array.new((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(version_array.init((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(version_array.version_array((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.from_list((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.elem((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.lookup((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.'elem :='((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.set((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(version_array.size((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(version_array.max((builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(version_array.resize((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(version_array.resize((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(version_array.list((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.to_list((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.foldl((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.foldr((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.copy((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.unsafe_rewind((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(version_array.unsafe_rewind((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(version_array.foldl_2((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.foldr_2((builtin.in), (builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(version_array.eq_version_array((builtin.in), (builtin.in)), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(version_array.cmp_version_array((builtin.uo), (builtin.in), (builtin.in)), finite(0, [no, no, no, no]), cannot_loop).
:- pragma termination_info(version_array.get_if_in_range((builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(version_array.set_if_in_range((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, cannot_loop).
