:- module uint32.
:- use_module builtin.
:- use_module exception.
:- use_module math.
:- use_module pretty_printer.
:- use_module private_builtin.
:- use_module require.
:- use_module string.
:- use_module uint.

:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("C", uint32).
:- pragma foreign_import_module("C#", io).
:- pragma foreign_import_module("C#", uint32).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("Java", uint32).
:- pragma foreign_import_module("Erlang", io).

:- pragma inline((uint32.(/))/2).
uint32.(V_4 / V_5) = V_3 :-
    V_3 = uint32.(V_4 // V_5).

:- pragma inline((uint32.(//))/2).
uint32.(V_4 // V_5) = V_6 :-
    ( if
      V_5 = 0u32 : uint32
    then
      V_7 = math.domain_error(V_8) : math.domain_error,
      V_8 = "uint32.\'//\': division by zero" : string,
      exception.throw(V_7)
    else
      V_6 = uint32.unchecked_quotient(V_4, V_5)
    ).

:- pragma foreign_proc("C", uint32.cast_from_int(I :: (builtin.in)) = (U32 :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U32 = (uint32_t) I;
").

:- pragma foreign_proc("C", uint32.cast_to_int(U32 :: (builtin.in)) = (I :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    I = (MR_Integer) U32;
").

uint32.(V_4 div V_5) = V_3 :-
    V_3 = uint32.(V_4 // V_5).

:- pragma inline((uint32.even)/1).
uint32.even(V_2) :-
    V_3 = uint32.(V_2 /\ V_4),
    V_4 = 1u32 : uint32,
    V_3 = 0u32 : uint32.

:- pragma foreign_proc("C", uint32.from_int(I :: (builtin.in), U :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    if (I < 0) {
        SUCCESS_INDICATOR = MR_FALSE;
    } else if (I > (MR_Integer) INT32_MAX) {
        SUCCESS_INDICATOR = MR_FALSE;
    } else {
        U = (uint32_t) I;
        SUCCESS_INDICATOR = MR_TRUE;
    }
").

uint32.max(V_4, V_5) = V_3 :-
    ( if
      uint32.(V_4 > V_5)
    then
      V_3 = V_4
    else
      V_3 = V_5
    ).

uint32.max_uint32 = V_1 :-
    V_1 = 4294967295u32 : uint32.

uint32.min(V_4, V_5) = V_3 :-
    ( if
      uint32.(V_4 < V_5)
    then
      V_3 = V_4
    else
      V_3 = V_5
    ).

uint32.(V_4 mod V_5) = V_3 :-
    V_3 = uint32.(V_4 rem V_5).

:- pragma inline((uint32.odd)/1).
uint32.odd(V_2) :-
    not (
      V_3 = uint32.(V_2 /\ V_4),
      V_4 = 1u32 : uint32,
      V_3 = 0u32 : uint32
    ).

:- pragma inline((uint32.(rem))/2).
uint32.(V_4 rem V_5) = V_6 :-
    ( if
      V_5 = 0u32 : uint32
    then
      V_7 = math.domain_error(V_8) : math.domain_error,
      V_8 = "uint32.rem: division by zero" : string,
      exception.throw(V_7)
    else
      V_6 = uint32.unchecked_rem(V_4, V_5)
    ).

uint32.uint32_to_doc(V_3) = pretty_printer.str(V_4) :-
    V_4 = string.uint32_to_string(V_3).

:- pragma exceptions(function, (uint32.(*)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.(+)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.(+)), 3, 1, will_not_throw).
:- pragma exceptions(function, (uint32.(+)), 3, 2, will_not_throw).
:- pragma exceptions(function, (uint32.(-)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.(-)), 3, 1, will_not_throw).
:- pragma exceptions(function, (uint32.(-)), 3, 2, will_not_throw).
:- pragma exceptions(function, (uint32.(/)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint32.(//)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint32.(/\)), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (uint32.(<)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint32.(<<)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint32.(=<)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint32.(>)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint32.(>=)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint32.(>>)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint32.(\)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint32.(\/)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.cast_from_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint32.cast_to_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint32.det_from_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint32.(div)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint32.even), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (uint32.from_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint32.max), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.max_uint32), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint32.min), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.minus), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.(mod)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint32.odd), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint32.plus), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.(rem)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint32.times), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.uint32_to_doc), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint32.unchecked_left_shift), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.unchecked_quotient), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.unchecked_rem), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.unchecked_right_shift), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.xor), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint32.xor), 3, 1, will_not_throw).
:- pragma exceptions(function, (uint32.xor), 3, 2, will_not_throw).

:- pragma termination_info(uint32.'*'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.'+'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.'+'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.'+'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.'-'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.'-'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.'-'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.'/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint32.'//'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint32.'/\\'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.'<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint32.'<<'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint32.'=<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint32.'>'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint32.'>='((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint32.'>>'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint32.'\\'((builtin.in)) = (builtin.uo), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint32.'\\/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.cast_from_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint32.cast_to_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint32.det_from_int((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(uint32.div((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint32.even((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint32.from_int((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(uint32.max((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info((uint32.max_uint32) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint32.min((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info(uint32.minus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.mod((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint32.odd((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint32.plus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint32.times((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.uint32_to_doc((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(uint32.unchecked_left_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.unchecked_quotient((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.unchecked_rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.unchecked_right_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.xor((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.xor((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint32.xor((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
