:- module queue.
:- use_module builtin, int, list, private_builtin.
:- type queue.queue(T)
	--->	queue((queue.on_list) :: list.list(T), (queue.off_list) :: list.list(T)).
queue.init(queue.queue(V_2, V_3)) :-
    V_2 = list.[] : list.list(T_1),
    V_3 = list.[] : list.list(T_1).
queue.init = Q_2 :-
    queue.init(Q_2).
queue.is_empty(queue.queue(V_2, V_3)) :-
    V_3 = list.[] : list.list(T_1).
queue.is_full(V_2) :-
    builtin.semidet_fail.
queue.put(Q1_4, T_5) = Q2_6 :-
    queue.put(Q1_4, T_5, Q2_6).
queue.put_list(Q1_4, Xs_5) = Q2_6 :-
    queue.put_list(Q1_4, Xs_5, Q2_6).
queue.first(queue.queue(V_3, V_6), Elem_4) :-
    V_6 = list.[Elem_4 | V_5] : list.list(T_1).
queue.length(queue.queue(On_3, Off_4), Length_5) :-
    list.length(On_3, LengthOn_6),
    list.length(Off_4, LengthOff_7),
    Length_5 = int.(LengthOn_6 + LengthOff_7).
queue.length(Q_3) = N_4 :-
    queue.length(Q_3, N_4).
queue.list_to_queue(List_3, queue.queue(V_4, List_3)) :-
    V_4 = list.[] : list.list(T_1).
queue.list_to_queue(Xs_3) = Q_4 :-
    queue.list_to_queue(Xs_3, Q_4).
queue.from_list(List_3) = queue.queue(V_4, List_3) :-
    V_4 = list.[] : list.list(T_1).
queue.to_list(queue.queue(On_3, Off_4)) = HeadVar__2_2 :-
    HeadVar__2_2 = list.(Off_4 ++ V_5),
    V_5 = list.reverse(On_3).
queue.delete_all(Q1_4, T_5) = Q2_6 :-
    queue.delete_all(Q1_4, T_5, Q2_6).
queue.put_on_front(Queue0_4, Elem_5) = Queue_6 :-
    queue.put_on_front(Queue0_4, Elem_5, Queue_6).
queue.put_on_front(queue.queue(On_4, Off_5), Elem_6, queue.queue(On_4, V_7)) :-
    V_7 = list.[Elem_6 | Off_5] : list.list(T_1).
queue.put_list_on_front(Queue0_4, Elems_5) = Queue_6 :-
    queue.put_list_on_front(Queue0_4, Elems_5, Queue_6).
queue.put_list_on_front(queue.queue(On_4, Off_5), Elems_6, queue.queue(On_4, V_7)) :-
    V_7 = list.(Elems_6 ++ Off_5).
:- pragma exceptions(predicate, (queue.init), 1, 0, will_not_throw).
:- pragma exceptions(function, (queue.init), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (queue.equal), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (queue.is_empty), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (queue.is_full), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (queue.put), 3, 0, will_not_throw).
:- pragma exceptions(function, (queue.put), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (queue.put_list), 3, 0, will_not_throw).
:- pragma exceptions(function, (queue.put_list), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (queue.first), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (queue.get), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (queue.length), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (queue.length), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (queue.list_to_queue), 2, 0, will_not_throw).
:- pragma exceptions(function, (queue.list_to_queue), 2, 0, will_not_throw).
:- pragma exceptions(function, (queue.from_list), 2, 0, will_not_throw).
:- pragma exceptions(function, (queue.to_list), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (queue.delete_all), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (queue.delete_all), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (queue.put_on_front), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (queue.put_on_front), 3, 0, will_not_throw).
:- pragma exceptions(function, (queue.put_list_on_front), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (queue.put_list_on_front), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (queue.get_from_back), 3, 0, may_throw(user_exception)).
:- pragma termination_info(queue.init((builtin.out)), finite(2, [no, no]), cannot_loop).
:- pragma termination_info((queue.init) = (builtin.out), finite(2, [no, no]), cannot_loop).
:- pragma termination_info(queue.equal((builtin.in), (builtin.in)), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(queue.is_empty((builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(queue.is_full((builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(queue.put((builtin.in), (builtin.in), (builtin.out)), finite(2, [no, yes, yes, no]), cannot_loop).
:- pragma termination_info(queue.put((builtin.in), (builtin.in)) = (builtin.out), finite(2, [no, yes, yes, no]), cannot_loop).
:- pragma termination_info(queue.put_list((builtin.in), (builtin.in), (builtin.out)), finite(0, [no, yes, yes, no]), can_loop).
:- pragma termination_info(queue.put_list((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, yes, yes, no]), can_loop).
:- pragma termination_info(queue.first((builtin.in), (builtin.out)), finite(-4, [no, yes, no]), cannot_loop).
:- pragma termination_info(queue.get((builtin.in), (builtin.out), (builtin.out)), infinite, can_loop).
:- pragma termination_info(queue.length((builtin.in), (builtin.out)), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(queue.length((builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(queue.list_to_queue((builtin.in), (builtin.out)), finite(2, [no, yes, no]), cannot_loop).
:- pragma termination_info(queue.list_to_queue((builtin.in)) = (builtin.out), finite(2, [no, yes, no]), cannot_loop).
:- pragma termination_info(queue.from_list((builtin.in)) = (builtin.out), finite(2, [no, yes, no]), cannot_loop).
:- pragma termination_info(queue.to_list((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(queue.delete_all((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(queue.delete_all((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(queue.put_on_front((builtin.in), (builtin.in)) = (builtin.out), finite(2, [no, yes, yes, no]), cannot_loop).
:- pragma termination_info(queue.put_on_front((builtin.in), (builtin.in), (builtin.out)), finite(2, [no, yes, yes, no]), cannot_loop).
:- pragma termination_info(queue.put_list_on_front((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(queue.put_list_on_front((builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(queue.get_from_back((builtin.in), (builtin.out), (builtin.out)), infinite, can_loop).
