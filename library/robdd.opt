:- module robdd.
:- use_module assoc_list.
:- use_module bool.
:- use_module builtin.
:- use_module int.
:- use_module io.
:- use_module list.
:- use_module map.
:- use_module multi_map.
:- use_module pair.
:- use_module private_builtin.
:- use_module require.
:- use_module set_bbbtree.
:- use_module set_unordlist.
:- use_module sparse_bitset.
:- use_module stream.
:- use_module string.
:- use_module term.
:- use_module (string.format).
:- use_module (string.parse_util).

:- type imp_res(T) == robdd.entailment_result(robdd.imp_res_2(T)).
:- type imp_res_2(T)
    --->    imps(tree234.tree234(term.var(T), robdd.entailment_result(sparse_bitset.sparse_bitset(term.var(T))))).
:- type implication_result(T)
    --->    implication_result(robdd.entailment_result(robdd.imp_res_2(T)), robdd.entailment_result(robdd.imp_res_2(T)), robdd.entailment_result(robdd.imp_res_2(T)), robdd.entailment_result(robdd.imp_res_2(T))).
:- type leader_to_eqvclass(T)
    --->    leader_to_eqvclass(tree234.tree234(term.var(T), sparse_bitset.sparse_bitset(term.var(T)))).
:- type robdd(T)
    --->    robdd(int).
:- type robdd_cache(T) == tree234.tree234(robdd.robdd(T), robdd.robdd(T)).
:- type var_cache(T) == tree234.tree234(term.var(T), bool.bool).

:- typeclass intersectable(T) where [
	func intersection(T, T) = T
].

:- instance (robdd.intersectable(sparse_bitset.sparse_bitset(T))) where [
	func((robdd.intersection)/2) is (sparse_bitset.intersect)
].
:- instance (robdd.intersectable(robdd.imp_res_2(T))).
:- instance (robdd.intersectable(robdd.entailment_result(T))) <= (robdd.intersectable(T)).
:- instance (robdd.intersectable(robdd.leader_to_eqvclass(T))).

:- pred robdd.add_equivalences_2(list.list(pair.pair(term.var(T), term.var(T))), sparse_bitset.sparse_bitset(term.var(T)), robdd.robdd(T), robdd.robdd(T), tree234.tree234(robdd.robdd(T), robdd.robdd(T)), tree234.tree234(robdd.robdd(T), robdd.robdd(T))).
:- mode add_equivalences_2((builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- func robdd.at_most_one_of_2(sparse_bitset.sparse_bitset(term.var(T)), robdd.robdd(T), robdd.robdd(T)) = robdd.robdd(T).
:- mode at_most_one_of_2((builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- func robdd.equivalent_vars_2(robdd.robdd(T)) = robdd.entailment_result(robdd.leader_to_eqvclass(T)).
:- mode equivalent_vars_2((builtin.in)) = (builtin.out) is det.
:- func robdd.fa(robdd.robdd(T)) = robdd.robdd(T).
:- mode fa((builtin.in)) = (builtin.out) is det.
:- pragma no_inline(func((robdd.fa)/1)).
:- pred robdd.filter_2((pred term.var(T)), (pred term.var(T)), robdd.robdd(T), robdd.robdd(T), tree234.tree234(term.var(T), bool.bool), tree234.tree234(term.var(T), bool.bool), tree234.tree234(robdd.robdd(T), robdd.robdd(T)), tree234.tree234(robdd.robdd(T), robdd.robdd(T))).
:- mode filter_2(builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- func robdd.implication_result_to_imp_vars(robdd.implication_result(T)) = robdd.imp_vars(T).
:- mode implication_result_to_imp_vars((builtin.in)) = (builtin.out) is det.
:- func robdd.implications_2(robdd.robdd(T)) = robdd.implication_result(T).
:- mode implications_2((builtin.in)) = (builtin.out) is det.
:- pred robdd.labelling_loop(list.list(term.var(T)), robdd.robdd(T), sparse_bitset.sparse_bitset(term.var(T)), sparse_bitset.sparse_bitset(term.var(T)), sparse_bitset.sparse_bitset(term.var(T)), sparse_bitset.sparse_bitset(term.var(T))).
:- mode labelling_loop((builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is nondet.
:- func robdd.make_equiv_2(list.list(pair.pair(term.var(T), term.var(T))), sparse_bitset.sparse_bitset(term.var(T))) = robdd.robdd(T).
:- mode make_equiv_2((builtin.in), (builtin.in)) = (builtin.out) is det.
:- func robdd.make_node(term.var(T), robdd.robdd(T), robdd.robdd(T)) = robdd.robdd(T).
:- mode make_node((builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
:- pragma no_inline(func((robdd.make_node)/3)).
:- func robdd.node_name(robdd.robdd(T)) = string.
:- mode node_name((builtin.in)) = (builtin.out) is det.
:- pred robdd.remove_implications_2(robdd.imp_vars(T), sparse_bitset.sparse_bitset(term.var(T)), sparse_bitset.sparse_bitset(term.var(T)), robdd.robdd(T), robdd.robdd(T), tree234.tree234(robdd.robdd(T), robdd.robdd(T)), tree234.tree234(robdd.robdd(T), robdd.robdd(T))).
:- mode remove_implications_2((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- pred robdd.restrict_true_false_vars_2(sparse_bitset.sparse_bitset(term.var(T)), sparse_bitset.sparse_bitset(term.var(T)), robdd.robdd(T), robdd.robdd(T), tree234.tree234(robdd.robdd(T), robdd.robdd(T)), tree234.tree234(robdd.robdd(T), robdd.robdd(T))).
:- mode restrict_true_false_vars_2((builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- func robdd.rev_map(robdd.entailment_result(robdd.leader_to_eqvclass(T))) = robdd.entailment_result(robdd.equiv_vars(T)).
:- mode rev_map((builtin.in)) = (builtin.out) is det.
:- pred robdd.robdd_to_dot_2(io.text_output_stream, robdd.robdd(T), ((func term.var(T)) = string), set_bbbtree.set_bbbtree(robdd.robdd(T)), set_bbbtree.set_bbbtree(robdd.robdd(T)), tree234.tree234(term.var(T), list.list(robdd.robdd(T))), tree234.tree234(term.var(T), list.list(robdd.robdd(T))), io.state, io.state).
:- mode robdd_to_dot_2((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det.
:- func robdd.terminal_name(robdd.robdd(T)) = string.
:- mode terminal_name((builtin.in)) = (builtin.out) is det.
:- func robdd.tr(robdd.robdd(T)) = robdd.robdd(T).
:- mode tr((builtin.in)) = (builtin.out) is det.
:- pragma no_inline(func((robdd.tr)/1)).
:- func robdd.value(robdd.robdd(T)) = term.var(T).
:- mode value((builtin.in)) = (builtin.out) is det.
:- pragma no_inline(func((robdd.value)/1)).
:- pred robdd.vars_are_constrained_2(robdd.robdd(T), list.list(term.var(T))).
:- mode vars_are_constrained_2((builtin.in), (builtin.in)) is semidet.
:- pred robdd.write_edge(io.text_output_stream, robdd.robdd(T), robdd.robdd(T), bool.bool, io.state, io.state).
:- mode write_edge((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- pred robdd.write_node(io.text_output_stream, robdd.robdd(T), ((func term.var(T)) = string), io.state, io.state).
:- mode write_node((builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.

robdd.(V_4 =:= V_5) = V_3 :-
    V_3 = robdd.ite(V_4, V_5, V_6),
    V_6 = robdd.(~ V_5).

robdd.(V_4 =\= V_5) = V_3 :-
    V_3 = robdd.ite(V_4, V_6, V_5),
    V_6 = robdd.(~ V_5).

robdd.add_equivalences(robdd.equiv_vars(V_4), V_5) = V_6 :-
    V_8 = map.to_sorted_assoc_list(V_4),
    V_9 = sparse_bitset.init,
    V_10 = map.init,
    robdd.add_equivalences_2(V_8, V_9, V_5, V_6, V_10, V_7).

robdd.at_most_one_of(V_3) = V_2 :-
    V_2 = robdd.at_most_one_of_2(V_3, V_4, V_5),
    V_4 = robdd.one,
    V_5 = robdd.one.

robdd.at_most_one_of_2(V_5, V_6, V_7) = V_8 :-
    V_15 = (pred(V_17::(ground >> ground), V_18::(ground >> ground), V_19::(free >> ground), V_20::(ground >> ground), V_21::(free >> ground)) is det :-
      some [] ( % compiler
        V_17 = V_24,
        V_18 = V_25,
        V_20 = V_27,
        V_28 = robdd.make_node(V_24, V_22, V_27),
        V_22 = robdd.zero,
        V_26 = robdd.make_node(V_24, V_27, V_25),
        V_19 = V_26,
        V_21 = V_28
      )
    ) : pred(term.var(T_1), robdd.robdd(T_1), robdd.robdd(T_1), robdd.robdd(T_1), robdd.robdd(T_1)),
    V_16 = list.reverse(V_23),
    V_23 = sparse_bitset.to_sorted_list(V_5),
    list.foldl2(V_15, V_16, V_6, V_8, V_7, V_14).

robdd.conj_not_vars(V_3) = V_2 :-
    V_2 = sparse_bitset.foldr(V_6, V_3, V_11),
    V_6 = (func(V_7::(ground >> ground), V_8::(ground >> ground)) = (V_9::(free >> ground)) is det :-
      some [] ( % compiler
        V_7 = V_12,
        V_8 = V_13,
        V_9 = robdd.make_node(V_12, V_10, V_13),
        V_10 = robdd.zero
      )
    ) : (func(term.var(T_1), robdd.robdd(T_1)) = robdd.robdd(T_1)),
    V_11 = robdd.one.

robdd.conj_vars(V_3) = V_2 :-
    V_2 = sparse_bitset.foldr(V_6, V_3, V_11),
    V_6 = (func(V_7::(ground >> ground), V_8::(ground >> ground)) = (V_9::(free >> ground)) is det :-
      some [] ( % compiler
        V_7 = V_12,
        V_8 = V_13,
        V_9 = robdd.make_node(V_12, V_13, V_10),
        V_10 = robdd.zero
      )
    ) : (func(term.var(T_1), robdd.robdd(T_1)) = robdd.robdd(T_1)),
    V_11 = robdd.one.

robdd.disj_vars(V_3) = V_2 :-
    V_2 = sparse_bitset.foldr(V_6, V_3, V_11),
    V_6 = (func(V_7::(ground >> ground), V_8::(ground >> ground)) = (V_9::(free >> ground)) is det :-
      some [] ( % compiler
        V_7 = V_12,
        V_8 = V_13,
        V_9 = robdd.make_node(V_12, V_10, V_13),
        V_10 = robdd.one
      )
    ) : (func(term.var(T_1), robdd.robdd(T_1)) = robdd.robdd(T_1)),
    V_11 = robdd.zero.

robdd.empty_vars_set = V_1 :-
    V_1 = sparse_bitset.init.

robdd.equivalent_vars(V_3) = V_2 :-
    V_2 = robdd.rev_map(V_4),
    V_4 = robdd.equivalent_vars_2(V_3).

robdd.extract_implications(V_3) = V_2 :-
    V_2 = robdd.implication_result_to_imp_vars(V_4),
    V_4 = robdd.implications_2(V_3).

robdd.filter_2(V_9, V_10, V_11, V_12, V_13, V_14, V_15, V_16) :-
    ( if
      robdd.is_terminal(V_11)
    then
      V_12 = V_11,
      V_14 = V_13,
      V_16 = V_15
    else
      ( if
        not (
          V_26 = robdd.value(V_11),
          call(V_10, V_26)
        )
      then
        V_12 = V_11,
        V_14 = V_13,
        V_16 = V_15
      else
        ( if
          map.search(V_15, V_11, V_17)
        then
          V_12 = V_17,
          V_14 = V_13,
          V_16 = V_15
        else
          V_27 = robdd.tr(V_11),
          robdd.filter_2(V_9, V_10, V_27, V_18, V_13, V_19, V_15, V_20),
          V_28 = robdd.fa(V_11),
          robdd.filter_2(V_9, V_10, V_28, V_21, V_19, V_22, V_20, V_23),
          V_24 = robdd.value(V_11),
          ( if
            map.search(V_13, V_24, V_25)
          then
            V_14 = V_22,
            ( % disjunction
              V_25 = bool.yes : bool.bool,
              V_12 = robdd.make_node(V_24, V_18, V_21)
            ;
              V_25 = bool.no : bool.bool,
              V_12 = robdd.(V_18 + V_21)
            )
          else
            ( if
              call(V_9, V_24)
            then
              V_12 = robdd.make_node(V_24, V_18, V_21),
              V_29 = bool.yes : bool.bool,
              map.det_insert(V_24, V_29, V_22, V_14)
            else
              V_12 = robdd.(V_18 + V_21),
              V_30 = bool.no : bool.bool,
              map.det_insert(V_24, V_30, V_22, V_14)
            )
          ),
          map.det_insert(V_11, V_12, V_23, V_16)
        )
      )
    ).

robdd.labelling(V_5, V_6, V_7, V_8) :-
    V_9 = sparse_bitset.to_sorted_list(V_5),
    V_10 = robdd.empty_vars_set,
    V_11 = robdd.empty_vars_set,
    robdd.labelling_loop(V_9, V_6, V_10, V_7, V_11, V_8).

robdd.make_equiv(robdd.equiv_vars(V_3)) = V_2 :-
    V_2 = robdd.make_equiv_2(V_4, V_5),
    V_4 = map.to_sorted_assoc_list(V_3),
    V_5 = sparse_bitset.init.

robdd.not_var(V_3) = V_2 :-
    V_2 = robdd.make_node(V_3, V_4, V_5),
    V_4 = robdd.zero,
    V_5 = robdd.one.

robdd.print_robdd(V_4, V_7, V_8) :-
    io.output_stream(V_6, V_7, V_9),
    robdd.print_robdd(V_6, V_4, V_9, V_8).

robdd.remove_implications(V_4, V_5) = V_6 :-
    V_8 = sparse_bitset.init,
    V_9 = sparse_bitset.init,
    V_10 = map.init,
    robdd.remove_implications_2(V_4, V_8, V_9, V_5, V_6, V_10, V_7).

robdd.rename_vars(V_4, V_5) = V_3 :-
    ( if
      robdd.is_terminal(V_5)
    then
      V_3 = V_5
    else
      V_3 = robdd.ite(V_6, V_9, V_11),
      V_6 = robdd.var(V_7),
      V_7 = apply(V_4, V_8),
      V_8 = robdd.value(V_5),
      V_9 = robdd.rename_vars(V_4, V_10),
      V_10 = robdd.tr(V_5),
      V_11 = robdd.rename_vars(V_4, V_12),
      V_12 = robdd.fa(V_5)
    ).

robdd.restrict_filter(V_4, V_5) = V_3 :-
    V_3 = robdd.restrict_filter(V_4, V_7, V_5),
    V_7 = (pred(V_8::(ground >> ground)) is semidet :-
      some [] ( % compiler
        V_8 = V_9
      )
    ) : (pred term.var(T_1)).

robdd.restrict_filter(V_5, V_6, V_7) = V_8 :-
    V_11 = map.init,
    V_12 = map.init,
    robdd.filter_2(V_5, V_6, V_7, V_8, V_11, V_9, V_12, V_10).

robdd.restrict_true_false_vars(V_5, V_6, V_7) = V_8 :-
    V_10 = map.init,
    robdd.restrict_true_false_vars_2(V_5, V_6, V_7, V_8, V_10, V_9).

robdd.robdd_to_dot(V_5, V_6, V_9, V_10) :-
    io.output_stream(V_8, V_9, V_11),
    robdd.robdd_to_dot_stream(V_8, V_5, V_6, V_11, V_10).

robdd.robdd_to_dot(V_6, V_7, V_8, V_14, V_15) :-
    io.open_output(V_8, V_10, V_14, V_16),
    ( % disjunction
      V_10 = io.ok(V_11) : io.res(io.text_output_stream),
      robdd.robdd_to_dot_stream(V_11, V_6, V_7, V_16, V_17),
      io.close_output(V_11, V_17, V_15)
    ;
      V_10 = io.error(V_12) : io.res(io.text_output_stream),
      io.stderr_stream(V_13, V_16, V_19),
      V_20 = "\n%s\n" : string,
      V_21 = list.[V_23 | V_25] : list.list(string.poly_type),
      V_23 = string.s(V_24) : string.poly_type,
      V_24 = io.error_message(V_12),
      V_25 = list.[] : list.list(string.poly_type),
      io.format(V_13, V_20, V_21, V_19, V_15)
    ).

robdd.robdd_to_dot_2(V_10, V_11, V_12, V_16, V_17, V_18, V_19, V_20, V_21) :-
    ( if
      robdd.is_terminal(V_11)
    then
      V_21 = V_20,
      V_19 = V_18,
      V_17 = V_16
    else
      ( if
        set_bbbtree.member(V_11, V_16)
      then
        V_21 = V_20,
        V_19 = V_18,
        V_17 = V_16
      else
        V_22 = robdd.tr(V_11),
        robdd.robdd_to_dot_2(V_10, V_22, V_12, V_16, V_23, V_18, V_24, V_20, V_25),
        V_26 = robdd.fa(V_11),
        robdd.robdd_to_dot_2(V_10, V_26, V_12, V_23, V_27, V_24, V_28, V_25, V_29),
        robdd.write_node(V_10, V_11, V_12, V_29, V_30),
        V_31 = robdd.tr(V_11),
        V_32 = bool.yes : bool.bool,
        robdd.write_edge(V_10, V_11, V_31, V_32, V_30, V_33),
        V_34 = robdd.fa(V_11),
        V_35 = bool.no : bool.bool,
        robdd.write_edge(V_10, V_11, V_34, V_35, V_33, V_21),
        V_17 = set_bbbtree.insert(V_27, V_11),
        V_38 = robdd.value(V_11),
        multi_map.set(V_38, V_11, V_28, V_19)
      )
    ).

robdd.robdd_to_dot_stream(V_6, V_7, V_8, V_17, V_18) :-
    V_10 = "digraph G{\n    center=true;\n    size=\"7,11\";\n    ordering=out;\n    node [shape=record,height=.1];\n    concentrate=true;\n" : string,
    io.write_string(V_6, V_10, V_17, V_19),
    multi_map.init(V_11),
    V_20 = set_bbbtree.init,
    robdd.robdd_to_dot_2(V_6, V_7, V_8, V_20, V_12, V_11, V_13, V_19, V_21),
    V_22 = (pred(V_28::(ground >> ground), V_29::(ground >> ground), V_30::(unique >> clobbered), V_31::(free >> unique)) is det :-
      some [] ( % compiler
        V_28 = V_47,
        V_29 = V_52,
        V_30 = V_53,
        V_32 = "{rank = same; " : string,
        io.write_string(V_6, V_32, V_53, V_25),
        V_33 = (pred(V_36::(ground >> ground), V_37::(unique >> clobbered), V_38::(free >> unique)) is det :-
          some [] ( % compiler
            V_36 = V_48,
            V_37 = V_49,
            V_39 = "%s; " : string,
            V_40 = list.[V_41 | V_43] : list.list(string.poly_type),
            V_41 = string.s(V_42) : string.poly_type,
            V_42 = robdd.node_name(V_48),
            V_43 = list.[] : list.list(string.poly_type),
            io.format(V_6, V_39, V_40, V_49, V_50),
            V_38 = V_50
          )
        ) : pred(robdd.robdd(T_1), io.state, io.state),
        list.foldl(V_33, V_52, V_25, V_26),
        V_44 = "}\n" : string,
        io.write_string(V_6, V_44, V_26, V_54),
        V_31 = V_54
      )
    ) : pred(term.var(T_1), list.list(robdd.robdd(T_1)), io.state, io.state),
    map.foldl(V_22, V_13, V_21, V_23),
    V_45 = "}\n" : string,
    io.write_string(V_6, V_45, V_23, V_18).

robdd.size(V_4, V_5, V_6) :-
    robdd.size(V_4, V_5, V_6, V_7).

robdd.vars_are_constrained(V_3, V_4) :-
    V_5 = sparse_bitset.to_sorted_list(V_4),
    robdd.vars_are_constrained_2(V_3, V_5).

robdd.write_node(V_6, V_7, V_8, V_10, V_11) :-
    V_12 = "%s [label=\"<f0> %s|<f1> " : string,
    V_13 = list.[V_15 | V_17] : list.list(string.poly_type),
    V_15 = string.s(V_16) : string.poly_type,
    V_16 = robdd.node_name(V_7),
    V_17 = list.[V_18 | V_21] : list.list(string.poly_type),
    V_18 = string.s(V_19) : string.poly_type,
    V_19 = robdd.terminal_name(V_20),
    V_20 = robdd.tr(V_7),
    V_21 = list.[] : list.list(string.poly_type),
    io.format(V_6, V_12, V_13, V_10, V_14),
    V_22 = apply(V_8, V_24),
    V_24 = robdd.value(V_7),
    io.write_string(V_6, V_22, V_14, V_23),
    V_25 = "|<f2> %s" : string,
    V_26 = list.[V_28 | V_31] : list.list(string.poly_type),
    V_28 = string.s(V_29) : string.poly_type,
    V_29 = robdd.terminal_name(V_30),
    V_30 = robdd.fa(V_7),
    V_31 = list.[] : list.list(string.poly_type),
    io.format(V_6, V_25, V_26, V_23, V_27),
    V_32 = "\"];\n" : string,
    io.write_string(V_6, V_32, V_27, V_11).

robdd.(~ V_3) = V_2 :-
    V_2 = robdd.ite(V_3, V_4, V_5),
    V_4 = robdd.zero,
    V_5 = robdd.one.

:- pragma termination_info(robdd.'*'((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.'+'((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.'=:='((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.'=<'((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.'=\\='((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.'ClassMethod_for_robdd__intersectable____robdd__entailment_result__arity1______robdd__intersection_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.'ClassMethod_for_robdd__intersectable____robdd__imp_res_2__arity1______robdd__intersection_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.'ClassMethod_for_robdd__intersectable____robdd__leader_to_eqvclass__arity1______robdd__intersection_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.'ClassMethod_for_robdd__intersectable____sparse_bitset__sparse_bitset__arity1______robdd__intersection_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.add_equivalences((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.add_equivalences_2((builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.add_implications((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.at_most_one_of((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.at_most_one_of_2((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((robdd.clear_caches), finite(0, []), cannot_loop).
:- pragma termination_info(robdd.clear_caches((builtin.di), (builtin.uo)), finite(0, [yes, no]), cannot_loop).
:- pragma termination_info(robdd.conj_not_vars((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.conj_vars((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.definite_vars((builtin.in), (builtin.out), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.disj_vars((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.dnf((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((robdd.empty_vars_set) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.entails((builtin.in), (builtin.in)), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(robdd.eq_vars((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.equivalent_vars((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.equivalent_vars_2((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.extract_implications((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.fa((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.filter_2(builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.imp_vars((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.implication_result_to_imp_vars((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.implications_2((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.intersection((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.is_terminal((builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(robdd.ite((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.ite_var((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.labelling((builtin.in), (builtin.in), (builtin.out), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.labelling_loop((builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.make_equiv((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.make_equiv_2((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.make_node((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.minimal_model((builtin.in), (builtin.in), (builtin.out), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.neq_vars((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.node_name((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.not_var((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info((robdd.one) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.print_robdd((builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(robdd.print_robdd((builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(robdd.remove_implications((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.remove_implications_2((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.rename_vars((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.restrict((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.restrict_filter(((pred((builtin.in)) is semidet) >> (pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.restrict_filter(((pred((builtin.in)) is semidet) >> (pred((builtin.in)) is semidet)), ((pred((builtin.in)) is semidet) >> (pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.restrict_threshold((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.restrict_true_false_vars((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.restrict_true_false_vars_2((builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.rev_map((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.robdd_to_dot((builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(robdd.robdd_to_dot((builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(robdd.robdd_to_dot_2((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(robdd.robdd_to_dot_stream((builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(robdd.size((builtin.in), (builtin.out), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.size((builtin.in), (builtin.out), (builtin.out), (builtin.out)), infinite, can_loop).
:- pragma termination_info(robdd.squeeze_equiv((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.terminal_name((builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(robdd.tr((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.value((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.var((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.var_entailed((builtin.in), (builtin.in)), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(robdd.var_is_constrained((builtin.in), (builtin.in)), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(robdd.var_restrict_false((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.var_restrict_true((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.vars_are_constrained((builtin.in), (builtin.in)), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(robdd.vars_are_constrained_2((builtin.in), (builtin.in)), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(robdd.vars_disentailed((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.vars_entailed((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(robdd.write_edge((builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(robdd.write_node((builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info((robdd.zero) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(robdd.'~'((builtin.in)) = (builtin.out), infinite, cannot_loop).

:- pragma exceptions(function, (robdd.(*)), 2, 0, may_throw(type_exception)).
:- pragma exceptions(function, (robdd.(+)), 2, 0, will_not_throw).
:- pragma exceptions(function, (robdd.(=:=)), 2, 0, will_not_throw).
:- pragma exceptions(function, (robdd.(=<)), 2, 0, will_not_throw).
:- pragma exceptions(function, (robdd.(=\=)), 2, 0, will_not_throw).
:- pragma exceptions(function, (robdd.add_equivalences), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.add_equivalences_2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.add_implications), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.at_most_one_of), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.at_most_one_of_2), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.clear_caches), 0, 0, will_not_throw).
:- pragma exceptions(predicate, (robdd.clear_caches), 2, 0, will_not_throw).
:- pragma exceptions(function, (robdd.conj_not_vars), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.conj_vars), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.definite_vars), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.disj_vars), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.dnf), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.empty_vars_set), 0, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.entails), 2, 0, will_not_throw).
:- pragma exceptions(function, (robdd.eq_vars), 2, 0, conditional).
:- pragma exceptions(function, (robdd.equivalent_vars), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.equivalent_vars_2), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.extract_implications), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.fa), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (robdd.filter_2), 8, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.imp_vars), 2, 0, conditional).
:- pragma exceptions(function, (robdd.implication_result_to_imp_vars), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.implications_2), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.intersection), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.is_terminal), 1, 0, will_not_throw).
:- pragma exceptions(function, (robdd.ite), 3, 0, will_not_throw).
:- pragma exceptions(function, (robdd.ite_var), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (robdd.labelling), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.labelling_loop), 6, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.make_equiv), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.make_equiv_2), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.make_node), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (robdd.minimal_model), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.neq_vars), 2, 0, conditional).
:- pragma exceptions(function, (robdd.node_name), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.not_var), 1, 0, will_not_throw).
:- pragma exceptions(function, (robdd.one), 0, 0, will_not_throw).
:- pragma exceptions(predicate, (robdd.print_robdd), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.print_robdd), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.remove_implications), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.remove_implications_2), 7, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.rename_vars), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.restrict), 2, 0, will_not_throw).
:- pragma exceptions(function, (robdd.restrict_filter), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.restrict_filter), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.restrict_threshold), 2, 0, will_not_throw).
:- pragma exceptions(function, (robdd.restrict_true_false_vars), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.restrict_true_false_vars_2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.rev_map), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.robdd_to_dot), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.robdd_to_dot), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.robdd_to_dot_2), 9, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.robdd_to_dot_stream), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.size), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.size), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.squeeze_equiv), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.terminal_name), 1, 0, may_throw(type_exception)).
:- pragma exceptions(function, (robdd.tr), 1, 0, will_not_throw).
:- pragma exceptions(function, (robdd.value), 1, 0, will_not_throw).
:- pragma exceptions(function, (robdd.var), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (robdd.var_entailed), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (robdd.var_is_constrained), 2, 0, may_throw(type_exception)).
:- pragma exceptions(function, (robdd.var_restrict_false), 2, 0, may_throw(type_exception)).
:- pragma exceptions(function, (robdd.var_restrict_true), 2, 0, may_throw(type_exception)).
:- pragma exceptions(predicate, (robdd.vars_are_constrained), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.vars_are_constrained_2), 2, 0, may_throw(type_exception)).
:- pragma exceptions(function, (robdd.vars_disentailed), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.vars_entailed), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.write_edge), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (robdd.write_node), 5, 0, may_throw(user_exception)).
:- pragma exceptions(function, (robdd.zero), 0, 0, will_not_throw).
:- pragma exceptions(function, (robdd.(~)), 1, 0, will_not_throw).
