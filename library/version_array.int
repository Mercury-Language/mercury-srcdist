:- module version_array.
:- interface.
:- import_module list.
:- import_module pretty_printer.
:- type index_out_of_bounds
	--->	index_out_of_bounds(string).
:- type version_array(T).
:- pragma obsolete((version_array.new)/2).
:- func copy(version_array.version_array(T)) = version_array.version_array(T).
:- func elem(int, version_array.version_array(T)) = T.
:- func 'elem :='(int, version_array.version_array(T), T) = version_array.version_array(T).
:- func empty = version_array.version_array(T).
:- func foldl((func(T1, T2) = T2), version_array.version_array(T1), T2) = T2.
:- pred foldl(pred(T1, T2, T2), version_array.version_array(T1), T2, T2).
:- mode foldl((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode foldl((pred((builtin.in), (builtin.mdi), (builtin.muo)) is det), (builtin.in), (builtin.mdi), (builtin.muo)) is det.
:- mode foldl((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode foldl((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- mode foldl((pred((builtin.in), (builtin.mdi), (builtin.muo)) is semidet), (builtin.in), (builtin.mdi), (builtin.muo)) is semidet.
:- mode foldl((pred((builtin.in), (builtin.di), (builtin.uo)) is semidet), (builtin.in), (builtin.di), (builtin.uo)) is semidet.
:- pred foldl2(pred(T1, T2, T2, T3, T3), version_array.version_array(T1), T2, T2, T3, T3).
:- mode foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- mode foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det.
:- mode foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det.
:- mode foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet.
:- mode foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet), (builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet.
:- mode foldl2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet.
:- func foldr((func(T1, T2) = T2), version_array.version_array(T1), T2) = T2.
:- pred foldr(pred(T1, T2, T2), version_array.version_array(T1), T2, T2).
:- mode foldr((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode foldr((pred((builtin.in), (builtin.mdi), (builtin.muo)) is det), (builtin.in), (builtin.mdi), (builtin.muo)) is det.
:- mode foldr((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode foldr((pred((builtin.in), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- mode foldr((pred((builtin.in), (builtin.mdi), (builtin.muo)) is semidet), (builtin.in), (builtin.mdi), (builtin.muo)) is semidet.
:- mode foldr((pred((builtin.in), (builtin.di), (builtin.uo)) is semidet), (builtin.in), (builtin.di), (builtin.uo)) is semidet.
:- pred foldr2(pred(T1, T2, T2, T3, T3), version_array.version_array(T1), T2, T2, T3, T3).
:- mode foldr2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- mode foldr2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is det.
:- mode foldr2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det.
:- mode foldr2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is semidet.
:- mode foldr2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet), (builtin.in), (builtin.in), (builtin.out), (builtin.mdi), (builtin.muo)) is semidet.
:- mode foldr2((pred((builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is semidet.
:- func from_list(list.list(T)) = version_array.version_array(T).
:- func init(int, T) = version_array.version_array(T).
:- func list(version_array.version_array(T)) = list.list(T).
:- func lookup(version_array.version_array(T), int) = T.
:- func max(version_array.version_array(T)) = int.
:- func new(int, T) = version_array.version_array(T).
:- func resize(version_array.version_array(T), int, T) = version_array.version_array(T).
:- pred resize(int, T, version_array.version_array(T), version_array.version_array(T)).
:- mode resize((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- pred set(int, T, version_array.version_array(T), version_array.version_array(T)).
:- mode set((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- func size(version_array.version_array(T)) = int.
:- func to_list(version_array.version_array(T)) = list.list(T).
:- func unsafe_empty = version_array.version_array(T).
:- func unsafe_new(int, T) = version_array.version_array(T).
:- func unsafe_rewind(version_array.version_array(T)) = version_array.version_array(T).
:- pred unsafe_rewind(version_array.version_array(T), version_array.version_array(T)).
:- mode unsafe_rewind((builtin.in), (builtin.out)) is det.
:- func version_array(list.list(T)) = version_array.version_array(T).
:- func version_array_to_doc(version_array.version_array(T)) = pretty_printer.doc.
:- implementation.
:- type version_array(T)
	--->	version_array(T).
:- pragma foreign_type(c, version_array(T), "struct ML_va *")
	where	type_is_abstract_noncanonical.
:- pragma foreign_type(java, version_array(T), "jmercury.version_array.ML_va")
	where	type_is_abstract_noncanonical.
:- pragma foreign_type(csharp, version_array(T), "version_array.ML_va")
	where	type_is_abstract_noncanonical.
:- pragma foreign_import_module("C", version_array).
:- pragma foreign_import_module("C#", version_array).
:- pragma foreign_import_module("Java", version_array).
:- pragma foreign_import_module("C", version_array).
:- pragma foreign_import_module("C#", version_array).
:- pragma foreign_import_module("Java", version_array).
