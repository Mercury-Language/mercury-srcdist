:- module pprint.
:- use_module array.
:- use_module builtin.
:- use_module char.
:- use_module deconstruct.
:- use_module enum.
:- use_module int.
:- use_module int16.
:- use_module int32.
:- use_module int64.
:- use_module int8.
:- use_module io.
:- use_module list.
:- use_module map.
:- use_module ops.
:- use_module pair.
:- use_module private_builtin.
:- use_module robdd.
:- use_module sparse_bitset.
:- use_module stream.
:- use_module string.
:- use_module term.
:- use_module type_desc.
:- use_module uint16.
:- use_module uint32.
:- use_module uint64.
:- use_module uint8.
:- use_module univ.
:- use_module version_array.
:- use_module (string.format).
:- use_module (string.parse_util).

:- type depth == int.
:- type doc
    --->    pp_nil 
    ;       pp_text(string)
    ;       pp_line 
    ;       pp_seq(pprint.doc, pprint.doc)
    ;       pp_group(pprint.doc)
    ;       pp_nest(int, pprint.doc)
    ;       pp_label(string, pprint.doc)
    ;       pp_doc(int, univ.univ).
:- type map_pair(K, V)
    --->    map_pair(K, V).

:- instance (pprint.doc(character)).
:- instance (pprint.doc(pprint.doc)).
:- instance (pprint.doc(float)).
:- instance (pprint.doc(int)).
:- instance (pprint.doc(int16)).
:- instance (pprint.doc(int32)).
:- instance (pprint.doc(int64)).
:- instance (pprint.doc(int8)).
:- instance (pprint.doc(string)).
:- instance (pprint.doc(uint)).
:- instance (pprint.doc(uint16)).
:- instance (pprint.doc(uint32)).
:- instance (pprint.doc(uint64)).
:- instance (pprint.doc(uint8)).

:- pred pprint.fits_flat(pprint.doc, int).
:- mode fits_flat((builtin.in), (builtin.in)) is semidet.
:- pred pprint.fits_flat_width_left(pprint.doc, int, int).
:- mode fits_flat_width_left((builtin.in), (builtin.in), (builtin.out)) is semidet.
:- pred pprint.layout_best(pred(string, T, T), int, pprint.doc, T, T).
:- mode layout_best(((pred((builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode layout_best(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- pred pprint.layout_best_acc(pred(string, T, T), int, string, pprint.doc, int, int, T, T).
:- mode layout_best_acc(((pred((builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det.
:- mode layout_best_acc(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- pred pprint.layout_flat(pred(string, T, T), pprint.doc, int, int, T, T).
:- mode layout_flat(((pred((builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)) is det.
:- mode layout_flat(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- func pprint.to_doc_prio(int, ops.priority, T) = pprint.doc.
:- mode to_doc_prio((builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.

pprint.(V_4 ++ V_5) = V_3 :-
    V_3 = pprint.'<>'(V_6, V_7),
    V_6 = pprint.doc(V_4),
    V_7 = pprint.doc(V_5).

pprint.'</>'(V_4, V_5) = V_3 :-
    V_3 = pprint.(V_4 ++ V_6),
    V_6 = pprint.(V_7 ++ V_5),
    V_7 = pprint.line.

pprint.'<>'(V_4, V_5) = pprint.pp_seq(V_4, V_5).

pprint.braces(V_3) = V_2 :-
    V_2 = pprint.bracketed(V_4, V_5, V_3),
    V_4 = "{" : string,
    V_5 = "}" : string.

pprint.bracketed(V_5, V_6, V_7) = V_4 :-
    V_4 = pprint.(V_5 ++ V_8),
    V_8 = pprint.(V_7 ++ V_6).

pprint.brackets(V_3) = V_2 :-
    V_2 = pprint.bracketed(V_4, V_5, V_3),
    V_4 = "[" : string,
    V_5 = "]" : string.

pprint.colon = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = ":" : string.

pprint.colon_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = ":" : string,
    V_3 = pprint.line.

pprint.colon_space = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = ": " : string.

pprint.colon_space_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = ": " : string,
    V_3 = pprint.line.

pprint.comma = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = "," : string.

pprint.comma_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = "," : string,
    V_3 = pprint.line.

pprint.comma_space = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = ", " : string.

pprint.comma_space_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = ", " : string,
    V_3 = pprint.line.

pprint.doc(V_3) = V_2 :-
    V_2 = pprint.doc(V_4, V_3),
    V_4 = int.max_int.

pprint.ellipsis = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = "..." : string.

pprint.fits_flat(V_3, V_4) :-
    pprint.fits_flat_width_left(V_3, V_4, V_5).

pprint.group(V_3) = pprint.pp_group(V_4) :-
    V_4 = pprint.doc(V_3).

pprint.label(V_4, V_5) = pprint.pp_label(V_4, V_6) :-
    V_6 = pprint.doc(V_5).

pprint.layout_best(V_6, V_7, V_8, V_11, V_12) :-
    V_13 = "" : string,
    V_14 = 0 : int,
    pprint.layout_best_acc(V_6, V_7, V_13, V_8, V_14, V_10, V_11, V_12).

pprint.layout_best_acc(V_9, V_10, V_11, V_12, V_23, V_24, V_25, V_26) :-
    ( % disjunction
      V_12 = pprint.pp_nil : pprint.doc,
      V_24 = V_23,
      V_26 = V_25
    ;
      V_12 = pprint.pp_seq(V_15, V_16) : pprint.doc,
      pprint.layout_best_acc(V_9, V_10, V_11, V_15, V_23, V_27, V_25, V_28),
      pprint.layout_best_acc(V_9, V_10, V_11, V_16, V_27, V_24, V_28, V_26)
    ;
      V_12 = pprint.pp_nest(V_17, V_52) : pprint.doc,
      V_18 = string.(V_11 ++ V_31),
      V_31 = string.duplicate_char(V_32, V_17),
      V_32 = (' ') : character,
      pprint.layout_best_acc(V_9, V_10, V_18, V_52, V_23, V_24, V_25, V_26)
    ;
      V_12 = pprint.pp_label(V_19, V_53) : pprint.doc,
      V_54 = string.(V_11 ++ V_19),
      pprint.layout_best_acc(V_9, V_10, V_54, V_53, V_23, V_24, V_25, V_26)
    ;
      V_12 = pprint.pp_line : pprint.doc,
      V_24 = string.count_codepoints(V_11),
      V_38 = "\n" : string,
      call(V_9, V_38, V_25, V_39),
      call(V_9, V_11, V_39, V_26)
    ;
      V_12 = pprint.pp_group(V_55) : pprint.doc,
      ( if
        V_41 = int.(V_10 - V_23),
        pprint.fits_flat(V_55, V_41)
      then
        pprint.layout_flat(V_9, V_55, V_23, V_24, V_25, V_26)
      else
        pprint.layout_best_acc(V_9, V_10, V_11, V_55, V_23, V_24, V_25, V_26)
      )
    ;
      V_12 = pprint.pp_doc(V_20, V_21) : pprint.doc,
      V_56 = pprint.to_doc(V_20, V_46),
      V_46 = univ.univ_value(V_21),
      pprint.layout_best_acc(V_9, V_10, V_11, V_56, V_23, V_24, V_25, V_26)
    ;
      V_12 = pprint.pp_text(V_22) : pprint.doc,
      V_24 = int.(V_23 + V_50),
      V_50 = string.count_codepoints(V_22),
      call(V_9, V_22, V_25, V_26)
    ).

pprint.layout_flat(V_7, V_8, V_18, V_19, V_20, V_21) :-
    ( % disjunction
      V_8 = pprint.pp_nil : pprint.doc,
      V_19 = V_18,
      V_21 = V_20
    ;
      V_8 = pprint.pp_line : pprint.doc,
      V_19 = V_18,
      V_21 = V_20
    ;
      V_8 = pprint.pp_text(V_11) : pprint.doc,
      V_19 = int.(V_18 + V_23),
      V_23 = string.count_codepoints(V_11),
      call(V_7, V_11, V_20, V_21)
    ;
      V_8 = pprint.pp_seq(V_12, V_13) : pprint.doc,
      pprint.layout_flat(V_7, V_12, V_18, V_25, V_20, V_26),
      pprint.layout_flat(V_7, V_13, V_25, V_19, V_26, V_21)
    ;
      ( % disjunction
        V_8 = pprint.pp_group(V_34) : pprint.doc
      ;
        V_8 = pprint.pp_nest(V_14, V_34) : pprint.doc
      ;
        V_8 = pprint.pp_label(V_15, V_34) : pprint.doc
      ),
      pprint.layout_flat(V_7, V_34, V_18, V_19, V_20, V_21)
    ;
      V_8 = pprint.pp_doc(V_16, V_17) : pprint.doc,
      V_35 = pprint.to_doc(V_16, V_31),
      V_31 = univ.univ_value(V_17),
      pprint.layout_flat(V_7, V_35, V_18, V_19, V_20, V_21)
    ).

pprint.line = pprint.pp_line.

pprint.nest(V_4, V_5) = pprint.pp_nest(V_4, V_6) :-
    V_6 = pprint.doc(V_5).

pprint.nil = pprint.pp_nil.

pprint.packed(V_4, V_5) = V_3 :-
    V_3 = pprint.packed(V_6, V_4, V_5),
    V_6 = int.max_int.

pprint.packed_cs(V_3) = V_2 :-
    V_2 = pprint.packed(V_4, V_3),
    V_4 = ", " : string.

pprint.packed_cs(V_4, V_5) = V_3 :-
    V_3 = pprint.packed(V_4, V_6, V_5),
    V_6 = ", " : string.

pprint.packed_cs_to_depth(V_4, V_5) = V_3 :-
    V_3 = pprint.packed_cs(V_4, V_6),
    V_6 = list.map(V_7, V_5),
    V_7 = pprint.to_doc(V_4) : ((func T_1) = pprint.doc).

pprint.packed_cs_univ_args(V_4, V_5) = V_3 :-
    V_3 = pprint.packed_cs(V_4, V_7),
    V_7 = list.map(V_8, V_5),
    V_8 = (func(V_9::(ground >> ground)) = (V_10::(free >> ground)) is det :-
      some [] (
        V_9 = V_11,
        V_10 = pprint.pp_doc(V_4, V_11) : pprint.doc
      )
    ) : ((func univ.univ) = pprint.doc).

pprint.parentheses(V_3) = V_2 :-
    V_2 = pprint.bracketed(V_4, V_5, V_3),
    V_4 = "(" : string,
    V_5 = ")" : string.

pprint.semic = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = ";" : string.

pprint.semic_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = ";" : string,
    V_3 = pprint.line.

pprint.semic_space = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = "; " : string.

pprint.semic_space_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = "; " : string,
    V_3 = pprint.line.

pprint.separated(V_5, V_6, list.[]) = V_4 :-
    V_4 = pprint.nil.
pprint.separated(V_7, V_8, list.[V_9 | V_10]) = V_11 :-
    ( % disjunction
      V_10 = list.[] : list.list(T1_1),
      V_11 = apply(V_7, V_9)
    ;
      V_10 = list.[V_12 | V_13] : list.list(T1_1),
      V_11 = pprint.(V_14 ++ V_15),
      V_14 = apply(V_7, V_9),
      V_15 = pprint.(V_8 ++ V_16),
      V_16 = pprint.separated(V_7, V_8, V_10)
    ).

pprint.space = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = " " : string.

pprint.space_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = " " : string,
    V_3 = pprint.line.

pprint.text(V_3) = pprint.pp_text(V_3).

pprint.to_doc(V_3) = V_2 :-
    V_2 = pprint.to_doc(V_4, V_3),
    V_4 = int.max_int.

pprint.to_doc(V_4, V_5) = V_3 :-
    V_3 = pprint.to_doc_prio(V_4, V_6, V_5),
    V_6 = ops.mercury_op_table_comma_priority.

pprint.write(V_5, V_6, V_8, V_9) :-
    V_10 = io.write_string : pred(string, io.state, io.state),
    V_11 = pprint.doc(V_6),
    pprint.layout_best(V_10, V_5, V_11, V_8, V_9).

pprint.write(V_6, V_7, V_8, V_10, V_11) :-
    V_12 = stream.put(V_6) : pred(string, State_3, State_3),
    V_13 = pprint.doc(V_8),
    pprint.layout_best(V_12, V_7, V_13, V_10, V_11).

:- pragma termination_info(pprint.'++'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'</>'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'<>'((builtin.in), (builtin.in)) = (builtin.out), finite(2, [yes, yes, no]), cannot_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____character__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____float__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____int16__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____int32__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____int64__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____int8__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____int__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____pprint__doc__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, yes, no]), cannot_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____string__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), finite(1, [no, yes, no]), cannot_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____uint16__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____uint32__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____uint64__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____uint8__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____uint__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.braces((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.bracketed((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.brackets((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.colon) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.colon_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.colon_space) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.colon_space_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.comma) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.comma_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.comma_space) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.comma_space_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.doc((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.doc((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.ellipsis) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info(pprint.fits_flat((builtin.in), (builtin.in)), finite(0, [no, no]), can_loop).
:- pragma termination_info(pprint.fits_flat_width_left((builtin.in), (builtin.in), (builtin.out)), finite(0, [no, yes, no]), can_loop).
:- pragma termination_info(pprint.group((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.label((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.layout_best(((pred((builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(pprint.layout_best(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(pprint.layout_best_acc(((pred((builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(pprint.layout_best_acc(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(pprint.layout_flat(((pred((builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.out), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(pprint.layout_flat(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info((pprint.line) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(pprint.nest((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.nil) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(pprint.packed((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed_cs((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed_cs((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed_cs_to_depth((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed_cs_univ_args((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.parentheses((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.poly((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.semic) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.semic_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.semic_space) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.semic_space_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.separated((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.space) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.space_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.text((builtin.in)) = (builtin.out), finite(1, [yes, no]), cannot_loop).
:- pragma termination_info(pprint.to_doc((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.to_doc((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.to_doc_prio((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.to_string((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.word_wrapped((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.write((builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(pprint.write((builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).

:- pragma exceptions(function, (pprint.(++)), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.'</>'), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.'<>'), 2, 0, will_not_throw).
:- pragma exceptions(function, (pprint.braces), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.bracketed), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.brackets), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.colon), 0, 0, will_not_throw).
:- pragma exceptions(function, (pprint.colon_line), 0, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.colon_space), 0, 0, will_not_throw).
:- pragma exceptions(function, (pprint.colon_space_line), 0, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.comma), 0, 0, will_not_throw).
:- pragma exceptions(function, (pprint.comma_line), 0, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.comma_space), 0, 0, will_not_throw).
:- pragma exceptions(function, (pprint.comma_space_line), 0, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.doc), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.doc), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.ellipsis), 0, 0, will_not_throw).
:- pragma exceptions(predicate, (pprint.fits_flat), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.fits_flat_width_left), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.group), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.label), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.layout_best), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.layout_best), 5, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.layout_best_acc), 8, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.layout_best_acc), 8, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.layout_flat), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.layout_flat), 6, 1, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.line), 0, 0, will_not_throw).
:- pragma exceptions(function, (pprint.nest), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.nil), 0, 0, will_not_throw).
:- pragma exceptions(function, (pprint.packed), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed_cs), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed_cs), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed_cs_to_depth), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed_cs_univ_args), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.parentheses), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.poly), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.semic), 0, 0, will_not_throw).
:- pragma exceptions(function, (pprint.semic_line), 0, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.semic_space), 0, 0, will_not_throw).
:- pragma exceptions(function, (pprint.semic_space_line), 0, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.separated), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.space), 0, 0, will_not_throw).
:- pragma exceptions(function, (pprint.space_line), 0, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.text), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.to_doc), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.to_doc), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.to_doc_prio), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.to_string), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.word_wrapped), 1, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.write), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.write), 5, 0, may_throw(user_exception)).
