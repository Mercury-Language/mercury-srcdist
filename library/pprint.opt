:- module pprint.
:- use_module array.
:- use_module builtin.
:- use_module char.
:- use_module deconstruct.
:- use_module enum.
:- use_module int.
:- use_module io.
:- use_module list.
:- use_module map.
:- use_module ops.
:- use_module pair.
:- use_module private_builtin.
:- use_module robdd.
:- use_module sparse_bitset.
:- use_module stream.
:- use_module string.
:- use_module term.
:- use_module type_desc.
:- use_module univ.
:- use_module version_array.
:- use_module (string.format).
:- use_module (string.parse_util).

:- type depth == int.
:- type doc
    --->    'NIL' 
    ;       'SEQ'(pprint.doc, pprint.doc)
    ;       'NEST'(int, pprint.doc)
    ;       'LABEL'(string, pprint.doc)
    ;       'TEXT'(string)
    ;       'LINE' 
    ;       'GROUP'(pprint.doc)
    ;       'DOC'(int, univ.univ).
:- type map_pair(K, V)
    --->    map_pair(K, V).

:- instance (pprint.doc(pprint.doc)).
:- instance (pprint.doc(int)).
:- instance (pprint.doc(uint)).
:- instance (pprint.doc(int8)).
:- instance (pprint.doc(uint8)).
:- instance (pprint.doc(int16)).
:- instance (pprint.doc(uint16)).
:- instance (pprint.doc(int32)).
:- instance (pprint.doc(uint32)).
:- instance (pprint.doc(float)).
:- instance (pprint.doc(string)).
:- instance (pprint.doc(character)).

:- pred pprint.layout_best(pred(string, T_1, T_1), int, pprint.doc, T_1, T_1).
:- mode pprint.layout_best((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode pprint.layout_best((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- pred pprint.lb(pred(string, T_1, T_1), int, int, int, string, pprint.doc, T_1, T_1).
:- mode pprint.lb((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode pprint.lb((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- func pprint.to_doc(int, int, T_1) = pprint.doc.
:- mode pprint.to_doc((builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.

pprint.(V_4 ++ V_5) = V_3 :-
    V_3 = pprint.'<>'(V_6, V_7),
    V_6 = pprint.doc(V_4),
    V_7 = pprint.doc(V_5).

pprint.'</>'(V_4, V_5) = V_3 :-
    V_3 = pprint.(V_4 ++ V_6),
    V_6 = pprint.(V_7 ++ V_5),
    V_7 = pprint.line.

pprint.'<>'(V_4, V_5) = pprint.'SEQ'(V_4, V_5).

pprint.braces(V_3) = V_2 :-
    V_2 = pprint.bracketed(V_4, V_5, V_3),
    V_4 = "{" : string,
    V_5 = "}" : string.

pprint.bracketed(V_5, V_6, V_7) = V_4 :-
    V_4 = pprint.(V_5 ++ V_8),
    V_8 = pprint.(V_7 ++ V_6).

pprint.brackets(V_3) = V_2 :-
    V_2 = pprint.bracketed(V_4, V_5, V_3),
    V_4 = "[" : string,
    V_5 = "]" : string.

pprint.colon = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = ":" : string.

pprint.colon_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = ":" : string,
    V_3 = pprint.line.

pprint.colon_space = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = ": " : string.

pprint.colon_space_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = ": " : string,
    V_3 = pprint.line.

pprint.comma = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = "," : string.

pprint.comma_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = "," : string,
    V_3 = pprint.line.

pprint.comma_space = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = ", " : string.

pprint.comma_space_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = ", " : string,
    V_3 = pprint.line.

pprint.doc(V_3) = V_2 :-
    V_2 = pprint.doc(V_4, V_3),
    V_4 = int.max_int.

pprint.ellipsis = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = "..." : string.

pprint.group(V_3) = pprint.'GROUP'(V_4) :-
    V_4 = pprint.doc(V_3).

pprint.label(V_4, V_5) = pprint.'LABEL'(V_4, V_6) :-
    V_6 = pprint.doc(V_5).

pprint.layout_best(V_6, V_7, V_8, V_9, V_10) :-
    V_12 = 0 : int,
    V_13 = "" : string,
    pprint.lb(V_6, V_7, V_12, V_11, V_13, V_8, V_9, V_10).

pprint.line = pprint.'LINE'.

pprint.nest(V_4, V_5) = pprint.'NEST'(V_4, V_6) :-
    V_6 = pprint.doc(V_5).

pprint.nil = pprint.'NIL'.

pprint.packed(V_4, V_5) = V_3 :-
    V_3 = pprint.packed(V_6, V_4, V_5),
    V_6 = int.max_int.

pprint.packed_cs(V_3) = V_2 :-
    V_2 = pprint.packed(V_4, V_3),
    V_4 = ", " : string.

pprint.packed_cs(V_4, V_5) = V_3 :-
    V_3 = pprint.packed(V_4, V_6, V_5),
    V_6 = ", " : string.

pprint.packed_cs_to_depth(V_4, V_5) = V_3 :-
    V_3 = pprint.packed_cs(V_4, V_6),
    V_6 = list.map(V_7, V_5),
    V_7 = pprint.to_doc(V_4) : ((func T_1) = pprint.doc).

pprint.packed_cs_univ_args(V_4, V_5) = V_3 :-
    V_3 = pprint.packed_cs(V_4, V_7),
    V_7 = list.map(V_8, V_5),
    V_8 = (func(V_9::(builtin.in)) = (V_10::(builtin.out)) is det :-
      some [] (
        V_9 = V_11,
        V_10 = pprint.'DOC'(V_4, V_11) : pprint.doc
      )
    )
 : ((func univ.univ) = pprint.doc).

pprint.parentheses(V_3) = V_2 :-
    V_2 = pprint.bracketed(V_4, V_5, V_3),
    V_4 = "(" : string,
    V_5 = ")" : string.

pprint.semic = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = ";" : string.

pprint.semic_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = ";" : string,
    V_3 = pprint.line.

pprint.semic_space = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = "; " : string.

pprint.semic_space_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = "; " : string,
    V_3 = pprint.line.

pprint.separated(V_5, V_6, list.[]) = V_4 :-
    V_4 = pprint.nil.
pprint.separated(V_7, V_8, list.[V_9 | V_10]) = V_4 :-
    ( if
      V_10 = list.[] : list.list(T1_1)
    then
      V_4 = apply(V_7, V_9)
    else
      V_4 = pprint.(V_11 ++ V_12),
      V_11 = apply(V_7, V_9),
      V_12 = pprint.(V_8 ++ V_13),
      V_13 = pprint.separated(V_7, V_8, V_10)
    ).

pprint.space = V_1 :-
    V_1 = pprint.text(V_2),
    V_2 = " " : string.

pprint.space_line = V_1 :-
    V_1 = pprint.(V_2 ++ V_3),
    V_2 = " " : string,
    V_3 = pprint.line.

pprint.text(V_3) = pprint.'TEXT'(V_3).

pprint.to_doc(V_3) = V_2 :-
    V_2 = pprint.to_doc(V_4, V_3),
    V_4 = int.max_int.

pprint.to_doc(V_4, V_5) = V_3 :-
    V_3 = pprint.to_doc(V_4, V_6, V_5),
    V_6 = 1000 : int.

pprint.write(V_5, V_6, V_8, V_9) :-
    V_10 = io.write_string : pred(string, io.state, io.state),
    V_11 = pprint.doc(V_6),
    pprint.layout_best(V_10, V_5, V_11, V_8, V_9).

pprint.write(V_6, V_7, V_8, V_10, V_11) :-
    V_12 = stream.put(V_6) : pred(string, State_3, State_3),
    V_13 = pprint.doc(V_8),
    pprint.layout_best(V_12, V_7, V_13, V_10, V_11).

:- pragma exceptions(function, (pprint.(++)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.'</>'), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.'<>'), 3, 0, will_not_throw).
:- pragma exceptions(function, (pprint.braces), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.bracketed), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.brackets), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.colon), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.colon_line), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.colon_space), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.colon_space_line), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.comma), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.comma_line), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.comma_space), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.comma_space_line), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.doc), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.doc), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.ellipsis), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.group), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.label), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.layout_best), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.layout_best), 5, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.lb), 8, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.lb), 8, 1, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.line), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.nest), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.nil), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.packed), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed_cs), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed_cs), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed_cs_to_depth), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.packed_cs_univ_args), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.parentheses), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.poly), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.semic), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.semic_line), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.semic_space), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.semic_space_line), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.separated), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.space), 1, 0, will_not_throw).
:- pragma exceptions(function, (pprint.space_line), 1, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.text), 2, 0, will_not_throw).
:- pragma exceptions(function, (pprint.to_doc), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.to_doc), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.to_doc), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.to_string), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (pprint.word_wrapped), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.write), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (pprint.write), 5, 0, may_throw(user_exception)).

:- pragma termination_info(pprint.'++'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'</>'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'<>'((builtin.in), (builtin.in)) = (builtin.out), finite(2, [yes, yes, no]), cannot_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____character__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____float__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____int16__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____int32__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____int8__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____int__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____pprint__doc__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, yes, no]), cannot_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____string__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), finite(1, [no, yes, no]), cannot_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____uint16__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____uint32__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____uint8__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.'ClassMethod_for_pprint__doc____uint__arity0______pprint__doc_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.braces((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.bracketed((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.brackets((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.colon) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.colon_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.colon_space) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.colon_space_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.comma) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.comma_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.comma_space) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.comma_space_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.doc((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.doc((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.ellipsis) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info(pprint.group((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.label((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.layout_best((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(pprint.layout_best((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(pprint.lb((pred((builtin.in), (builtin.di), (builtin.uo)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(pprint.lb((pred((builtin.in), (builtin.in), (builtin.out)) is det), (builtin.in), (builtin.in), (builtin.out), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info((pprint.line) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(pprint.nest((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.nil) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(pprint.packed((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed_cs((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed_cs((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed_cs_to_depth((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.packed_cs_univ_args((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.parentheses((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.poly((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.semic) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.semic_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.semic_space) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.semic_space_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.separated((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info((pprint.space) = (builtin.out), finite(1, [no]), cannot_loop).
:- pragma termination_info((pprint.space_line) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.text((builtin.in)) = (builtin.out), finite(1, [yes, no]), cannot_loop).
:- pragma termination_info(pprint.to_doc((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.to_doc((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.to_doc((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.to_string((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.word_wrapped((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(pprint.write((builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(pprint.write((builtin.in), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
