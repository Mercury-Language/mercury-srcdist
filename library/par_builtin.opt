:- module par_builtin.
:- use_module builtin, io, private_builtin.
:- type par_builtin.future(T).
:- pragma foreign_type(il, par_builtin.future(T), "class [mscorlib]System.Object").
:- pragma foreign_type(c, par_builtin.future(T), "MR_Future *", [can_pass_as_mercury_type]).
:- pragma foreign_type(java, par_builtin.future(T), "java.lang.Object").
:- pragma foreign_type(erlang, par_builtin.future(T), "").
:- pragma foreign_import_module("C", par_builtin).
:- pragma foreign_import_module("Java", par_builtin).
:- pragma foreign_import_module("IL", par_builtin).
:- pragma foreign_import_module("Erlang", par_builtin).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("Erlang", io).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("IL", io).
:- pragma foreign_import_module("Erlang", io).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("IL", bitmap).
:- pragma foreign_import_module("Erlang", bitmap).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("IL", bitmap).
:- pragma foreign_import_module("Erlang", bitmap).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
:- pragma foreign_import_module("Erlang", time).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("Java", time).
:- pragma foreign_import_module("IL", time).
:- pragma foreign_import_module("Erlang", time).
:- pragma foreign_proc("C", par_builtin.new_future(Future :: (builtin.uo)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
#if (!defined MR_HIGHLEVEL_CODE) && (defined MR_THREAD_SAFE)

    MR_Word fut_addr;

    MR_incr_hp(fut_addr, MR_round_up(sizeof(MR_Future), sizeof(MR_Word)));
    Future = (MR_Future *) fut_addr;

    pthread_mutex_init(&(Future->MR_fut_lock), MR_MUTEX_ATTR);

    /*
    ** The mutex needs to be destroyed when the future is garbage collected.
    ** For efficiency we might want to ignore this altogether, e.g. on Linux
    ** pthread_mutex_destroy() only checks that the mutex is unlocked.
    **
    ** We initialize the value field only to prevent its previous value,
    ** which may point to an allocated block, keeping that block alive.
    ** Semantically, the value field is undefined at this point in time.
    */
  #ifdef MR_CONSERVATIVE_GC
    GC_REGISTER_FINALIZER(Future, MR_finalize_future, NULL, NULL, NULL);
    Future->MR_fut_value = 0;
  #endif

    Future->MR_fut_signalled = MR_FALSE;
    Future->MR_fut_suspended = NULL;

#else

    MR_fatal_error(\"internal error: par_builtin should only be used by \"
        \"lowlevel parallel grades\");

#endif
").
:- pragma foreign_proc("C", par_builtin.wait(Future :: (builtin.in), Value :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
#if (!defined MR_HIGHLEVEL_CODE) && (defined MR_THREAD_SAFE)

    /*
    ** It would be nice if we could rely on an invariant such as
    ** `if MR_fut_signalled is true, then reading MR_fut_value is ok\'
    ** even *without* wrapping up those two field accesses in the mutex,
    ** taking the mutex only when MR_fut_signalled is false. (We would
    ** then have to repeat the test of MR_fut_signalled, of course.)
    ** Unfortunately, memory systems today cannot be relied on to provide
    ** the required level of consistency.
    */

    MR_LOCK(&(Future->MR_fut_lock), \"future.wait\");

    if (Future->MR_fut_signalled) {
        Value = Future->MR_fut_value;
        MR_UNLOCK(&(Future->MR_fut_lock), \"future.wait\");
    } else {
        MR_Context *ctxt;

        /*
        ** Put the address of the future at a fixed place known to
        ** mercury__par_builtin__wait_resume, to wit, the top of the stack.
        */
        MR_incr_sp(1);
        MR_sv(1) = (MR_Word) Future;

        /*
        ** Save this context and put it on the list of suspended contexts for
        ** this future.
        */
        ctxt = MR_ENGINE(MR_eng_this_context);
        MR_save_context(ctxt);

        ctxt->MR_ctxt_resume = MR_ENTRY(mercury__par_builtin__wait_resume);
        ctxt->MR_ctxt_next = Future->MR_fut_suspended;
        Future->MR_fut_suspended = ctxt;

        MR_UNLOCK(&(Future->MR_fut_lock), \"future.wait\");

        MR_ENGINE(MR_eng_this_context) = NULL;
        MR_runnext();
    }

#else

    MR_fatal_error(\"internal error: par_builtin.wait\");
    Value = -1;

#endif
").
:- pragma foreign_proc("C", par_builtin.get(Future :: (builtin.in), Value :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
#if (!defined MR_HIGHLEVEL_CODE) && (defined MR_THREAD_SAFE)

    assert(Future->MR_fut_signalled);
    Value = Future->MR_fut_value;

#else

    MR_fatal_error(\"internal error: par_builtin.get\");
    Value = -1;

#endif
").
:- pragma exceptions(predicate, (par_builtin.new_future), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (par_builtin.wait), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (par_builtin.get), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (par_builtin.signal), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (par_builtin.evaluate_parallelism_condition), 0, 0, will_not_throw).
:- pragma exceptions(predicate, (par_builtin.par_cond_outstanding_jobs_vs_num_cpus), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (par_builtin.par_cond_close_stats_file), 2, 0, will_not_throw).
:- pragma termination_info(par_builtin.new_future((builtin.uo)), infinite, cannot_loop).
:- pragma termination_info(par_builtin.wait((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(par_builtin.get((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(par_builtin.signal((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info((par_builtin.evaluate_parallelism_condition), finite(0, []), cannot_loop).
:- pragma termination_info(par_builtin.par_cond_outstanding_jobs_vs_num_cpus((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(par_builtin.par_cond_close_stats_file((builtin.di), (builtin.uo)), infinite, cannot_loop).
