:- module rtree.
:- use_module builtin.
:- use_module float.
:- use_module int.
:- use_module list.
:- use_module private_builtin.
:- use_module require.

:- type delete_info(K, V)
    --->    deleting(list.list(rtree.orphan(K, V)))
    ;       finished(int, list.list(rtree.orphan(K, V))).
:- type min_of_four_result
    --->    min4_first 
    ;       min4_second 
    ;       min4_third 
    ;       min4_fourth .
:- type min_of_three_result
    --->    min3_first 
    ;       min3_second 
    ;       min3_third .
:- type min_of_two_result
    --->    min2_first 
    ;       min2_second .
:- type orphan(K, V)
    --->    orphan(K, rtree.rtree_2(K, V)).
:- type orphans(K, V) == list.list(rtree.orphan(K, V)).
:- type rtree(K, V)
    --->    empty 
    ;       one(K, V)
    ;       rtree(rtree.rtree_2(K, V)).
:- type rtree_2(K, V)
    --->    leaf(V)
    ;       two(K, rtree.rtree_2(K, V), K, rtree.rtree_2(K, V))
    ;       three(K, rtree.rtree_2(K, V), K, rtree.rtree_2(K, V), K, rtree.rtree_2(K, V))
    ;       four(K, rtree.rtree_2(K, V), K, rtree.rtree_2(K, V), K, rtree.rtree_2(K, V), K, rtree.rtree_2(K, V)).

:- inst four for rtree.rtree_2/2
    --->    four(ground, ground, ground, ground, ground, ground, ground, ground).

:- instance (rtree.region(rtree.box)) where [
	pred((rtree.intersects)/2) is (rtree.box_intersects),
	pred((rtree.contains)/2) is (rtree.box_contains),
	func((rtree.size)/1) is (rtree.box_area),
	func((rtree.bounding_region)/2) is (rtree.box_bounding_region),
	func((rtree.bounding_region_size)/2) is (rtree.box_bounding_region_area)
].
:- instance (rtree.region(rtree.box3d)) where [
	pred((rtree.intersects)/2) is (rtree.box3d_intersects),
	pred((rtree.contains)/2) is (rtree.box3d_contains),
	func((rtree.size)/1) is (rtree.box3d_volume),
	func((rtree.bounding_region)/2) is (rtree.box3d_bounding_region),
	func((rtree.bounding_region_size)/2) is (rtree.box3d_bounding_region_volume)
].
:- instance (rtree.region(rtree.interval)) where [
	pred((rtree.intersects)/2) is (rtree.interval_intersects),
	pred((rtree.contains)/2) is (rtree.interval_contains),
	func((rtree.size)/1) is (rtree.interval_length),
	func((rtree.bounding_region)/2) is (rtree.interval_bounding_region),
	func((rtree.bounding_region_size)/2) is (rtree.interval_bounding_region_length)
].

:- func rtree.box3d_bounding_region(rtree.box3d, rtree.box3d) = rtree.box3d.
:- mode box3d_bounding_region((builtin.in), (builtin.in)) = (builtin.out) is det.
:- func rtree.box3d_bounding_region_volume(rtree.box3d, rtree.box3d) = float.
:- mode box3d_bounding_region_volume((builtin.in), (builtin.in)) = (builtin.out) is det.
:- pred rtree.box3d_contains(rtree.box3d, rtree.box3d).
:- mode box3d_contains((builtin.in), (builtin.in)) is semidet.
:- pred rtree.box3d_intersects(rtree.box3d, rtree.box3d).
:- mode box3d_intersects((builtin.in), (builtin.in)) is semidet.
:- func rtree.box3d_volume(rtree.box3d) = float.
:- mode box3d_volume((builtin.in)) = (builtin.out) is det.
:- func rtree.box_area(rtree.box) = float.
:- mode box_area((builtin.in)) = (builtin.out) is det.
:- func rtree.box_bounding_region(rtree.box, rtree.box) = rtree.box.
:- mode box_bounding_region((builtin.in), (builtin.in)) = (builtin.out) is det.
:- func rtree.box_bounding_region_area(rtree.box, rtree.box) = float.
:- mode box_bounding_region_area((builtin.in), (builtin.in)) = (builtin.out) is det.
:- pred rtree.box_contains(rtree.box, rtree.box).
:- mode box_contains((builtin.in), (builtin.in)) is semidet.
:- pred rtree.box_intersects(rtree.box, rtree.box).
:- mode box_intersects((builtin.in), (builtin.in)) is semidet.
:- pred rtree.fold_2(pred(K, V, A, A), rtree.rtree_2(K, V), A, A).
:- mode fold_2(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode fold_2(((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode fold_2(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- pred rtree.fold_subtree(pred(K, V, A, A), K, rtree.rtree_2(K, V), A, A).
:- mode fold_subtree(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode fold_subtree(((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det.
:- mode fold_subtree(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- func rtree.interval_bounding_region(rtree.interval, rtree.interval) = rtree.interval.
:- mode interval_bounding_region((builtin.in), (builtin.in)) = (builtin.out) is det.
:- func rtree.interval_bounding_region_length(rtree.interval, rtree.interval) = float.
:- mode interval_bounding_region_length((builtin.in), (builtin.in)) = (builtin.out) is det.
:- pred rtree.interval_contains(rtree.interval, rtree.interval).
:- mode interval_contains((builtin.in), (builtin.in)) is semidet.
:- pred rtree.interval_intersects(rtree.interval, rtree.interval).
:- mode interval_intersects((builtin.in), (builtin.in)) is semidet.
:- func rtree.interval_length(rtree.interval) = float.
:- mode interval_length((builtin.in)) = (builtin.out) is det.
:- pred rtree.map_values_2(pred(K, V, W), rtree.rtree_2(K, V), rtree.rtree_2(K, W)).
:- mode map_values_2(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out)) is det.
:- mode map_values_2(((pred((builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.out)) is semidet.
:- pred rtree.map_values_key_2(pred(K, V, W), K, rtree.rtree_2(K, V), rtree.rtree_2(K, W)).
:- mode map_values_key_2(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.out)) is det.
:- mode map_values_key_2(((pred((builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.out)) is semidet.
:- pred rtree.maybe_limit(K, pred(K, E), E, E).
:- mode maybe_limit((builtin.in), builtin.in((pred((builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.out)) is semidet.
:- pred rtree.search_first_2(rtree.rtree_2(K, V), pred(K, E), pred(V, E), E, V, E).
:- mode search_first_2((builtin.in), ((pred((builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.out)) is semidet)), ((pred((builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.out), (builtin.out)) is semidet.
:- pred rtree.search_general_2(rtree.rtree_2(K, V), (pred K), (pred V), list.list(V), list.list(V)).
:- mode search_general_2((builtin.in), builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.out)) is det.
:- pred rtree.search_general_fold_2(rtree.rtree_2(K, V), (pred K), pred(K, V, A, A), A, A).
:- mode search_general_fold_2((builtin.in), ((pred((builtin.in)) is semidet) >> (pred((builtin.in)) is semidet)), ((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out)) is det.
:- mode search_general_fold_2((builtin.in), ((pred((builtin.in)) is semidet) >> (pred((builtin.in)) is semidet)), ((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.di), (builtin.uo)) is det.
:- pred rtree.search_general_fold_subtree(K, rtree.rtree_2(K, V), (pred K), pred(K, V, A, A), A, A).
:- mode search_general_fold_subtree((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out)) is det.
:- mode search_general_fold_subtree((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.di), (builtin.uo)) is det.
:- pred rtree.search_general_subtree(K, rtree.rtree_2(K, V), (pred K), (pred V), list.list(V), list.list(V)).
:- mode search_general_subtree((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.out)) is det.

rtree.fold(V_5, rtree.empty, V_7, V_8) :-
    V_8 = V_7.
rtree.fold(V_9, rtree.one(V_10, V_11), V_13, V_14) :-
    call(V_9, V_10, V_11, V_13, V_14).
rtree.fold(V_16, rtree.rtree(V_17), V_19, V_20) :-
    rtree.fold_2(V_16, V_17, V_19, V_20).

rtree.fold_2(V_5, rtree.leaf(V_6), V_7, V_8) :-
    V_9 = "fold: leaf unexpected" : string,
    require.error(V_9).
rtree.fold_2(V_10, rtree.two(V_11, V_12, V_13, V_14), V_16, V_17) :-
    rtree.fold_subtree(V_10, V_11, V_12, V_16, V_18),
    rtree.fold_subtree(V_10, V_13, V_14, V_18, V_17).
rtree.fold_2(V_20, rtree.three(V_21, V_22, V_23, V_24, V_25, V_26), V_28, V_29) :-
    rtree.fold_subtree(V_20, V_21, V_22, V_28, V_30),
    rtree.fold_subtree(V_20, V_23, V_24, V_30, V_31),
    rtree.fold_subtree(V_20, V_25, V_26, V_31, V_29).
rtree.fold_2(V_33, rtree.four(V_34, V_35, V_36, V_37, V_38, V_39, V_40, V_41), V_43, V_44) :-
    rtree.fold_subtree(V_33, V_34, V_35, V_43, V_45),
    rtree.fold_subtree(V_33, V_36, V_37, V_45, V_46),
    rtree.fold_subtree(V_33, V_38, V_39, V_46, V_47),
    rtree.fold_subtree(V_33, V_40, V_41, V_47, V_44).

rtree.fold_subtree(V_6, V_7, V_8, V_29, V_30) :-
    ( % disjunction
      V_8 = rtree.leaf(V_10) : rtree.rtree_2(K_1, V_2),
      call(V_6, V_7, V_10, V_29, V_30)
    ;
      ( % disjunction
        V_8 = rtree.two(V_11, V_12, V_13, V_14) : rtree.rtree_2(K_1, V_2)
      ;
        V_8 = rtree.three(V_15, V_16, V_17, V_18, V_19, V_20) : rtree.rtree_2(K_1, V_2)
      ;
        V_8 = rtree.four(V_21, V_22, V_23, V_24, V_25, V_26, V_27, V_28) : rtree.rtree_2(K_1, V_2)
      ),
      rtree.fold_2(V_6, V_8, V_29, V_30)
    ).

rtree.init = rtree.empty.

rtree.insert(V_5, V_6, V_8) = V_9 :-
    rtree.insert(V_5, V_6, V_8, V_9).

rtree.is_empty(rtree.empty).

rtree.map_values(V_4, rtree.empty, rtree.empty).
rtree.map_values(V_5, rtree.one(V_6, V_7), rtree.one(V_6, V_8)) :-
    call(V_5, V_6, V_7, V_8).
rtree.map_values(V_9, rtree.rtree(V_10), rtree.rtree(V_11)) :-
    rtree.map_values_2(V_9, V_10, V_11).

rtree.map_values_2(V_4, rtree.leaf(V_5), V_6) :-
    V_7 = "map_values_2: unexpected leaf." : string,
    require.error(V_7).
rtree.map_values_2(V_8, rtree.two(V_9, V_10, V_11, V_12), rtree.two(V_9, V_13, V_11, V_14)) :-
    rtree.map_values_key_2(V_8, V_9, V_10, V_13),
    rtree.map_values_key_2(V_8, V_11, V_12, V_14).
rtree.map_values_2(V_15, rtree.three(V_16, V_17, V_18, V_19, V_20, V_21), rtree.three(V_16, V_22, V_18, V_23, V_20, V_24)) :-
    rtree.map_values_key_2(V_15, V_16, V_17, V_22),
    rtree.map_values_key_2(V_15, V_18, V_19, V_23),
    rtree.map_values_key_2(V_15, V_20, V_21, V_24).
rtree.map_values_2(V_25, rtree.four(V_26, V_27, V_28, V_29, V_30, V_31, V_32, V_33), rtree.four(V_26, V_34, V_28, V_35, V_30, V_36, V_32, V_37)) :-
    rtree.map_values_key_2(V_25, V_26, V_27, V_34),
    rtree.map_values_key_2(V_25, V_28, V_29, V_35),
    rtree.map_values_key_2(V_25, V_30, V_31, V_36),
    rtree.map_values_key_2(V_25, V_32, V_33, V_37).

rtree.map_values_key_2(V_5, V_6, V_7, V_8) :-
    ( % disjunction
      V_7 = rtree.leaf(V_9) : rtree.rtree_2(K_1, V_2),
      call(V_5, V_6, V_9, V_10),
      V_8 = rtree.leaf(V_10) : rtree.rtree_2(K_1, W_3)
    ;
      ( % disjunction
        V_7 = rtree.two(V_11, V_12, V_13, V_14) : rtree.rtree_2(K_1, V_2)
      ;
        V_7 = rtree.three(V_15, V_16, V_17, V_18, V_19, V_20) : rtree.rtree_2(K_1, V_2)
      ;
        V_7 = rtree.four(V_21, V_22, V_23, V_24, V_25, V_26, V_27, V_28) : rtree.rtree_2(K_1, V_2)
      ),
      rtree.map_values_2(V_5, V_7, V_8)
    ).

rtree.maybe_limit(V_5, V_6, V_7, V_8) :-
    call(V_6, V_5, V_8),
    V_9 = builtin.(<) : builtin.comparison_result,
    builtin.compare(V_9, V_8, V_7).

rtree.search_first(V_7, V_8, rtree.one(V_9, V_10), V_11, V_10, V_12) :-
    rtree.maybe_limit(V_9, V_7, V_11, V_13),
    rtree.maybe_limit(V_10, V_8, V_11, V_12).
rtree.search_first(V_14, V_15, rtree.rtree(V_16), V_17, V_18, V_19) :-
    rtree.search_first_2(V_16, V_14, V_15, V_17, V_18, V_19).

rtree.search_general(V_5, V_6, rtree.empty) = list.[].
rtree.search_general(V_7, V_8, rtree.one(V_9, V_10)) = V_4 :-
    ( if
      call(V_7, V_9),
      call(V_8, V_10)
    then
      V_4 = list.[V_10 | V_11] : list.list(V_2),
      V_11 = list.[] : list.list(V_2)
    else
      V_4 = list.[] : list.list(V_2)
    ).
rtree.search_general(V_12, V_13, rtree.rtree(V_14)) = V_15 :-
    V_16 = list.[] : list.list(V_2),
    rtree.search_general_2(V_14, V_12, V_13, V_16, V_15).

rtree.search_general_2(rtree.leaf(V_6), V_7, V_8, V_10, V_11) :-
    ( if
      call(V_8, V_6)
    then
      V_11 = list.[V_6 | V_10] : list.list(V_2)
    else
      V_11 = V_10
    ).
rtree.search_general_2(V_13, V_14, V_15, V_21, V_22) :-
    V_13 = rtree.two(V_17, V_18, V_19, V_20) : rtree.rtree_2(K_1, V_2),
    rtree.search_general_subtree(V_17, V_18, V_14, V_15, V_21, V_23),
    rtree.search_general_subtree(V_19, V_20, V_14, V_15, V_23, V_22).
rtree.search_general_2(V_25, V_26, V_27, V_35, V_36) :-
    V_25 = rtree.three(V_29, V_30, V_31, V_32, V_33, V_34) : rtree.rtree_2(K_1, V_2),
    rtree.search_general_subtree(V_29, V_30, V_26, V_27, V_35, V_37),
    rtree.search_general_subtree(V_31, V_32, V_26, V_27, V_37, V_38),
    rtree.search_general_subtree(V_33, V_34, V_26, V_27, V_38, V_36).
rtree.search_general_2(V_40, V_41, V_42, V_52, V_53) :-
    V_40 = rtree.four(V_44, V_45, V_46, V_47, V_48, V_49, V_50, V_51) : rtree.rtree_2(K_1, V_2),
    rtree.search_general_subtree(V_44, V_45, V_41, V_42, V_52, V_54),
    rtree.search_general_subtree(V_46, V_47, V_41, V_42, V_54, V_55),
    rtree.search_general_subtree(V_48, V_49, V_41, V_42, V_55, V_56),
    rtree.search_general_subtree(V_50, V_51, V_41, V_42, V_56, V_53).

rtree.search_general_fold(V_6, V_7, rtree.empty, V_9, V_10) :-
    V_10 = V_9.
rtree.search_general_fold(V_11, V_12, rtree.one(V_13, V_14), V_16, V_17) :-
    ( if
      call(V_11, V_13)
    then
      call(V_12, V_13, V_14, V_16, V_17)
    else
      V_17 = V_16
    ).
rtree.search_general_fold(V_19, V_20, rtree.rtree(V_21), V_23, V_24) :-
    rtree.search_general_fold_2(V_21, V_19, V_20, V_23, V_24).

rtree.search_general_fold_2(rtree.leaf(V_6), V_7, V_8, V_9, V_10) :-
    V_11 = "search_general_fold_2: unexpected leaf node" : string,
    require.error(V_11).
rtree.search_general_fold_2(V_12, V_13, V_14, V_20, V_21) :-
    V_12 = rtree.two(V_16, V_17, V_18, V_19) : rtree.rtree_2(K_1, V_2),
    rtree.search_general_fold_subtree(V_16, V_17, V_13, V_14, V_20, V_22),
    rtree.search_general_fold_subtree(V_18, V_19, V_13, V_14, V_22, V_21).
rtree.search_general_fold_2(V_24, V_25, V_26, V_34, V_35) :-
    V_24 = rtree.three(V_28, V_29, V_30, V_31, V_32, V_33) : rtree.rtree_2(K_1, V_2),
    rtree.search_general_fold_subtree(V_28, V_29, V_25, V_26, V_34, V_36),
    rtree.search_general_fold_subtree(V_30, V_31, V_25, V_26, V_36, V_37),
    rtree.search_general_fold_subtree(V_32, V_33, V_25, V_26, V_37, V_35).
rtree.search_general_fold_2(V_39, V_40, V_41, V_51, V_52) :-
    V_39 = rtree.four(V_43, V_44, V_45, V_46, V_47, V_48, V_49, V_50) : rtree.rtree_2(K_1, V_2),
    rtree.search_general_fold_subtree(V_43, V_44, V_40, V_41, V_51, V_53),
    rtree.search_general_fold_subtree(V_45, V_46, V_40, V_41, V_53, V_54),
    rtree.search_general_fold_subtree(V_47, V_48, V_40, V_41, V_54, V_55),
    rtree.search_general_fold_subtree(V_49, V_50, V_40, V_41, V_55, V_52).

rtree.search_general_fold_subtree(V_7, V_8, V_9, V_10, V_13, V_14) :-
    ( if
      call(V_9, V_7)
    then
      ( if
        V_8 = rtree.leaf(V_12) : rtree.rtree_2(K_1, V_2)
      then
        call(V_10, V_7, V_12, V_13, V_14)
      else
        rtree.search_general_fold_2(V_8, V_9, V_10, V_13, V_14)
      )
    else
      V_14 = V_13
    ).

rtree.search_general_subtree(V_7, V_8, V_9, V_10, V_12, V_13) :-
    ( if
      call(V_9, V_7)
    then
      rtree.search_general_2(V_8, V_9, V_10, V_12, V_13)
    else
      V_13 = V_12
    ).

:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box3d__arity0______rtree__bounding_region_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box3d__arity0______rtree__bounding_region_size_2'((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box3d__arity0______rtree__contains_2'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box3d__arity0______rtree__intersects_2'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box3d__arity0______rtree__size_1'((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box__arity0______rtree__bounding_region_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box__arity0______rtree__bounding_region_size_2'((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box__arity0______rtree__contains_2'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box__arity0______rtree__intersects_2'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__box__arity0______rtree__size_1'((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__interval__arity0______rtree__bounding_region_2'((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__interval__arity0______rtree__bounding_region_size_2'((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__interval__arity0______rtree__contains_2'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__interval__arity0______rtree__intersects_2'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.'ClassMethod_for_rtree__region____rtree__interval__arity0______rtree__size_1'((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.bounding_region((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.bounding_region_size((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.box3d_bounding_region((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.box3d_bounding_region_volume((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(rtree.box3d_contains((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.box3d_intersects((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.box3d_volume((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.box_area((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.box_bounding_region((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.box_bounding_region_area((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(rtree.box_contains((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.box_intersects((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.contains((builtin.in), (builtin.in)), infinite, can_loop).
:- pragma termination_info(rtree.delete((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.fold(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.fold(((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(rtree.fold(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.fold_2(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.fold_2(((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(rtree.fold_2(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.fold_subtree(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.fold_subtree(((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(rtree.fold_subtree(((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info((rtree.init) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(rtree.insert((builtin.in), (builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.insert((builtin.in), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.intersects((builtin.in), (builtin.in)), infinite, can_loop).
:- pragma termination_info(rtree.interval_bounding_region((builtin.in), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.interval_bounding_region_length((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(rtree.interval_contains((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.interval_intersects((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.interval_length((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(rtree.is_empty((builtin.in)), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(rtree.map_values(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.map_values(((pred((builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.map_values_2(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.map_values_2(((pred((builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.map_values_key_2(((pred((builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.map_values_key_2(((pred((builtin.in), (builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.maybe_limit((builtin.in), builtin.in((pred((builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.search_contains((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, yes, no, no]), can_loop).
:- pragma termination_info(rtree.search_first(((pred((builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.out)) is semidet)), ((pred((builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.in), (builtin.out), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.search_first_2((builtin.in), ((pred((builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.out)) is semidet)), ((pred((builtin.in), (builtin.out)) is semidet) >> (pred((builtin.in), (builtin.out)) is semidet)), (builtin.in), (builtin.out), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.search_general(builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in)) is semidet)), (builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(rtree.search_general_2((builtin.in), builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.search_general_fold(((pred((builtin.in)) is semidet) >> (pred((builtin.in)) is semidet)), ((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.search_general_fold(((pred((builtin.in)) is semidet) >> (pred((builtin.in)) is semidet)), ((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.in), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(rtree.search_general_fold_2((builtin.in), ((pred((builtin.in)) is semidet) >> (pred((builtin.in)) is semidet)), ((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det) >> (pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.search_general_fold_2((builtin.in), ((pred((builtin.in)) is semidet) >> (pred((builtin.in)) is semidet)), ((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det) >> (pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(rtree.search_general_fold_subtree((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in), (builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.search_general_fold_subtree((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in), (builtin.in), (builtin.di), (builtin.uo)) is det)), (builtin.di), (builtin.uo)), infinite, can_loop).
:- pragma termination_info(rtree.search_general_subtree((builtin.in), (builtin.in), builtin.in((pred((builtin.in)) is semidet)), builtin.in((pred((builtin.in)) is semidet)), (builtin.in), (builtin.out)), infinite, can_loop).
:- pragma termination_info(rtree.search_intersects((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, yes, no, no]), can_loop).
:- pragma termination_info(rtree.size((builtin.in)) = (builtin.out), infinite, can_loop).

:- pragma exceptions(function, (rtree.bounding_region), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.bounding_region_size), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.box3d_bounding_region), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.box3d_bounding_region_volume), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.box3d_contains), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (rtree.box3d_intersects), 2, 0, will_not_throw).
:- pragma exceptions(function, (rtree.box3d_volume), 1, 0, will_not_throw).
:- pragma exceptions(function, (rtree.box_area), 1, 0, will_not_throw).
:- pragma exceptions(function, (rtree.box_bounding_region), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.box_bounding_region_area), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.box_contains), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (rtree.box_intersects), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (rtree.contains), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.delete), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.fold), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.fold), 4, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.fold), 4, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.fold_2), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.fold_2), 4, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.fold_2), 4, 2, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.fold_subtree), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.fold_subtree), 5, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.fold_subtree), 5, 2, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.init), 0, 0, will_not_throw).
:- pragma exceptions(function, (rtree.insert), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.insert), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.intersects), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.interval_bounding_region), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.interval_bounding_region_length), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.interval_contains), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (rtree.interval_intersects), 2, 0, will_not_throw).
:- pragma exceptions(function, (rtree.interval_length), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (rtree.is_empty), 1, 0, will_not_throw).
:- pragma exceptions(predicate, (rtree.map_values), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.map_values), 3, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.map_values_2), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.map_values_2), 3, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.map_values_key_2), 4, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.map_values_key_2), 4, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.maybe_limit), 4, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.search_contains), 2, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_first), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_first_2), 6, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.search_general), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_general_2), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_general_fold), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_general_fold), 5, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_general_fold_2), 5, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_general_fold_2), 5, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_general_fold_subtree), 6, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_general_fold_subtree), 6, 1, may_throw(user_exception)).
:- pragma exceptions(predicate, (rtree.search_general_subtree), 6, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.search_intersects), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (rtree.size), 1, 0, may_throw(user_exception)).
