:- module uint16.
:- use_module builtin.
:- use_module exception.
:- use_module int.
:- use_module math.
:- use_module pretty_printer.
:- use_module private_builtin.
:- use_module require.
:- use_module string.
:- use_module uint.

:- pragma foreign_import_module("C", array).
:- pragma foreign_import_module("C", bitmap).
:- pragma foreign_import_module("C", io).
:- pragma foreign_import_module("C", stm_builtin).
:- pragma foreign_import_module("C", store).
:- pragma foreign_import_module("C", string).
:- pragma foreign_import_module("C", time).
:- pragma foreign_import_module("C", uint16).
:- pragma foreign_import_module("C#", array).
:- pragma foreign_import_module("C#", bitmap).
:- pragma foreign_import_module("C#", io).
:- pragma foreign_import_module("C#", store).
:- pragma foreign_import_module("C#", uint16).
:- pragma foreign_import_module("Java", array).
:- pragma foreign_import_module("Java", bitmap).
:- pragma foreign_import_module("Java", io).
:- pragma foreign_import_module("Java", store).
:- pragma foreign_import_module("Java", uint16).
:- pragma foreign_import_module("Erlang", array).
:- pragma foreign_import_module("Erlang", bitmap).
:- pragma foreign_import_module("Erlang", io).
:- pragma foreign_import_module("Erlang", store).

:- pragma inline((uint16.(/))/2).
uint16.(V_4 / V_5) = V_3 :-
    V_3 = uint16.(V_4 // V_5).

:- pragma inline((uint16.(//))/2).
uint16.(V_4 // V_5) = V_6 :-
    ( if
      V_5 = 0u16 : uint16
    then
      V_7 = math.domain_error(V_8) : math.domain_error,
      V_8 = "uint16.\'//\': division by zero" : string,
      exception.throw(V_7)
    else
      V_6 = uint16.unchecked_quotient(V_4, V_5)
    ).

:- pragma foreign_proc("C", uint16.cast_from_int(I :: (builtin.in)) = (U16 :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U16 = (uint16_t) I;
").

:- pragma foreign_proc("C", uint16.cast_from_int16(I16 :: (builtin.in)) = (U16 :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U16 = (uint16_t) I16;
").

:- pragma foreign_proc("C", uint16.cast_from_uint64(U64 :: (builtin.in)) = (U16 :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U16 = (uint16_t) U64;
").

:- pragma foreign_proc("C", uint16.cast_to_int(U16 :: (builtin.in)) = (I :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    I = U16;
").

:- pragma foreign_proc("C", uint16.cast_to_uint(U16 :: (builtin.in)) = (U :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U = (MR_Unsigned) U16;
").

:- pragma foreign_proc("C", uint16.cast_to_uint64(U16 :: (builtin.in)) = (U64 :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    U64 = (uint64_t) U16;
").

uint16.(V_4 div V_5) = V_3 :-
    V_3 = uint16.(V_4 // V_5).

:- pragma inline((uint16.even)/1).
uint16.even(V_2) :-
    V_3 = uint16.(V_2 /\ V_4),
    V_4 = 1u16 : uint16,
    V_3 = 0u16 : uint16.

uint16.from_bytes_be(V_4, V_5) = V_3 :-
    V_3 = uint16.from_bytes_le(V_5, V_4).

:- pragma foreign_proc("C", uint16.from_bytes_le(LSB :: (builtin.in), MSB :: (builtin.in)) = (U16 :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    unsigned char *uint16_bytes = (unsigned char *) &U16;
#if defined(MR_BIG_ENDIAN)
    uint16_bytes[0] = MSB;
    uint16_bytes[1] = LSB;
#else
    uint16_bytes[0] = LSB;
    uint16_bytes[1] = MSB;
#endif
").

uint16.max(V_4, V_5) = V_3 :-
    ( if
      uint16.(V_4 > V_5)
    then
      V_3 = V_4
    else
      V_3 = V_5
    ).

uint16.max_uint16 = 65535u16.

uint16.min(V_4, V_5) = V_3 :-
    ( if
      uint16.(V_4 < V_5)
    then
      V_3 = V_4
    else
      V_3 = V_5
    ).

uint16.(V_4 mod V_5) = V_3 :-
    V_3 = uint16.(V_4 rem V_5).

:- pragma foreign_proc("C", uint16.num_leading_zeros(U :: (builtin.in)) = (N :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    if (U == 0) {
        N = 16;
    } else {
        int n = 1;
        if ((U >> 8) == 0) { n = n + 8;   U = U << 8; }
        if ((U >> 12) == 0) { n = n + 4;  U = U << 4; }
        if ((U >> 14) == 0) { n = n + 2;  U = U << 2; }
        if ((U >> 15) == 0) { n = n + 1;  U = U << 1; }
        N = n - (int) (U >> 15);
    }
").

:- pragma foreign_proc("C", uint16.num_ones(U :: (builtin.in)) = (N :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    U = (U & 0x5555) + ((U >> 1) & 0x5555);
    U = (U & 0x3333) + ((U >> 2) & 0x3333);
    U = (U & 0x0f0f) + ((U >> 4) & 0x0f0f);
    U = (U & 0x00ff) + ((U >> 8) & 0x00ff);
    N = U;
").

uint16.num_zeros(V_3) = V_2 :-
    V_2 = int.(V_4 - V_5),
    V_4 = 16 : int,
    V_5 = uint16.num_ones(V_3).

:- pragma inline((uint16.odd)/1).
uint16.odd(V_2) :-
    not (
      V_3 = uint16.(V_2 /\ V_4),
      V_4 = 1u16 : uint16,
      V_3 = 0u16 : uint16
    ).

:- pragma inline((uint16.(rem))/2).
uint16.(V_4 rem V_5) = V_6 :-
    ( if
      V_5 = 0u16 : uint16
    then
      V_7 = math.domain_error(V_8) : math.domain_error,
      V_8 = "uint16.rem: division by zero" : string,
      exception.throw(V_7)
    else
      V_6 = uint16.unchecked_rem(V_4, V_5)
    ).

:- pragma foreign_proc("C", uint16.reverse_bytes(A :: (builtin.in)) = (B :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail], "
    B = MR_uint16_reverse_bytes(A);
").

:- pragma foreign_proc("C", uint16.to_int(U16 :: (builtin.in)) = (I :: (builtin.out)), [will_not_call_mercury, thread_safe, not_tabled_for_io, promise_pure, will_not_modify_trail, doesnt_affect_liveness], "
    I = U16;
").

uint16.uint16_to_doc(V_3) = pretty_printer.str(V_4) :-
    V_4 = string.uint16_to_string(V_3).

:- pragma termination_info(uint16.'*'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'+'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'+'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'+'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'-'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'-'((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'-'((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint16.'//'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint16.'/\\'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.'<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'<<'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint16.'=<'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'>'((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'>='((builtin.in), (builtin.in)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'>>'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint16.'\\'((builtin.in)) = (builtin.uo), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.'\\/'((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.cast_from_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.cast_from_int16((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.cast_from_uint64((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.cast_to_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.cast_to_uint((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.cast_to_uint64((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.det_from_int((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(uint16.div((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint16.even((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint16.from_bytes_be((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.from_bytes_le((builtin.in), (builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.from_int((builtin.in), (builtin.out)), infinite, cannot_loop).
:- pragma termination_info(uint16.max((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info((uint16.max_uint16) = (builtin.out), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint16.min((builtin.in), (builtin.in)) = (builtin.out), finite(0, [yes, yes, no]), cannot_loop).
:- pragma termination_info(uint16.minus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.mod((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint16.num_leading_zeros((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.num_ones((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.num_trailing_zeros((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.num_zeros((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(uint16.odd((builtin.in)), finite(0, [no]), cannot_loop).
:- pragma termination_info(uint16.plus((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), can_loop).
:- pragma termination_info(uint16.reverse_bits((builtin.in)) = (builtin.out), finite(0, [no, no]), can_loop).
:- pragma termination_info(uint16.reverse_bytes((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.times((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.to_int((builtin.in)) = (builtin.out), infinite, cannot_loop).
:- pragma termination_info(uint16.uint16_to_doc((builtin.in)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(uint16.unchecked_left_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.unchecked_quotient((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.unchecked_rem((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.unchecked_right_shift((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.xor((builtin.in), (builtin.in)) = (builtin.uo), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.xor((builtin.in), (builtin.uo)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(uint16.xor((builtin.uo), (builtin.in)) = (builtin.in), finite(0, [no, no, no]), cannot_loop).

:- pragma exceptions(function, (uint16.(*)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(+)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(+)), 3, 1, will_not_throw).
:- pragma exceptions(function, (uint16.(+)), 3, 2, will_not_throw).
:- pragma exceptions(function, (uint16.(-)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(-)), 3, 1, will_not_throw).
:- pragma exceptions(function, (uint16.(-)), 3, 2, will_not_throw).
:- pragma exceptions(function, (uint16.(/)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.(//)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.(/\)), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.(<)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(<<)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint16.(=<)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.(>)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.(>=)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(>>)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.(\)), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(\/)), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.cast_from_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.cast_from_int16), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.cast_from_uint64), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.cast_to_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.cast_to_uint), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.cast_to_uint64), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.det_from_int), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.(div)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(predicate, (uint16.even), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint16.from_bytes_be), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.from_bytes_le), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.from_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.max), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.max_uint16), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint16.min), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.minus), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(mod)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.num_leading_zeros), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.num_ones), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.num_trailing_zeros), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.num_zeros), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (uint16.odd), 1, 0, will_not_throw).
:- pragma exceptions(function, (uint16.plus), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.(rem)), 3, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.reverse_bits), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.reverse_bytes), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.times), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.to_int), 2, 0, will_not_throw).
:- pragma exceptions(function, (uint16.uint16_to_doc), 2, 0, may_throw(user_exception)).
:- pragma exceptions(function, (uint16.unchecked_left_shift), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.unchecked_quotient), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.unchecked_rem), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.unchecked_right_shift), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.xor), 3, 0, will_not_throw).
:- pragma exceptions(function, (uint16.xor), 3, 1, will_not_throw).
:- pragma exceptions(function, (uint16.xor), 3, 2, will_not_throw).
