:- module bool.
:- use_module builtin, enum, list, private_builtin.
:- instance (enum.enum((bool.bool))).
bool.(X_4 or Y_5) = Result_6 :-
    bool.or(X_4, Y_5, Result_6).
bool.or((bool.yes), V_4, (bool.yes)).
bool.or((bool.no), Bool_5, Bool_5).
bool.or_list(List_3) = Result_4 :-
    bool.or_list(List_3, Result_4).
bool.(X_4 and Y_5) = Result_6 :-
    bool.and(X_4, Y_5, Result_6).
bool.and((bool.no), V_4, (bool.no)).
bool.and((bool.yes), Bool_5, Bool_5).
bool.and_list(List_3) = Result_4 :-
    bool.and_list(List_3, Result_4).
bool.(not X_3) = Result_4 :-
    bool.not(X_3, Result_4).
bool.not((bool.no), (bool.yes)).
bool.not((bool.yes), (bool.no)).
bool.pred_to_bool(P_3) = HeadVar__2_2 :-
    (if
      call(P_3)
    then
      HeadVar__2_2 = bool.yes : (bool.bool)
    else
      HeadVar__2_2 = bool.no : (bool.bool)
    ).
:- pragma exceptions(function, (bool.(or)), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (bool.(or)), 3, 0, will_not_throw).
:- pragma exceptions(function, (bool.or_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (bool.or_list), 2, 0, will_not_throw).
:- pragma exceptions(function, (bool.(and)), 3, 0, will_not_throw).
:- pragma exceptions(predicate, (bool.(and)), 3, 0, will_not_throw).
:- pragma exceptions(function, (bool.and_list), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (bool.and_list), 2, 0, will_not_throw).
:- pragma exceptions(function, (bool.(not)), 2, 0, will_not_throw).
:- pragma exceptions(predicate, (bool.(not)), 2, 0, will_not_throw).
:- pragma exceptions(function, (bool.xor), 3, 0, will_not_throw).
:- pragma exceptions(function, (bool.pred_to_bool), 2, 0, may_throw(user_exception)).
:- pragma termination_info(bool.or((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, yes, no]), cannot_loop).
:- pragma termination_info(bool.or((builtin.in), (builtin.in), (builtin.out)), finite(0, [no, yes, no]), cannot_loop).
:- pragma termination_info(bool.or_list((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(bool.or_list((builtin.in), (builtin.out)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(bool.and((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, yes, no]), cannot_loop).
:- pragma termination_info(bool.and((builtin.in), (builtin.in), (builtin.out)), finite(0, [no, yes, no]), cannot_loop).
:- pragma termination_info(bool.and_list((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(bool.and_list((builtin.in), (builtin.out)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(bool.not((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(bool.not((builtin.in), (builtin.out)), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(bool.xor((builtin.in), (builtin.in)) = (builtin.out), finite(0, [no, no, no]), cannot_loop).
:- pragma termination_info(bool.pred_to_bool(((pred) is semidet)) = (builtin.out), infinite, can_loop).
:- pragma termination_info(bool.'ClassMethod_for_enum__enum____bool__bool__arity0______enum__to_int_1'((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
:- pragma termination_info(bool.'ClassMethod_for_enum__enum____bool__bool__arity0______enum__from_int_1'((builtin.in)) = (builtin.out), finite(0, [no, no]), cannot_loop).
