:- module ((mdbcomp.feedback).automatic_parallelism).
:- interface.
:- use_module (mdbcomp.program_representation).
:- type alg_for_finding_best_par
    --->    affbp_complete_branches(int)
    ;       affbp_complete_size(int)
    ;       affbp_complete 
    ;       affbp_greedy .
:- type callee_rep
    --->    unknown_callee 
    ;       named_callee((((mdbcomp.feedback).automatic_parallelism).nc_module_name) :: string, (((mdbcomp.feedback).automatic_parallelism).nc_proc_name) :: string).
:- type candidate_par_conjunction(GoalType)
    --->    candidate_par_conjunction((((mdbcomp.feedback).automatic_parallelism).cpc_goal_path) :: mdbcomp.goal_path.goal_path_string, (((mdbcomp.feedback).automatic_parallelism).cpc_maybe_push_goal) :: maybe.maybe(mdbcomp.feedback.automatic_parallelism.push_goal), (((mdbcomp.feedback).automatic_parallelism).cpc_first_conj_num) :: int, (((mdbcomp.feedback).automatic_parallelism).cpc_is_dependent) :: mdbcomp.feedback.automatic_parallelism.conjuncts_are_dependent, (((mdbcomp.feedback).automatic_parallelism).cpc_goals_before) :: list.list(GoalType), (((mdbcomp.feedback).automatic_parallelism).cpc_goals_before_cost) :: float, (((mdbcomp.feedback).automatic_parallelism).cpc_conjs) :: list.list(mdbcomp.feedback.automatic_parallelism.seq_conj(GoalType)), (((mdbcomp.feedback).automatic_parallelism).cpc_goals_after) :: list.list(GoalType), (((mdbcomp.feedback).automatic_parallelism).cpc_goals_after_cost) :: float, (((mdbcomp.feedback).automatic_parallelism).cpc_par_exec_metrics) :: mdbcomp.feedback.automatic_parallelism.parallel_exec_metrics).
:- type candidate_par_conjunctions_params
    --->    candidate_par_conjunctions_params((((mdbcomp.feedback).automatic_parallelism).cpcp_desired_parallelism) :: float, (((mdbcomp.feedback).automatic_parallelism).cpcp_intermodule_var_use) :: bool.bool, (((mdbcomp.feedback).automatic_parallelism).cpcp_sparking_cost) :: int, (((mdbcomp.feedback).automatic_parallelism).cpcp_sparking_delay) :: int, (((mdbcomp.feedback).automatic_parallelism).cpcp_barrier_cost) :: int, (((mdbcomp.feedback).automatic_parallelism).cpcp_future_signal_cost) :: int, (((mdbcomp.feedback).automatic_parallelism).cpcp_future_wait_cost) :: int, (((mdbcomp.feedback).automatic_parallelism).cpcp_context_wakeup_delay) :: int, (((mdbcomp.feedback).automatic_parallelism).cpcp_clique_threshold) :: int, (((mdbcomp.feedback).automatic_parallelism).cpcp_call_site_threshold) :: int, (((mdbcomp.feedback).automatic_parallelism).cpcp_speedup_threshold) :: float, (((mdbcomp.feedback).automatic_parallelism).cpcp_parallelise_dep_conjs) :: mdbcomp.feedback.automatic_parallelism.parallelise_dep_conjs, (((mdbcomp.feedback).automatic_parallelism).cpcp_alg_for_best_par) :: mdbcomp.feedback.automatic_parallelism.alg_for_finding_best_par).
:- type candidate_par_conjunctions_proc == mdbcomp.feedback.automatic_parallelism.candidate_par_conjunctions_proc(mdbcomp.feedback.automatic_parallelism.pard_goal).
:- type candidate_par_conjunctions_proc(GoalType)
    --->    candidate_par_conjunctions_proc((((mdbcomp.feedback).automatic_parallelism).cpcp_var_table) :: mdbcomp.program_representation.var_name_table, (((mdbcomp.feedback).automatic_parallelism).cpcp_push_goals) :: list.list(mdbcomp.feedback.automatic_parallelism.push_goal), (((mdbcomp.feedback).automatic_parallelism).cpcp_par_conjs) :: list.list(mdbcomp.feedback.automatic_parallelism.candidate_par_conjunction(GoalType))).
:- type conjuncts_are_dependent
    --->    conjuncts_are_dependent(set.set(mdbcomp.program_representation.var_rep))
    ;       conjuncts_are_independent .
:- type cost_above_par_threshold
    --->    cost_above_par_threshold 
    ;       cost_not_above_par_threshold .
:- type parallel_exec_metrics
    --->    parallel_exec_metrics((((mdbcomp.feedback).automatic_parallelism).pem_num_calls) :: int, (((mdbcomp.feedback).automatic_parallelism).pem_seq_time) :: float, (((mdbcomp.feedback).automatic_parallelism).pem_par_time) :: float, (((mdbcomp.feedback).automatic_parallelism).pem_par_overhead_spark_cost) :: float, (((mdbcomp.feedback).automatic_parallelism).pem_par_overhead_barrier) :: float, (((mdbcomp.feedback).automatic_parallelism).pem_par_overhead_signals) :: float, (((mdbcomp.feedback).automatic_parallelism).pem_par_overhead_waits) :: float, (((mdbcomp.feedback).automatic_parallelism).pem_first_conj_dead_time) :: float, (((mdbcomp.feedback).automatic_parallelism).pem_future_dead_time) :: float).
:- type parallelise_dep_conjs
    --->    do_not_parallelise_dep_conjs 
    ;       parallelise_dep_conjs(mdbcomp.feedback.automatic_parallelism.speedup_estimate_alg).
:- type pard_goal == mdbcomp.program_representation.goal_rep(mdbcomp.feedback.automatic_parallelism.pard_goal_annotation).
:- type pard_goal_annotation
    --->    pard_goal_annotation((((mdbcomp.feedback).automatic_parallelism).pga_cost_percall) :: float, (((mdbcomp.feedback).automatic_parallelism).pga_coat_above_threshold) :: mdbcomp.feedback.automatic_parallelism.cost_above_par_threshold, (((mdbcomp.feedback).automatic_parallelism).pga_var_productions) :: assoc_list.assoc_list(mdbcomp.program_representation.var_rep, float), (((mdbcomp.feedback).automatic_parallelism).pga_var_consumptions) :: assoc_list.assoc_list(mdbcomp.program_representation.var_rep, float)).
:- type push_goal
    --->    push_goal((((mdbcomp.feedback).automatic_parallelism).pg_goal_path) :: mdbcomp.goal_path.goal_path_string, (((mdbcomp.feedback).automatic_parallelism).pg_pushee_lo) :: int, (((mdbcomp.feedback).automatic_parallelism).pg_pushee_hi) :: int, (((mdbcomp.feedback).automatic_parallelism).pg_pushed_into) :: list.list(mdbcomp.goal_path.goal_path_string)).
:- type seq_conj(GoalType)
    --->    seq_conj((((mdbcomp.feedback).automatic_parallelism).sc_conjs) :: list.list(GoalType)).
:- type speedup_estimate_alg
    --->    estimate_speedup_naively 
    ;       estimate_speedup_by_overlap .
:- type stat_measure
    --->    stat_mean 
    ;       stat_median .
:- type_representation(candidate_par_conjunctions_params, is_word_aligned_ptr).
:- type_representation(candidate_par_conjunctions_proc, is_eqv_to(mdbcomp.feedback.automatic_parallelism.candidate_par_conjunctions_proc(mdbcomp.feedback.automatic_parallelism.pard_goal))).
:- type_representation(cost_above_par_threshold, du_repn(enum("cost_above_par_threshold", "cost_not_above_par_threshold", [],  no_c_j_cs_e))).
:- type_representation(parallel_exec_metrics, is_word_aligned_ptr).
:- type_representation(pard_goal, is_eqv_to(mdbcomp.program_representation.goal_rep(mdbcomp.feedback.automatic_parallelism.pard_goal_annotation))).
:- type_representation(pard_goal_annotation, is_word_aligned_ptr).
:- type_representation(push_goal, is_word_aligned_ptr).
:- type_representation(seq_conj(V_1), du_repn(notag("seq_conj", list.list(V_1),  no_c_j_cs_e))).
:- type_representation(speedup_estimate_alg, du_repn(enum("estimate_speedup_naively", "estimate_speedup_by_overlap", [],  no_c_j_cs_e))).
:- type_representation(stat_measure, du_repn(enum("stat_mean", "stat_median", [],  no_c_j_cs_e))).
