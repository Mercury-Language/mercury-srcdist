:- module (mdb.declarative_debugger).
:- interface.
:- import_module io.
:- import_module list.
:- import_module maybe.
:- import_module unit.
:- import_module (mdb.browser_info).
:- import_module (mdb.declarative_analyser).
:- import_module (mdb.declarative_execution).
:- import_module (mdb.declarative_tree).
:- import_module (mdb.help).
:- import_module (mdb.io_action).
:- import_module (mdb.term_rep).
:- import_module (mdbcomp.program_representation).
:- type decl_bug
	--->	e_bug(((mdb.declarative_debugger).decl_e_bug))
	;	i_bug(((mdb.declarative_debugger).decl_i_bug)).
:- type decl_confirmation
	--->	confirm_bug 
	;	overrule_bug 
	;	abort_diagnosis .
:- type decl_contour == (list.list(((mdb.declarative_debugger).final_decl_atom))).
:- type decl_e_bug
	--->	incorrect_contour(((mdb.declarative_debugger).init_decl_atom), ((mdb.declarative_debugger).final_decl_atom), ((mdb.declarative_debugger).decl_contour), ((mdb.declarative_execution).event_number))
	;	partially_uncovered_atom(((mdb.declarative_debugger).init_decl_atom), ((mdb.declarative_execution).event_number))
	;	unhandled_exception(((mdb.declarative_debugger).init_decl_atom), ((mdb.declarative_debugger).decl_exception), ((mdb.declarative_execution).event_number)).
:- type decl_exception == ((mdb.term_rep).term_rep).
:- type decl_i_bug
	--->	inadmissible_call(((mdb.declarative_debugger).init_decl_atom), ((mdb.declarative_debugger).decl_position), ((mdb.declarative_debugger).init_decl_atom), ((mdb.declarative_execution).event_number)).
:- type decl_position == (unit.unit).
:- type decl_truth
	--->	truth_correct 
	;	truth_erroneous 
	;	truth_inadmissible .
:- type diagnoser_exception
	--->	internal_error(string, string)
	;	io_error(string, string)
	;	unimplemented_feature(string).
:- type final_decl_atom
	--->	final_decl_atom(((mdb.declarative_debugger).final_atom) :: ((mdb.declarative_execution).trace_atom), ((mdb.declarative_debugger).final_io_actions) :: (maybe.maybe(((mdb.io_action).io_action_range)))).
:- type init_decl_atom
	--->	init_decl_atom(((mdb.declarative_debugger).init_atom) :: ((mdb.declarative_execution).trace_atom)).
:- type some_decl_atom
	--->	init(((mdb.declarative_debugger).init_decl_atom))
	;	final(((mdb.declarative_debugger).final_decl_atom)).
:- type diagnoser_response(R)
	--->	bug_found(((mdb.declarative_execution).event_number))
	;	symptom_found(((mdb.declarative_execution).event_number))
	;	no_bug_found 
	;	require_subtree(((mdb.declarative_debugger).require_subtree_final_event) :: ((mdb.declarative_execution).event_number), ((mdb.declarative_debugger).require_subtree_seqno) :: ((mdb.declarative_execution).sequence_number), ((mdb.declarative_debugger).require_subtree_call_preceding_node) :: R, ((mdb.declarative_debugger).require_subtree_max_depth) :: int)
	;	require_supertree(((mdb.declarative_execution).event_number), ((mdb.declarative_execution).sequence_number)).
:- type diagnoser_state(R).
:- type decl_answer(T)
	--->	truth_value(T, ((mdb.declarative_debugger).decl_truth))
	;	suspicious_subterm(T, ((mdbcomp.program_representation).arg_pos), ((mdbcomp.program_representation).term_path), ((mdb.browser_info).how_track_subterm), ((mdb.browser_info).should_assert_invalid))
	;	ignore(T)
	;	skip(T).
:- type decl_evidence(T) == (list.list(((mdb.declarative_debugger).decl_question(T)))).
:- type decl_question(T)
	--->	wrong_answer(T, ((mdb.declarative_debugger).init_decl_atom), ((mdb.declarative_debugger).final_decl_atom))
	;	missing_answer(T, ((mdb.declarative_debugger).init_decl_atom), (list.list(((mdb.declarative_debugger).final_decl_atom))))
	;	unexpected_exception(T, ((mdb.declarative_debugger).init_decl_atom), ((mdb.declarative_debugger).decl_exception)).
:- inst (known_answer) == bound(ignore(ground) ; truth_value(ground, ground)).
