%-----------------------------------------------------------------------------%
% vim: ft=mercury ts=4 sw=4 et
%-----------------------------------------------------------------------------%
% Copyright (C) 2006-2008 The University of Melbourne.
% This file may only be copied under the terms of the GNU General
% Public License - see the file COPYING in the Mercury distribution.
%-----------------------------------------------------------------------------%
%
% File: mdprof_feedback.m.
% Author: tannier, pbone.
%
% This module contains the code for writing to a file the CSSs whose CSDs' 
% mean/median call sequence counts (own and desc) exceed the given threshold.
% 
% The generated file will then be used by the compiler for implicit parallelism.
%
%-----------------------------------------------------------------------------%

:- module mdprof_feedback.
:- interface.

:- import_module io.

%-----------------------------------------------------------------------------%

:- pred main(io::di, io::uo) is det.

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

:- implementation.

:- import_module conf.
:- import_module mdbcomp.
:- import_module mdbcomp.feedback.
:- import_module mdbcomp.program_representation.
:- import_module measurements.
:- import_module profile.
:- import_module startup.

:- import_module array.
:- import_module bool.
:- import_module char.
:- import_module getopt.
:- import_module int.
:- import_module library.
:- import_module list.
:- import_module map.
:- import_module maybe.
:- import_module string.
:- import_module svmap.

%-----------------------------------------------------------------------------%
%
% This section contains the main predicate as well as code to read the deep
% profiling data and display usage and version messages to the user.
%

main(!IO) :-
    io.progname_base("mdprof_feedback", ProgName, !IO),
    io.command_line_arguments(Args0, !IO),
    getopt.process_options(option_ops_multi(short, long, defaults),
        Args0, Args, MaybeOptions),
    (
        MaybeOptions = ok(Options),
        lookup_bool_option(Options, help, Help),
        lookup_bool_option(Options, version, Version),
        lookup_string_option(Options, program_name, ProfileProgName0),
        ProfileProgName = string.strip(ProfileProgName0),
        ( 
            Version = yes
        ->
            write_version_message(ProgName, !IO)
        ; 
            Help = yes
        ->
            write_help_message(ProgName, !IO)
        ; 
            ProfileProgName \= "",
            Args = [Input, Output],
            check_options(Options, RequestedFeedbackInfo)
        ->
            lookup_bool_option(Options, verbose, Verbose),
            read_deep_file(Input, Verbose, MaybeDeep, !IO),
            (
                MaybeDeep = ok(Deep),
                feedback.read_or_create(Output, Feedback0, !IO),
                process_deep_to_feedback(RequestedFeedbackInfo, 
                    Deep, Feedback0, Feedback),
                write_feedback_file(Output, ProfileProgName, Feedback,
                    WriteResult, !IO),
                (
                    WriteResult = ok
                ;
                    ( WriteResult = open_error(Error)
                    ; WriteResult = write_error(Error) ),
                    io.error_message(Error, ErrorMessage),
                    io.format("%s: %s\n", [s(Output), s(ErrorMessage)], !IO),
                    io.set_exit_status(1, !IO)
                )
            ;
                MaybeDeep = error(Error),
                io.stderr_stream(Stderr, !IO),
                io.set_exit_status(1, !IO),
                io.format(Stderr, "%s: error reading deep file: %s\n",
                    [s(ProgName), s(Error)], !IO)
            )   
        ;
            io.set_exit_status(1, !IO),
            write_help_message(ProgName, !IO)
        )
    ;
        MaybeOptions = error(Msg),
        io.stderr_stream(Stderr, !IO),
        io.set_exit_status(1, !IO),
        io.format(Stderr, "%s: error parsing options: %s\n",
            [s(ProgName), s(Msg)], !IO),
        write_help_message(ProgName, !IO)
    ).

:- pred write_help_message(string::in, io::di, io::uo) is det.

write_help_message(ProgName, !IO) :- 
    Message0 = [
        "Usage: %s --program-name <ProgName> [<options>] <input> <output>",
        "   <input> must name a deep profiling data file.",
        "   <output> is the file generated by this program.",
        "   You may specify the following options:",
        "   --help      Generate this help message.",
        "   --version   Report the program's version number.",
        "   --verbose   Generate progress messages.",
        "   --program-name <name>",
        "               The name of the program that generated the",
        "               profiling data.  This is stored in the",
        "               feedback file",
        "\nThe following options select sets of feedback information useful",
        "for particular compiler optimizations",
        "   --implicit-parallelism",
        "\nThe following options select specific types of feedback",
        "information and parameterise them",
        "   --calls-above-threshold-sorted",
        "               A list of calls whose typical cost (in call sequence",
        "               counts is above a given threshold, the definition of",
        "               'typical' may be specified.",
        "   --calls-above-threshold-sorted-threshold <value>",
        "               Set the threshold to <value>.",
        "   --calls-above-threshold-sorted-measure mean|median",
        "               mean : Use mean(call site dynamic cost), this is the",
        "                      default.",
        "               median : Use median(call site dynamic cost)."],
    string.join_list("\n", Message0) ++ "\n" = Message,
    io.format(Message, [s(ProgName)], !IO).

:- pred write_version_message(string::in, io::di, io::uo) is det.

write_version_message(ProgName, !IO) :-
    library.version(Version),
    io.write_string(ProgName, !IO),
    io.write_string(": Mercury deep profiler", !IO),
    io.nl(!IO),
    io.write_string(Version, !IO),
    io.nl(!IO).

    % Read a deep profiling data file.
    % 
:- pred read_deep_file(string::in, bool::in,
    maybe_error(deep)::out, io::di, io::uo) is det.

read_deep_file(Input, Verbose, MaybeProfile, !IO) :-
    server_name_port(Machine, !IO),
    script_name(ScriptName, !IO),
    (
        Verbose = yes,
        io.stdout_stream(Stdout, !IO),
        MaybeOutput = yes(Stdout)
    ;
        Verbose = no,
        MaybeOutput = no
    ),
    read_and_startup(Machine, ScriptName, [Input], no, MaybeOutput,
        [], MaybeProfile, !IO).

%----------------------------------------------------------------------------%
%
% This section describes and processes command line options.  Individual
% feedback information can be requested by the user, as well as options named
% after optimizations that may imply one or more feedback inforemation types,
% which that optimization uses.
%

    % Command line options.
    %
:- type option
    --->    help
    ;       program_name
    ;       verbose
    ;       version
            
            % The calls above threshold sorted feedback information
    ;       calls_above_threshold_sorted
    ;       calls_above_threshold_sorted_measure
    ;       calls_above_threshold_sorted_threshold
    
            % Provide suitable feedback information for implicit parallelism
    ;       implicit_parallelism.

:- pred short(char::in, option::out) is semidet.

short('h',  help).
short('p',  program_name).
short('V',  verbose).
short('v',  version).

:- pred long(string::in, option::out) is semidet.

long("help",                help).
long("verbose",             verbose).
long("version",             version).
long("program-name",        program_name).

long("calls-above-threshold-sorted", calls_above_threshold_sorted).
long("calls-above-threshold-sorted-measure",
    calls_above_threshold_sorted_measure).
long("calls-above-threshold-sorted-threshold",
    calls_above_threshold_sorted_threshold).

long("implicit-parallelism",    implicit_parallelism).

:- pred defaults(option::out, option_data::out) is multi.

defaults(help,              bool(no)).
defaults(program_name,      string("")).
defaults(verbose,           bool(no)).
defaults(version,           bool(no)).

defaults(calls_above_threshold_sorted,              bool(no)).
defaults(calls_above_threshold_sorted_measure,      string("mean")).
defaults(calls_above_threshold_sorted_threshold,    int(100000)).

defaults(implicit_parallelism,  bool(no)).

:- pred construct_measure(string::in, stat_measure::out) is semidet.

construct_measure("mean",       stat_mean).
construct_measure("median",     stat_median).

    % This type defines the set of feedback_types that are to be calculated and
    % put into the feedback info file,  They should correspond with the values
    % of feedback_type.
    %
:- type requested_feedback_info 
    --->    requested_feedback_info(
                maybe_calls_above_threshold_sorted
                    :: maybe(calls_above_threshold_sorted_opts) 
            ).

:- type calls_above_threshold_sorted_opts
    --->    calls_above_threshold_sorted_opts(
                measure         :: stat_measure,
                threshold       :: int
            ).


    % Check all the command line options and return a well-typed representation
    % of the user's request.  Some command line options imply other options,
    % those implications are also handled here.
    %
:- pred check_options(option_table(option)::in, requested_feedback_info::out)
    is semidet.

check_options(Options0, RequestedFeedbackInfo) :-
    % Handle options that imply other options here.
    option_implies(implicit_parallelism, calls_above_threshold_sorted, yes,
        Options0, Options), 

    % For each feedback type determine if it is requested and fill in the the
    % field in the RequestedFeedbackInfo structure.
    lookup_bool_option(Options, calls_above_threshold_sorted,
        CallsAboveThresholdSorted),
    (
        CallsAboveThresholdSorted = yes,
        lookup_string_option(Options, calls_above_threshold_sorted_measure,
            Measure),
        % TODO: this goal is semidet, but this predicate should be det.
        construct_measure(Measure, MeasureType),
        CallsAboveThresholdSortedOpts ^ measure = MeasureType,
        lookup_int_option(Options, calls_above_threshold_sorted_threshold,
            Threshold),
        CallsAboveThresholdSortedOpts ^ threshold = Threshold,
        MaybeCallsAboveThresholdSortedOpts =
            yes(CallsAboveThresholdSortedOpts)
    ;
        CallsAboveThresholdSorted = no,
        MaybeCallsAboveThresholdSortedOpts = no
    ),
    RequestedFeedbackInfo ^ maybe_calls_above_threshold_sorted =
        MaybeCallsAboveThresholdSortedOpts.

    % Adjust command line options when one option implies other options.
    %
:- pred option_implies(option::in, option::in, bool::in,
    option_table(option)::in, option_table(option)::out) is det.

option_implies(Option, ImpliedOption, ImpliedValue, !Options) :-
    (
        lookup_bool_option(!.Options, Option, yes)
    ->
        svmap.set(ImpliedOption, bool(ImpliedValue), !Options)
    ;
        true
    ).

%----------------------------------------------------------------------------%

    % process_deep_to_feedback(RequestedFeedbackInfo, Deep, !Feedback)
    %
    % Process a deep profiling structure and update the feedback information
    % according to the RequestedFeedbackInfo parameter.
    %
:- pred process_deep_to_feedback(requested_feedback_info::in, deep::in,
    feedback_info::in, feedback_info::out) is det.

process_deep_to_feedback(RequestedFeedbackInfo, Deep, !Feedback) :-
    MaybeCallsAboveThresholdSorted = 
        RequestedFeedbackInfo ^ maybe_calls_above_threshold_sorted,
    (
        MaybeCallsAboveThresholdSorted = yes(Opts),
        css_list_above_threshold(Opts, Deep, !Feedback)
    ;
        MaybeCallsAboveThresholdSorted = no
    ).

%----------------------------------------------------------------------------%
%
% Jerome's implicit parallelism feedback information.
%

    % Perform Jerome's analysis and update the feedback info structure.
    %
:- pred css_list_above_threshold(calls_above_threshold_sorted_opts::in,
    deep::in, feedback_info::in, feedback_info::out) is det. 

css_list_above_threshold(Options, Deep, !Feedback) :-
    Options = calls_above_threshold_sorted_opts(MeasureType, Threshold),
    compute_css_list_above_threshold(0, Deep, Threshold, 
        MeasureType, [], CSSList),
    map(css_to_call(Deep), CSSList, Calls), 
    FeedbackData = feedback_data_calls_above_threshold_sorted(Threshold,
        MeasureType, Calls),
    FeedbackType = feedback_type_calls_above_threshold_sorted, 
    put_feedback_data(FeedbackType, FeedbackData, !Feedback).

    % Determine those CSSs whose CSDs' average/median call sequence counts 
    % exceed the given threshold.
    % 
:- pred compute_css_list_above_threshold(int::in, deep::in, int::in, 
    stat_measure::in, list(call_site_static)::in, 
    list(call_site_static)::out) is det.

compute_css_list_above_threshold(Index, Deep, Threshold, Measure,
        !CSSAcc) :-
    array.size(Deep ^ call_site_statics, Size),
    ( Index = Size ->
        true
    ;
        CallSiteCall = array.lookup(Deep ^ call_site_calls, Index),
        CSDListList = map.values(CallSiteCall),
        CSDList = list.condense(CSDListList),
        list.length(CSDList, NumCSD),
        ( NumCSD = 0 ->
            % The CSS doesn't have any CSDs.
            Callseqs = 0
        ;
            ( 
                Measure = stat_mean,
                list.foldr(sum_callseqs_csd_ptr(Deep), CSDList,
                    0, SumCallseqs),
                % NOTE: we have checked that NumCSD is not zero above.
                Callseqs = SumCallseqs // NumCSD
            ;
                Measure = stat_median,
                list.sort(compare_csd_ptr(Deep), CSDList, CSDListSorted),
                IndexMedian = NumCSD // 2,
                list.index0_det(CSDListSorted, IndexMedian, MedianPtr),
                sum_callseqs_csd_ptr(Deep, MedianPtr, 0, Callseqs)
            )
        ),
        ( Callseqs >= Threshold ->
            CSS = array.lookup(Deep ^ call_site_statics, Index),
            list.append(!.CSSAcc, [CSS], !:CSSAcc),
            compute_css_list_above_threshold(Index + 1, Deep, Threshold, 
                Measure, !CSSAcc)
        ;
            compute_css_list_above_threshold(Index + 1, Deep, Threshold, 
                Measure, !CSSAcc)
        ) 
    ).

    % Add the call sequence counts (own and desc) of CSDPtr to the accumulator.
    % 
:- pred sum_callseqs_csd_ptr(deep::in, call_site_dynamic_ptr::in,
    int::in, int::out) is det.

sum_callseqs_csd_ptr(Deep, CSDPtr, !Sum) :-
    lookup_call_site_dynamics(Deep ^ call_site_dynamics, CSDPtr, CSD),
    lookup_csd_desc(Deep ^ csd_desc, CSDPtr, IPO),
    !:Sum = !.Sum + callseqs(CSD ^ csd_own_prof) + inherit_callseqs(IPO).

    % Compare two CSD pointers on the basis of their call sequence counts 
    % (own and desc).
    % 
:- pred compare_csd_ptr(deep::in, call_site_dynamic_ptr::in, 
    call_site_dynamic_ptr::in, comparison_result::out) is det.

compare_csd_ptr(Deep, CSDPtrA, CSDPtrB, Result) :-
    sum_callseqs_csd_ptr(Deep, CSDPtrA, 0, SumA),
    sum_callseqs_csd_ptr(Deep, CSDPtrB, 0, SumB),
    compare(Result, SumA, SumB).

    % Write to the output the list of CSSs.     
    % 
:- pred css_to_call(deep::in, call_site_static::in, call_site::out) is det.
   
css_to_call(Deep, CSS, Call) :-
    % Get the caller.
    lookup_proc_statics(Deep ^ proc_statics, CSS ^ css_container, CallerPS),
    Caller = CallerPS ^ ps_id,    

    % Get the slot number.
    Slot = CSS ^ css_slot_num,
    
    % Get the Callee and Call Type.
    (
        CSS ^ css_kind = normal_call_and_callee(PSPtr, _),
        lookup_proc_statics(Deep ^ proc_statics, PSPtr, CalleePS),
        CallTypeAndCallee = plain_call(CalleePS ^ ps_id)
    ;
        CSS ^ css_kind = special_call_and_no_callee,
        CallTypeAndCallee = special_call
    ;
        CSS ^ css_kind = higher_order_call_and_no_callee,
        CallTypeAndCallee = higher_order_call
    ;
        CSS ^ css_kind = method_call_and_no_callee,
        CallTypeAndCallee = method_call
    ;
        CSS ^ css_kind = callback_and_no_callee,
        CallTypeAndCallee = callback_call
    ),
   
    % Build the call datastructure.
    Call = call_site(Caller, Slot, CallTypeAndCallee).

%-----------------------------------------------------------------------------%
:- end_module mdprof_feedback.
%-----------------------------------------------------------------------------%
