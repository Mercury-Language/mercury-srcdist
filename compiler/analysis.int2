:- module analysis.
:- interface.
:- type analysis_info.
:- type analysis_name == string.
:- type analysis_result(Call, Answer)
    --->    analysis_result((analysis.ar_call) :: Call, (analysis.ar_answer) :: Answer, (analysis.ar_status) :: analysis.analysis_status).
:- type analysis_status
    --->    invalid 
    ;       suboptimal 
    ;       optimal .
:- type analysis_type
    --->    some [FuncInfo, Call, Answer] (analysis_type(unit.unit(Call), unit.unit(Answer)) => (analysis.analysis(FuncInfo, Call, Answer))).
:- type any_call
    --->    any_call .
:- type fixpoint_type
    --->    least_fixpoint 
    ;       greatest_fixpoint .
:- type func_id
    --->    func_id((analysis.fid_pf) :: mdbcomp.prim_data.pred_or_func, (analysis.fid_name) :: string, (analysis.fid_arity) :: int, (analysis.fid_mode) :: hlds.hlds_pred.proc_id).
:- type no_func_info
    --->    no_func_info .
:- typeclass analysis(FuncInfo, Call, Answer) <= (analysis.call_pattern(FuncInfo, Call), analysis.answer_pattern(FuncInfo, Answer)).
:- typeclass answer_pattern(FuncInfo, Answer) <= (analysis.partial_order(FuncInfo, Answer), analysis.to_term(Answer)).
:- typeclass call_pattern(FuncInfo, Call) <= (analysis.partial_order(FuncInfo, Call), analysis.to_term(Call)).
:- typeclass compiler(Compiler).
:- typeclass partial_order(FuncInfo, T) <= ((T -> FuncInfo)).
:- typeclass to_term(S).
:- instance (analysis.call_pattern(analysis.no_func_info, analysis.any_call)).
:- instance (analysis.partial_order(analysis.no_func_info, analysis.any_call)).
:- instance (analysis.to_term(analysis.any_call)).
:- type_representation(analysis_info, is_word_aligned_ptr).
:- type_representation(analysis_map(V_1), is_eqv_to(map.map(mdbcomp.sym_name.module_name, analysis.module_analysis_map(V_1)))).
:- type_representation(analysis_name, is_eqv_to(string)).
:- type_representation(analysis_status, du_repn(enum("invalid", "suboptimal", ["optimal"],  no_c_j_cs))).
:- type_representation(analysis_type, is_word_aligned_ptr).
:- type_representation(any_call, du_repn(direct_dummy("any_call",  no_c_j_cs))).
:- type_representation(fixpoint_type, du_repn(enum("least_fixpoint", "greatest_fixpoint", [],  no_c_j_cs))).
:- type_representation(func_analysis_map(V_1), is_eqv_to(map.map(analysis.func_id, list.list(V_1)))).
:- type_representation(func_id, is_word_aligned_ptr).
:- type_representation(module_analysis_map(V_1), is_eqv_to(map.map(analysis.analysis_name, analysis.func_analysis_map(V_1)))).
:- type_representation(no_func_info, du_repn(direct_dummy("no_func_info",  no_c_j_cs))).
