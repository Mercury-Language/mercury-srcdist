:- module (libs.lp_rational).
:- interface.
:- use_module io.
:- use_module list.
:- use_module map.
:- use_module maybe.
:- use_module pair.
:- use_module set.
:- use_module term.
:- use_module varset.
:- use_module (libs.rat).
:- type constraint.
:- type constraints == list.list(libs.lp_rational.constraint).
:- type direction
    --->    max 
    ;       min .
:- type entailment_result
    --->    entailed 
    ;       not_entailed 
    ;       inconsistent .
:- type lp_coefficient == libs.rat.rat.
:- type lp_constant == libs.rat.rat.
:- type lp_operator
    --->    lp_lt_eq 
    ;       lp_eq 
    ;       lp_gt_eq .
:- type lp_result
    --->    lp_res_unbounded 
    ;       lp_res_inconsistent 
    ;       lp_res_satisfiable(libs.rat.rat, map.map(libs.lp_rational.lp_var, libs.rat.rat)).
:- type lp_term == pair.pair(libs.lp_rational.lp_var, libs.lp_rational.lp_coefficient).
:- type lp_terms == list.list(libs.lp_rational.lp_term).
:- type lp_var == term.var.
:- type lp_vars == list.list(libs.lp_rational.lp_var).
:- type lp_varset == varset.varset.
:- type objective == libs.lp_rational.lp_terms.
:- type output_var == ((func libs.lp_rational.lp_var) = string).
:- type projection_result
    --->    pr_res_ok(libs.lp_rational.constraints)
    ;       pr_res_inconsistent 
    ;       pr_res_aborted .
:- inst (lp_op_lt_eq_or_eq) for (libs.lp_rational).lp_operator/0 == bound(lp_eq ; lp_lt_eq).
:- type_representation(cc_map, is_eqv_to(map.map(libs.lp_rational.lp_var, libs.lp_rational.coeff_info))).
:- type_representation(constraints, is_eqv_to(list.list(libs.lp_rational.constraint))).
:- type_representation(direction, du_repn(enum("max", "min", [], []))).
:- type_representation(entailment_result, du_repn(enum("entailed", "not_entailed", ["inconsistent"], []))).
:- type_representation(lp_coefficient, is_eqv_to(libs.rat.rat)).
:- type_representation(lp_constant, is_eqv_to(libs.rat.rat)).
:- type_representation(lp_operator, du_repn(enum("lp_lt_eq", "lp_eq", ["lp_gt_eq"], []))).
:- type_representation(lp_term, is_eqv_to(pair.pair(libs.lp_rational.lp_var, libs.lp_rational.lp_coefficient))).
:- type_representation(lp_terms, is_eqv_to(list.list(libs.lp_rational.lp_term))).
:- type_representation(lp_var, is_eqv_to(term.var)).
:- type_representation(lp_vars, is_eqv_to(list.list(libs.lp_rational.lp_var))).
:- type_representation(lp_varset, is_eqv_to(varset.varset)).
:- type_representation(matrix, is_eqv_to(list.list(libs.lp_rational.vector))).
:- type_representation(objective, is_eqv_to(libs.lp_rational.lp_terms)).
:- type_representation(output_var, is_eqv_to(((func libs.lp_rational.lp_var) = string))).
:- type_representation(var_num_map, is_eqv_to(map.map(libs.lp_rational.lp_var, int))).
