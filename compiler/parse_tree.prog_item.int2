:- module (parse_tree.prog_item).
:- interface.
:- import_module assoc_list.
:- import_module bool.
:- import_module list.
:- import_module maybe.
:- import_module pair.
:- import_module recompilation.
:- import_module set.
:- import_module term.
:- import_module (libs.globals).
:- import_module (libs.options).
:- import_module (mdbcomp.prim_data).
:- import_module (parse_tree.prog_data).
:- type class_method
	--->	method_pred_or_func(((parse_tree.prog_data).tvarset), ((parse_tree.prog_data).inst_varset), ((parse_tree.prog_data).existq_tvars), ((mdbcomp.prim_data).pred_or_func), ((mdbcomp.prim_data).sym_name), (list.list(((parse_tree.prog_data).type_and_mode))), (maybe.maybe(((parse_tree.prog_data).mer_type))), (maybe.maybe(((parse_tree.prog_data).mer_inst))), (maybe.maybe(((parse_tree.prog_data).determinism))), ((parse_tree.prog_data).condition), ((parse_tree.prog_data).purity), ((parse_tree.prog_data).prog_constraints), ((parse_tree.prog_data).prog_context))
	;	method_pred_or_func_mode(((parse_tree.prog_data).inst_varset), (maybe.maybe(((mdbcomp.prim_data).pred_or_func))), ((mdbcomp.prim_data).sym_name), (list.list(((parse_tree.prog_data).mer_mode))), (maybe.maybe(((parse_tree.prog_data).mer_inst))), (maybe.maybe(((parse_tree.prog_data).determinism))), ((parse_tree.prog_data).condition), ((parse_tree.prog_data).prog_context)).
:- type class_methods == (list.list(((parse_tree.prog_item).class_method))).
:- type compilation_unit
	--->	unit_module(((mdbcomp.prim_data).module_name), ((parse_tree.prog_item).item_list)).
:- type foreign_name
	--->	foreign_name(((parse_tree.prog_item).foreign_name_lang) :: ((libs.globals).foreign_language), ((parse_tree.prog_item).foreign_name_name) :: string).
:- type goal == (pair.pair(((parse_tree.prog_item).goal_expr), ((parse_tree.prog_data).prog_context))).
:- type goal_expr
	--->	conj_expr(((parse_tree.prog_item).goal), ((parse_tree.prog_item).goal))
	;	true_expr 
	;	par_conj_expr(((parse_tree.prog_item).goal), ((parse_tree.prog_item).goal))
	;	disj_expr(((parse_tree.prog_item).goal), ((parse_tree.prog_item).goal))
	;	fail_expr 
	;	some_expr(((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).goal))
	;	all_expr(((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).goal))
	;	some_state_vars_expr(((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).goal))
	;	all_state_vars_expr(((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).goal))
	;	promise_purity_expr(((parse_tree.prog_data).implicit_purity_promise), ((parse_tree.prog_data).purity), ((parse_tree.prog_item).goal))
	;	promise_equivalent_solutions_expr(((parse_tree.prog_data).prog_vars), ((parse_tree.prog_data).prog_vars), ((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).goal))
	;	promise_equivalent_solution_sets_expr(((parse_tree.prog_data).prog_vars), ((parse_tree.prog_data).prog_vars), ((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).goal))
	;	promise_equivalent_solution_arbitrary_expr(((parse_tree.prog_data).prog_vars), ((parse_tree.prog_data).prog_vars), ((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).goal))
	;	trace_expr(((parse_tree.prog_item).texpr_compiletime) :: (maybe.maybe(((parse_tree.prog_data).trace_expr(((parse_tree.prog_data).trace_compiletime))))), ((parse_tree.prog_item).texpr_runtime) :: (maybe.maybe(((parse_tree.prog_data).trace_expr(((parse_tree.prog_data).trace_runtime))))), ((parse_tree.prog_item).texpr_maybe_io) :: (maybe.maybe(((parse_tree.prog_data).prog_var))), ((parse_tree.prog_item).texpr_mutable_vars) :: (list.list(((parse_tree.prog_data).trace_mutable_var))), ((parse_tree.prog_item).texpr_goal) :: ((parse_tree.prog_item).goal))
	;	implies_expr(((parse_tree.prog_item).goal), ((parse_tree.prog_item).goal))
	;	equivalent_expr(((parse_tree.prog_item).goal), ((parse_tree.prog_item).goal))
	;	not_expr(((parse_tree.prog_item).goal))
	;	if_then_else_expr(((parse_tree.prog_data).prog_vars), ((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).goal), ((parse_tree.prog_item).goal), ((parse_tree.prog_item).goal))
	;	event_expr(string, (list.list(((parse_tree.prog_data).prog_term))))
	;	call_expr(((mdbcomp.prim_data).sym_name), (list.list(((parse_tree.prog_data).prog_term))), ((parse_tree.prog_data).purity))
	;	unify_expr(((parse_tree.prog_data).prog_term), ((parse_tree.prog_data).prog_term), ((parse_tree.prog_data).purity)).
:- type goals == (list.list(((parse_tree.prog_item).goal))).
:- type item
	--->	item_clause(((parse_tree.prog_item).cl_origin) :: ((parse_tree.prog_item).item_origin), ((parse_tree.prog_item).cl_varset) :: ((parse_tree.prog_data).prog_varset), ((parse_tree.prog_item).cl_pred_or_func) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).cl_predname) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).cl_head_args) :: (list.list(((parse_tree.prog_data).prog_term))), ((parse_tree.prog_item).cl_body) :: ((parse_tree.prog_item).goal))
	;	item_type_defn(((parse_tree.prog_item).td_tvarset) :: ((parse_tree.prog_data).tvarset), ((parse_tree.prog_item).td_ctor_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).td_ctor_args) :: (list.list(((parse_tree.prog_data).type_param))), ((parse_tree.prog_item).td_ctor_defn) :: ((parse_tree.prog_data).type_defn), ((parse_tree.prog_item).td_cond) :: ((parse_tree.prog_data).condition))
	;	item_inst_defn(((parse_tree.prog_item).id_varset) :: ((parse_tree.prog_data).inst_varset), ((parse_tree.prog_item).id_inst_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).id_inst_args) :: (list.list(((parse_tree.prog_data).inst_var))), ((parse_tree.prog_item).id_inst_defn) :: ((parse_tree.prog_data).inst_defn), ((parse_tree.prog_item).id_cond) :: ((parse_tree.prog_data).condition))
	;	item_mode_defn(((parse_tree.prog_item).md_varset) :: ((parse_tree.prog_data).inst_varset), ((parse_tree.prog_item).md_mode_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).md_mode_args) :: (list.list(((parse_tree.prog_data).inst_var))), ((parse_tree.prog_item).md_mode_defn) :: ((parse_tree.prog_data).mode_defn), ((parse_tree.prog_item).md_cond) :: ((parse_tree.prog_data).condition))
	;	item_module_defn(((parse_tree.prog_item).module_defn_varset) :: ((parse_tree.prog_data).prog_varset), ((parse_tree.prog_item).module_defn_module_defn) :: ((parse_tree.prog_item).module_defn))
	;	item_pred_or_func(((parse_tree.prog_item).pf_origin) :: ((parse_tree.prog_item).item_origin), ((parse_tree.prog_item).pf_tvarset) :: ((parse_tree.prog_data).tvarset), ((parse_tree.prog_item).pf_instvarset) :: ((parse_tree.prog_data).inst_varset), ((parse_tree.prog_item).pf_existqvars) :: ((parse_tree.prog_data).existq_tvars), ((parse_tree.prog_item).pf_which) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).pf_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).pf_arg_decls) :: (list.list(((parse_tree.prog_data).type_and_mode))), ((parse_tree.prog_item).pf_maybe_with_type) :: (maybe.maybe(((parse_tree.prog_data).mer_type))), ((parse_tree.prog_item).pf_maybe_with_inst) :: (maybe.maybe(((parse_tree.prog_data).mer_inst))), ((parse_tree.prog_item).pf_maybe_detism) :: (maybe.maybe(((parse_tree.prog_data).determinism))), ((parse_tree.prog_item).pf_cond) :: ((parse_tree.prog_data).condition), ((parse_tree.prog_item).pf_purity) :: ((parse_tree.prog_data).purity), ((parse_tree.prog_item).pf_class_context) :: ((parse_tree.prog_data).prog_constraints))
	;	item_pred_or_func_mode(((parse_tree.prog_item).pfm_instvarset) :: ((parse_tree.prog_data).inst_varset), ((parse_tree.prog_item).pfm_which) :: (maybe.maybe(((mdbcomp.prim_data).pred_or_func))), ((parse_tree.prog_item).pfm_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).pfm_arg_modes) :: (list.list(((parse_tree.prog_data).mer_mode))), ((parse_tree.prog_item).pfm_maybe_with_inst) :: (maybe.maybe(((parse_tree.prog_data).mer_inst))), ((parse_tree.prog_item).pfm_maybe_detism) :: (maybe.maybe(((parse_tree.prog_data).determinism))), ((parse_tree.prog_item).pfm_cond) :: ((parse_tree.prog_data).condition))
	;	item_pragma(((parse_tree.prog_item).pragma_origin) :: ((parse_tree.prog_item).item_origin), ((parse_tree.prog_item).pragma_type) :: ((parse_tree.prog_item).pragma_type))
	;	item_promise(((parse_tree.prog_item).prom_type) :: ((parse_tree.prog_data).promise_type), ((parse_tree.prog_item).prom_clause) :: ((parse_tree.prog_item).goal), ((parse_tree.prog_item).prom_varset) :: ((parse_tree.prog_data).prog_varset), ((parse_tree.prog_item).prom_univ_quant_vars) :: ((parse_tree.prog_data).prog_vars))
	;	item_typeclass(((parse_tree.prog_item).tc_constraints) :: (list.list(((parse_tree.prog_data).prog_constraint))), ((parse_tree.prog_item).tc_fundeps) :: (list.list(((parse_tree.prog_data).prog_fundep))), ((parse_tree.prog_item).tc_class_name) :: ((parse_tree.prog_data).class_name), ((parse_tree.prog_item).tc_class_params) :: (list.list(((parse_tree.prog_data).tvar))), ((parse_tree.prog_item).tc_class_methods) :: ((parse_tree.prog_data).class_interface), ((parse_tree.prog_item).tc_varset) :: ((parse_tree.prog_data).tvarset))
	;	item_instance(((parse_tree.prog_item).ci_deriving_class) :: (list.list(((parse_tree.prog_data).prog_constraint))), ((parse_tree.prog_item).ci_class_name) :: ((parse_tree.prog_data).class_name), ((parse_tree.prog_item).ci_types) :: (list.list(((parse_tree.prog_data).mer_type))), ((parse_tree.prog_item).ci_method_instances) :: ((parse_tree.prog_data).instance_body), ((parse_tree.prog_item).ci_varset) :: ((parse_tree.prog_data).tvarset), ((parse_tree.prog_item).ci_module_containing_instance) :: ((mdbcomp.prim_data).module_name))
	;	item_initialise(((parse_tree.prog_item).item_origin), ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_data).arity))
	;	item_finalise(((parse_tree.prog_item).item_origin), ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_data).arity))
	;	item_mutable(((parse_tree.prog_item).mut_name) :: string, ((parse_tree.prog_item).mut_type) :: ((parse_tree.prog_data).mer_type), ((parse_tree.prog_item).mut_init_value) :: ((parse_tree.prog_data).prog_term), ((parse_tree.prog_item).mut_inst) :: ((parse_tree.prog_data).mer_inst), ((parse_tree.prog_item).mut_attrs) :: ((parse_tree.prog_item).mutable_var_attributes), ((parse_tree.prog_item).mut_varset) :: ((parse_tree.prog_data).prog_varset))
	;	item_nothing(((parse_tree.prog_item).nothing_maybe_warning) :: (maybe.maybe(((parse_tree.prog_item).item_warning)))).
:- type item_and_context
	--->	item_and_context(((parse_tree.prog_item).item), ((parse_tree.prog_data).prog_context)).
:- type item_compiler_origin
	--->	initialise_decl 
	;	finalise_decl 
	;	mutable_decl 
	;	solver_type 
	;	pragma_memo_attribute 
	;	foreign_imports .
:- type item_list == (list.list(((parse_tree.prog_item).item_and_context))).
:- type item_origin
	--->	user 
	;	compiler(((parse_tree.prog_item).item_compiler_origin)).
:- type item_warning
	--->	item_warning((maybe.maybe(((libs.options).option))), string, (term.term)).
:- type message_list == (assoc_list.assoc_list(string, (term.term))).
:- type module_defn
	--->	md_module(((mdbcomp.prim_data).module_name))
	;	md_end_module(((mdbcomp.prim_data).module_name))
	;	md_interface 
	;	md_implementation 
	;	md_private_interface 
	;	md_imported(((parse_tree.prog_data).import_locn))
	;	md_used(((parse_tree.prog_data).import_locn))
	;	md_abstract_imported 
	;	md_opt_imported 
	;	md_transitively_imported 
	;	md_external((maybe.maybe(((parse_tree.prog_data).backend))), ((parse_tree.prog_data).sym_name_specifier))
	;	md_export(((parse_tree.prog_data).sym_list))
	;	md_import(((parse_tree.prog_data).sym_list))
	;	md_use(((parse_tree.prog_data).sym_list))
	;	md_include_module((list.list(((mdbcomp.prim_data).module_name))))
	;	md_version_numbers(((mdbcomp.prim_data).module_name), (recompilation.version_numbers)).
:- type mutable_thread_local
	--->	mutable_thread_local 
	;	mutable_not_thread_local .
:- type mutable_trailed
	--->	mutable_trailed 
	;	mutable_untrailed .
:- type mutable_var_attributes.
:- type pragma_type
	--->	pragma_foreign_decl(((parse_tree.prog_item).decl_lang) :: ((libs.globals).foreign_language), ((parse_tree.prog_item).decl_is_local) :: ((parse_tree.prog_data).foreign_decl_is_local), ((parse_tree.prog_item).decl_decl) :: string)
	;	pragma_foreign_code(((parse_tree.prog_item).code_lang) :: ((libs.globals).foreign_language), ((parse_tree.prog_item).code_code) :: string)
	;	pragma_foreign_proc(((parse_tree.prog_item).proc_attrs) :: ((parse_tree.prog_data).pragma_foreign_proc_attributes), ((parse_tree.prog_item).proc_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).proc_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).proc_vars) :: (list.list(((parse_tree.prog_data).pragma_var))), ((parse_tree.prog_item).proc_varset) :: ((parse_tree.prog_data).prog_varset), ((parse_tree.prog_item).proc_instvarset) :: ((parse_tree.prog_data).inst_varset), ((parse_tree.prog_item).proc_impl) :: ((parse_tree.prog_data).pragma_foreign_code_impl))
	;	pragma_foreign_import_module(((parse_tree.prog_item).imp_lang) :: ((libs.globals).foreign_language), ((parse_tree.prog_item).imp_module) :: ((mdbcomp.prim_data).module_name))
	;	pragma_foreign_export(((parse_tree.prog_item).exp_language) :: ((libs.globals).foreign_language), ((parse_tree.prog_item).exp_predname) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).exp_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).exp_modes) :: (list.list(((parse_tree.prog_data).mer_mode))), ((parse_tree.prog_item).exp_foreign_name) :: string)
	;	pragma_import(((parse_tree.prog_item).import_pred_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).import_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).import_modes) :: (list.list(((parse_tree.prog_data).mer_mode))), ((parse_tree.prog_item).import_attrs) :: ((parse_tree.prog_data).pragma_foreign_proc_attributes), ((parse_tree.prog_item).import_foreign_name) :: string)
	;	pragma_type_spec(((parse_tree.prog_item).tspec_pred_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).tspec_new_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).tspec_arity) :: ((parse_tree.prog_data).arity), ((parse_tree.prog_item).tspec_p_or_f) :: (maybe.maybe(((mdbcomp.prim_data).pred_or_func))), ((parse_tree.prog_item).tspec_modes) :: (maybe.maybe((list.list(((parse_tree.prog_data).mer_mode))))), ((parse_tree.prog_item).tspec_tsubst) :: ((parse_tree.prog_data).type_subst), ((parse_tree.prog_item).tspec_tvarset) :: ((parse_tree.prog_data).tvarset), ((parse_tree.prog_item).tspec_items) :: (set.set((recompilation.item_id))))
	;	pragma_inline(((parse_tree.prog_item).inline_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).inline_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_no_inline(((parse_tree.prog_item).noinline_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).noinline_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_unused_args(((parse_tree.prog_item).unused_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).unused_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).unused_arity) :: ((parse_tree.prog_data).arity), ((parse_tree.prog_item).unused_mode) :: ((parse_tree.prog_data).mode_num), ((parse_tree.prog_item).unused_args) :: (list.list(int)))
	;	pragma_exceptions(((parse_tree.prog_item).exceptions_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).exceptions_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).exceptions_arity) :: ((parse_tree.prog_data).arity), ((parse_tree.prog_item).exceptions_mode) :: ((parse_tree.prog_data).mode_num), ((parse_tree.prog_item).exceptions_status) :: ((parse_tree.prog_data).exception_status))
	;	pragma_trailing_info(((parse_tree.prog_item).trailing_info_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).trailing_info_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).trailing_info_arity) :: ((parse_tree.prog_data).arity), ((parse_tree.prog_item).trailing_info_mode) :: ((parse_tree.prog_data).mode_num), ((parse_tree.prog_item).trailing_info_status) :: ((parse_tree.prog_data).trailing_status))
	;	pragma_mm_tabling_info(((parse_tree.prog_item).mm_tabling_info_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).mm_tabling_info_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).mm_tabling_info_arity) :: ((parse_tree.prog_data).arity), ((parse_tree.prog_item).mm_tabling_info_mode) :: ((parse_tree.prog_data).mode_num), ((parse_tree.prog_item).mm_tabling_info_status) :: ((parse_tree.prog_data).mm_tabling_status))
	;	pragma_obsolete(((parse_tree.prog_item).obsolete_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).obsolete_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_source_file(((parse_tree.prog_item).pragma_source_file) :: string)
	;	pragma_tabled(((parse_tree.prog_item).tabled_method) :: ((parse_tree.prog_data).eval_method), ((parse_tree.prog_item).tabled_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).tabled_arity) :: int, ((parse_tree.prog_item).tabled_p_or_f) :: (maybe.maybe(((mdbcomp.prim_data).pred_or_func))), ((parse_tree.prog_item).tabled_mode) :: (maybe.maybe((list.list(((parse_tree.prog_data).mer_mode))))), ((parse_tree.prog_item).tabled_attributes) :: (maybe.maybe(((parse_tree.prog_data).table_attributes))))
	;	pragma_fact_table(((parse_tree.prog_item).fact_table_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).fact_table_arity) :: ((parse_tree.prog_data).arity), ((parse_tree.prog_item).fact_table_file) :: string)
	;	pragma_reserve_tag(((parse_tree.prog_item).restag_type) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).restag_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_promise_equivalent_clauses(((parse_tree.prog_item).eqv_clauses_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).eqv_clauses_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_promise_pure(((parse_tree.prog_item).pure_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).pure_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_promise_semipure(((parse_tree.prog_item).semipure_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).semipure_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_termination_info(((parse_tree.prog_item).terminfo_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).terminfo_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).terminfo_mode) :: (list.list(((parse_tree.prog_data).mer_mode))), ((parse_tree.prog_item).terminfo_args) :: (maybe.maybe(((parse_tree.prog_data).pragma_arg_size_info))), ((parse_tree.prog_item).terminfo_term) :: (maybe.maybe(((parse_tree.prog_data).pragma_termination_info))))
	;	pragma_termination2_info(((parse_tree.prog_item).terminfo2_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).terminfo2_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).terminfo2_mode) :: (list.list(((parse_tree.prog_data).mer_mode))), ((parse_tree.prog_item).terminfo2_args) :: (maybe.maybe(((parse_tree.prog_data).pragma_constr_arg_size_info))), ((parse_tree.prog_item).terminfo2_args2) :: (maybe.maybe(((parse_tree.prog_data).pragma_constr_arg_size_info))), ((parse_tree.prog_item).terminfo2_term) :: (maybe.maybe(((parse_tree.prog_data).pragma_termination_info))))
	;	pragma_terminates(((parse_tree.prog_item).term_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).term_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_does_not_terminate(((parse_tree.prog_item).noterm_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).noterm_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_check_termination(((parse_tree.prog_item).checkterm_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).checkterm_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_mode_check_clauses(((parse_tree.prog_item).mode_check_clause_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).mode_check_clause_arity) :: ((parse_tree.prog_data).arity))
	;	pragma_structure_sharing(((parse_tree.prog_item).sharing_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).sharing_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).sharing_mode) :: (list.list(((parse_tree.prog_data).mer_mode))), ((parse_tree.prog_item).sharing_headvars) :: ((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).sharing_headvartypes) :: (list.list(((parse_tree.prog_data).mer_type))), ((parse_tree.prog_item).sharing_description) :: (maybe.maybe(((parse_tree.prog_data).structure_sharing_domain))))
	;	pragma_structure_reuse(((parse_tree.prog_item).reuse_p_or_f) :: ((mdbcomp.prim_data).pred_or_func), ((parse_tree.prog_item).reuse_name) :: ((mdbcomp.prim_data).sym_name), ((parse_tree.prog_item).reuse_mode) :: (list.list(((parse_tree.prog_data).mer_mode))), ((parse_tree.prog_item).reuse_headvars) :: ((parse_tree.prog_data).prog_vars), ((parse_tree.prog_item).reuse_headvartypes) :: (list.list(((parse_tree.prog_data).mer_type))), ((parse_tree.prog_item).reuse_description) :: (maybe.maybe(((parse_tree.prog_data).structure_reuse_domain)))).
:- inst (item_mutable) == bound(item_mutable(ground, ground, ground, ground, ground, ground)).
:- inst (pragma_type_spec) == bound(pragma_type_spec(ground, ground, ground, ground, ground, ground, ground, ground)).
