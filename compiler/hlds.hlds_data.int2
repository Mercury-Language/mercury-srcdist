:- module (hlds.hlds_data).
:- interface.
:- import_module assoc_list.
:- import_module bool.
:- import_module libs.
:- import_module list.
:- import_module map.
:- import_module maybe.
:- import_module mdbcomp.
:- import_module parse_tree.
:- import_module (hlds.hlds_pred).
:- import_module (hlds.status).
:- import_module (libs.globals).
:- import_module (mdbcomp.sym_name).
:- import_module (parse_tree.prog_data).
:- type cons_table.
:- type cons_tag
    --->    string_tag(string)
    ;       float_tag(float)
    ;       int_tag(hlds.hlds_data.int_tag)
    ;       foreign_tag(libs.globals.foreign_language, string)
    ;       closure_tag(hlds.hlds_pred.pred_id, hlds.hlds_pred.proc_id, parse_tree.prog_data.lambda_eval_method)
    ;       type_ctor_info_tag(mdbcomp.sym_name.module_name, string, parse_tree.prog_data.arity)
    ;       base_typeclass_info_tag(mdbcomp.sym_name.module_name, parse_tree.prog_data.class_id, string)
    ;       type_info_const_tag(int)
    ;       typeclass_info_const_tag(int)
    ;       ground_term_const_tag(int, hlds.hlds_data.cons_tag)
    ;       tabling_info_tag(hlds.hlds_pred.pred_id, hlds.hlds_pred.proc_id)
    ;       deep_profiling_proc_layout_tag(hlds.hlds_pred.pred_id, hlds.hlds_pred.proc_id)
    ;       table_io_entry_tag(hlds.hlds_pred.pred_id, hlds.hlds_pred.proc_id)
    ;       single_functor_tag 
    ;       unshared_tag(hlds.hlds_data.ptag)
    ;       direct_arg_tag(hlds.hlds_data.ptag)
    ;       shared_local_tag_no_args(hlds.hlds_data.ptag, hlds.hlds_data.local_sectag, hlds.hlds_data.lsectag_mask)
    ;       shared_local_tag_with_args(hlds.hlds_data.ptag, hlds.hlds_data.local_sectag)
    ;       shared_remote_tag(hlds.hlds_data.ptag, hlds.hlds_data.remote_sectag)
    ;       dummy_tag 
    ;       no_tag .
:- type constructor_arg_repn
    --->    ctor_arg_repn(((hlds.hlds_data).car_field_name) :: maybe.maybe(parse_tree.prog_data.ctor_field_name), ((hlds.hlds_data).car_type) :: parse_tree.prog_data.mer_type, ((hlds.hlds_data).car_pos_width) :: parse_tree.prog_data.arg_pos_width, ((hlds.hlds_data).car_context) :: parse_tree.prog_data.prog_context).
:- type constructor_repn
    --->    ctor_repn(((hlds.hlds_data).cr_ordinal) :: int, ((hlds.hlds_data).cr_maybe_exist) :: parse_tree.prog_data.maybe_cons_exist_constraints, ((hlds.hlds_data).cr_name) :: mdbcomp.sym_name.sym_name, ((hlds.hlds_data).cr_tag) :: hlds.hlds_data.cons_tag, ((hlds.hlds_data).cr_args) :: list.list(hlds.hlds_data.constructor_arg_repn), ((hlds.hlds_data).cr_num_args) :: int, ((hlds.hlds_data).cr_context) :: parse_tree.prog_data.prog_context).
:- type ctor_field_table == map.map(mdbcomp.sym_name.sym_name, list.list(hlds.hlds_data.hlds_ctor_field_defn)).
:- type ctor_name_to_repn_map == map.map(string, list.one_or_more(hlds.hlds_data.constructor_repn)).
:- type du_type_kind
    --->    du_type_kind_mercury_enum 
    ;       du_type_kind_foreign_enum(((hlds.hlds_data).dtkfe_language) :: libs.globals.foreign_language)
    ;       du_type_kind_direct_dummy 
    ;       du_type_kind_notag(((hlds.hlds_data).dtkn_functor_name) :: mdbcomp.sym_name.sym_name, ((hlds.hlds_data).dtkn_arg_type) :: parse_tree.prog_data.mer_type, ((hlds.hlds_data).dtkn_maybe_arg_name) :: maybe.maybe(string))
    ;       du_type_kind_general .
:- type du_type_repn
    --->    du_type_repn(((hlds.hlds_data).dur_ctor_repns) :: list.list(hlds.hlds_data.constructor_repn), ((hlds.hlds_data).dur_ctor_map) :: hlds.hlds_data.ctor_name_to_repn_map, ((hlds.hlds_data).dur_cheaper_tag_test) :: hlds.hlds_data.maybe_cheaper_tag_test, ((hlds.hlds_data).dur_kind) :: hlds.hlds_data.du_type_kind, ((hlds.hlds_data).dur_direct_arg_ctors) :: maybe.maybe(list.list(parse_tree.prog_data.sym_name_and_arity))).
:- type field_access_type
    --->    get 
    ;       set .
:- type foreign_type_body
    --->    foreign_type_body(((hlds.hlds_data).c) :: hlds.hlds_data.foreign_type_lang_body(parse_tree.prog_data.c_foreign_type), ((hlds.hlds_data).java) :: hlds.hlds_data.foreign_type_lang_body(parse_tree.prog_data.java_foreign_type), ((hlds.hlds_data).csharp) :: hlds.hlds_data.foreign_type_lang_body(parse_tree.prog_data.csharp_foreign_type), ((hlds.hlds_data).erlang) :: hlds.hlds_data.foreign_type_lang_body(parse_tree.prog_data.erlang_foreign_type)).
:- type foreign_type_lang_body(T) == maybe.maybe(hlds.hlds_data.foreign_type_lang_data(T)).
:- type foreign_type_lang_data(T)
    --->    foreign_type_lang_data(T, parse_tree.prog_data.maybe_canonical, parse_tree.prog_data.foreign_type_assertions).
:- type hlds_cons_defn
    --->    hlds_cons_defn(((hlds.hlds_data).cons_type_ctor) :: parse_tree.prog_data.type_ctor, ((hlds.hlds_data).cons_type_tvarset) :: parse_tree.prog_data.tvarset, ((hlds.hlds_data).cons_type_params) :: list.list(parse_tree.prog_data.type_param), ((hlds.hlds_data).cons_type_kinds) :: parse_tree.prog_data.tvar_kind_map, ((hlds.hlds_data).cons_maybe_exist) :: parse_tree.prog_data.maybe_cons_exist_constraints, ((hlds.hlds_data).cons_args) :: list.list(parse_tree.prog_data.constructor_arg), ((hlds.hlds_data).cons_context) :: parse_tree.prog_data.prog_context).
:- type hlds_ctor_field_defn
    --->    hlds_ctor_field_defn(((hlds.hlds_data).field_context) :: parse_tree.prog_data.prog_context, ((hlds.hlds_data).field_status) :: hlds.status.type_status, ((hlds.hlds_data).field_type_ctor) :: parse_tree.prog_data.type_ctor, ((hlds.hlds_data).field_cons_id) :: parse_tree.prog_data.cons_id, ((hlds.hlds_data).field_arg_num) :: int).
:- type hlds_type_body
    --->    hlds_du_type(((hlds.hlds_data).du_type_ctors) :: list.list(parse_tree.prog_data.constructor), ((hlds.hlds_data).du_type_canonical) :: parse_tree.prog_data.maybe_canonical, ((hlds.hlds_data).du_type_repn) :: maybe.maybe(hlds.hlds_data.du_type_repn), ((hlds.hlds_data).du_type_is_foreign_type) :: maybe.maybe(hlds.hlds_data.foreign_type_body))
    ;       hlds_eqv_type(parse_tree.prog_data.mer_type)
    ;       hlds_foreign_type(hlds.hlds_data.foreign_type_body)
    ;       hlds_solver_type(parse_tree.prog_data.type_details_solver)
    ;       hlds_abstract_type(parse_tree.prog_data.type_details_abstract).
:- type hlds_type_defn.
:- type int_tag
    --->    int_tag_int(int)
    ;       int_tag_uint(uint)
    ;       int_tag_int8(int8)
    ;       int_tag_uint8(uint8)
    ;       int_tag_int16(int16)
    ;       int_tag_uint16(uint16)
    ;       int_tag_int32(int32)
    ;       int_tag_uint32(uint32)
    ;       int_tag_int64(int64)
    ;       int_tag_uint64(uint64).
:- type local_sectag
    --->    local_sectag(((hlds.hlds_data).lsectag_value) :: uint, ((hlds.hlds_data).lsectag_prim_sec) :: uint, ((hlds.hlds_data).lsectag_bits) :: hlds.hlds_data.sectag_bits).
:- type lsectag_mask
    --->    lsectag_always_rest_of_word 
    ;       lsectag_must_be_masked .
:- type may_use_atomic_alloc
    --->    may_use_atomic_alloc 
    ;       may_not_use_atomic_alloc .
:- type maybe_cheaper_tag_test
    --->    no_cheaper_tag_test 
    ;       cheaper_tag_test(((hlds.hlds_data).more_expensive_cons_id) :: parse_tree.prog_data.cons_id, ((hlds.hlds_data).more_expensive_cons_tag) :: hlds.hlds_data.cons_tag, ((hlds.hlds_data).less_expensive_cons_id) :: parse_tree.prog_data.cons_id, ((hlds.hlds_data).less_expensive_cons_tag) :: hlds.hlds_data.cons_tag).
:- type no_tag_type
    --->    no_tag_type(list.list(parse_tree.prog_data.type_param), mdbcomp.sym_name.sym_name, parse_tree.prog_data.mer_type).
:- type no_tag_type_table == map.map(parse_tree.prog_data.type_ctor, hlds.hlds_data.no_tag_type).
:- type ptag
    --->    ptag(uint8).
:- type remote_sectag
    --->    remote_sectag(((hlds.hlds_data).rsectag_value) :: uint, ((hlds.hlds_data).rsectag_added) :: hlds.hlds_data.sectag_added_by).
:- type rsectag_size
    --->    rsectag_word 
    ;       rsectag_subword(hlds.hlds_data.sectag_bits).
:- type sectag_added_by
    --->    sectag_added_by_unify 
    ;       sectag_added_by_constructor .
:- type sectag_bits
    --->    sectag_bits(((hlds.hlds_data).sectag_num_bits) :: uint8, ((hlds.hlds_data).sectag_mask) :: uint).
:- type tagged_cons_id
    --->    tagged_cons_id(parse_tree.prog_data.cons_id, hlds.hlds_data.cons_tag).
:- type type_defn_prev_errors
    --->    type_defn_no_prev_errors 
    ;       type_defn_prev_errors .
:- type type_table.
:- implementation.
:- type cons_table == map.map(string, hlds.hlds_data.inner_cons_table).
:- type inner_cons_entry.
:- type inner_cons_table == list.list(hlds.hlds_data.inner_cons_entry).
:- type type_ctor_table == map.map(parse_tree.prog_data.type_ctor, hlds.hlds_data.hlds_type_defn).
:- type type_table == map.map(string, hlds.hlds_data.type_ctor_table).
