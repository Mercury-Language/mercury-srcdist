:- module (check_hlds.mode_info).
:- interface.
:- use_module assoc_list.
:- use_module list.
:- use_module map.
:- use_module (check_hlds.mode_errors).
:- use_module (parse_tree.prog_data).
:- use_module (parse_tree.set_of_var).
:- type call_context
    --->    call_context_unify(hlds.hlds_goal.unify_context)
    ;       call_context_call(check_hlds.mode_info.mode_call_id).
:- type debug_flags
    --->    debug_flags(((check_hlds.mode_info).verbose) :: bool.bool, ((check_hlds.mode_info).minimal) :: bool.bool, ((check_hlds.mode_info).statistics) :: bool.bool).
:- type had_from_ground_term_scope
    --->    had_from_ground_term_scope 
    ;       did_not_have_from_ground_term_scope .
:- type how_to_check_goal
    --->    check_modes 
    ;       check_unique_modes .
:- type in_dupl_for_switch
    --->    in_dupl_for_switch 
    ;       not_in_dupl_for_switch .
:- type in_from_ground_term_scope
    --->    in_from_ground_term_scope 
    ;       not_in_from_ground_term_scope .
:- type in_promise_purity_scope
    --->    in_promise_purity_scope 
    ;       not_in_promise_purity_scope .
:- type locked_vars == assoc_list.assoc_list(check_hlds.mode_info.var_lock_reason, parse_tree.set_of_var.set_of_progvar).
:- type make_ground_terms_unique
    --->    make_ground_terms_unique 
    ;       do_not_make_ground_terms_unique .
:- type may_change_called_proc
    --->    may_change_called_proc 
    ;       may_not_change_called_proc .
:- type mode_call_id
    --->    mode_call_plain(hlds.hlds_pred.pred_id)
    ;       mode_call_generic(hlds.hlds_pred.generic_call_id).
:- type mode_context
    --->    mode_context_call(check_hlds.mode_info.mode_call_id, int)
    ;       mode_context_unify(hlds.hlds_goal.unify_context, check_hlds.mode_info.side)
    ;       mode_context_uninitialized .
:- type mode_info.
:- type par_conj_mode_check
    --->    par_conj_mode_check(((check_hlds.mode_info).par_conj_nonlocals) :: parse_tree.set_of_var.set_of_progvar, ((check_hlds.mode_info).par_conj_bound) :: parse_tree.set_of_var.set_of_progvar).
:- type par_conj_mode_check_stack == list.list(check_hlds.mode_info.par_conj_mode_check).
:- type pred_var_multimode_map == map.map(parse_tree.prog_data.prog_var, check_hlds.mode_errors.pred_var_multimode_pred_error).
:- type side
    --->    left 
    ;       right .
:- type var_lock_reason
    --->    var_lock_negation 
    ;       var_lock_if_then_else 
    ;       var_lock_lambda(mdbcomp.prim_data.pred_or_func)
    ;       var_lock_trace_goal 
    ;       var_lock_atomic_goal 
    ;       var_lock_par_conj .
:- type_representation(debug_flags, is_word_aligned_ptr).
:- type_representation(had_from_ground_term_scope, du_repn(enum("had_from_ground_term_scope", "did_not_have_from_ground_term_scope", [],  no_c_j_cs_e))).
:- type_representation(how_to_check_goal, du_repn(enum("check_modes", "check_unique_modes", [],  no_c_j_cs_e))).
:- type_representation(in_dupl_for_switch, du_repn(enum("in_dupl_for_switch", "not_in_dupl_for_switch", [],  no_c_j_cs_e))).
:- type_representation(in_from_ground_term_scope, du_repn(enum("in_from_ground_term_scope", "not_in_from_ground_term_scope", [],  no_c_j_cs_e))).
:- type_representation(in_promise_purity_scope, du_repn(enum("in_promise_purity_scope", "not_in_promise_purity_scope", [],  no_c_j_cs_e))).
:- type_representation(locked_vars, is_eqv_to(assoc_list.assoc_list(check_hlds.mode_info.var_lock_reason, parse_tree.set_of_var.set_of_progvar))).
:- type_representation(make_ground_terms_unique, du_repn(enum("make_ground_terms_unique", "do_not_make_ground_terms_unique", [],  no_c_j_cs_e))).
:- type_representation(may_change_called_proc, du_repn(enum("may_change_called_proc", "may_not_change_called_proc", [],  no_c_j_cs_e))).
:- type_representation(mode_info, is_word_aligned_ptr).
:- type_representation(par_conj_mode_check, is_word_aligned_ptr).
:- type_representation(par_conj_mode_check_stack, is_eqv_to(list.list(check_hlds.mode_info.par_conj_mode_check))).
:- type_representation(pred_var_multimode_map, is_eqv_to(map.map(parse_tree.prog_data.prog_var, check_hlds.mode_errors.pred_var_multimode_pred_error))).
:- type_representation(side, du_repn(enum("left", "right", [],  no_c_j_cs_e))).
