:- module (transform_hlds.term_constr_data).
:- interface.
:- use_module list.
:- use_module map.
:- use_module set.
:- use_module (libs.lp_rational).
:- use_module (parse_tree.prog_data).
:- type abstract_goal
    --->    term_disj(((transform_hlds.term_constr_data).disj_goals) :: list.list(transform_hlds.term_constr_data.abstract_goal), ((transform_hlds.term_constr_data).disj_size) :: int, ((transform_hlds.term_constr_data).disj_locals) :: transform_hlds.term_constr_data.local_vars, ((transform_hlds.term_constr_data).disj_nonlocals) :: transform_hlds.term_constr_data.nonlocal_vars)
    ;       term_conj(((transform_hlds.term_constr_data).conj_goals) :: list.list(transform_hlds.term_constr_data.abstract_goal), ((transform_hlds.term_constr_data).conj_locals) :: transform_hlds.term_constr_data.local_vars, ((transform_hlds.term_constr_data).conj_nonlocals) :: transform_hlds.term_constr_data.nonlocal_vars)
    ;       term_call(((transform_hlds.term_constr_data).call_ppid) :: transform_hlds.term_constr_data.abstract_ppid, ((transform_hlds.term_constr_data).call_context) :: parse_tree.prog_data.prog_context, ((transform_hlds.term_constr_data).call_vars) :: transform_hlds.term_constr_data.call_vars, ((transform_hlds.term_constr_data).call_zeros) :: transform_hlds.term_constr_data.zero_vars, ((transform_hlds.term_constr_data).call_locals) :: transform_hlds.term_constr_data.local_vars, ((transform_hlds.term_constr_data).call_nonlocals) :: transform_hlds.term_constr_data.nonlocal_vars, ((transform_hlds.term_constr_data).call_constrs) :: libs.polyhedron.polyhedron)
    ;       term_primitive(((transform_hlds.term_constr_data).prim_constrs) :: libs.polyhedron.polyhedron, ((transform_hlds.term_constr_data).prim_locals) :: transform_hlds.term_constr_data.local_vars, ((transform_hlds.term_constr_data).prim_nonlocals) :: transform_hlds.term_constr_data.nonlocal_vars).
:- type abstract_goals == list.list(transform_hlds.term_constr_data.abstract_goal).
:- type abstract_ho_call
    --->    ho_call(parse_tree.prog_data.prog_context).
:- type abstract_ppid
    --->    real(hlds.hlds_pred.pred_proc_id).
:- type abstract_proc
    --->    abstract_proc(((transform_hlds.term_constr_data).ap_ppid) :: transform_hlds.term_constr_data.abstract_ppid, ((transform_hlds.term_constr_data).ap_context) :: parse_tree.prog_data.prog_context, ((transform_hlds.term_constr_data).ap_head_vars) :: transform_hlds.term_constr_data.head_vars, ((transform_hlds.term_constr_data).ap_inputs) :: list.list(bool.bool), ((transform_hlds.term_constr_data).ap_body) :: transform_hlds.term_constr_data.abstract_goal, ((transform_hlds.term_constr_data).ap_size_var_map) :: transform_hlds.term_constr_data.size_var_map, ((transform_hlds.term_constr_data).ap_size_varset) :: transform_hlds.term_constr_data.size_varset, ((transform_hlds.term_constr_data).ap_zeros) :: transform_hlds.term_constr_data.zero_vars, ((transform_hlds.term_constr_data).ap_is_entry) :: bool.bool, ((transform_hlds.term_constr_data).ap_recursion) :: transform_hlds.term_constr_data.recursion_type, ((transform_hlds.term_constr_data).ap_num_calls) :: int, ((transform_hlds.term_constr_data).ap_ho_calls) :: list.list(transform_hlds.term_constr_data.abstract_ho_call)).
:- type abstract_scc == set.set(transform_hlds.term_constr_data.abstract_proc).
:- type arg_size_result
    --->    arg_size_ok 
    ;       arg_size_error(list.list(transform_hlds.term_constr_errors.term2_error)).
:- type call_vars == transform_hlds.term_constr_data.size_vars.
:- type head_vars == transform_hlds.term_constr_data.size_vars.
:- type local_vars == transform_hlds.term_constr_data.size_vars.
:- type nonlocal_vars == transform_hlds.term_constr_data.size_vars.
:- type recursion_type
    --->    none 
    ;       direct_only 
    ;       mutual_only 
    ;       both .
:- type size_term == libs.lp_rational.lp_term.
:- type size_terms == libs.lp_rational.lp_terms.
:- type size_var == libs.lp_rational.lp_var.
:- type size_var_map == map.map(parse_tree.prog_data.prog_var, transform_hlds.term_constr_data.size_var).
:- type size_vars == list.list(transform_hlds.term_constr_data.size_var).
:- type size_varset == libs.lp_rational.lp_varset.
:- type widening
    --->    after_fixed_cutoff(int).
:- type zero_vars == set.set(transform_hlds.term_constr_data.size_var).
:- type_representation(abstract_goals, is_eqv_to(list.list(transform_hlds.term_constr_data.abstract_goal))).
:- type_representation(abstract_ho_call, du_repn(notag("ho_call", parse_tree.prog_data.prog_context,  no_c_j_cs_e))).
:- type_representation(abstract_ppid, du_repn(notag("real", hlds.hlds_pred.pred_proc_id,  no_c_j_cs_e))).
:- type_representation(abstract_proc, is_word_aligned_ptr).
:- type_representation(abstract_scc, is_eqv_to(set.set(transform_hlds.term_constr_data.abstract_proc))).
:- type_representation(call_vars, is_eqv_to(transform_hlds.term_constr_data.size_vars)).
:- type_representation(head_vars, is_eqv_to(transform_hlds.term_constr_data.size_vars)).
:- type_representation(local_vars, is_eqv_to(transform_hlds.term_constr_data.size_vars)).
:- type_representation(nonlocal_vars, is_eqv_to(transform_hlds.term_constr_data.size_vars)).
:- type_representation(recursion_type, du_repn(enum("none", "direct_only", ["mutual_only", "both"],  no_c_j_cs_e))).
:- type_representation(size_term, is_eqv_to(libs.lp_rational.lp_term)).
:- type_representation(size_terms, is_eqv_to(libs.lp_rational.lp_terms)).
:- type_representation(size_var, is_eqv_to(libs.lp_rational.lp_var)).
:- type_representation(size_var_map, is_eqv_to(map.map(parse_tree.prog_data.prog_var, transform_hlds.term_constr_data.size_var))).
:- type_representation(size_vars, is_eqv_to(list.list(transform_hlds.term_constr_data.size_var))).
:- type_representation(size_varset, is_eqv_to(libs.lp_rational.lp_varset)).
:- type_representation(widening, du_repn(notag("after_fixed_cutoff", int,  no_c_j_cs_e))).
:- type_representation(zero_vars, is_eqv_to(set.set(transform_hlds.term_constr_data.size_var))).
