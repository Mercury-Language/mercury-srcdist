:- module (parse_tree.prog_data).
:- interface.
:- import_module char.
:- import_module list.
:- import_module map.
:- import_module maybe.
:- import_module mdbcomp.
:- import_module set.
:- import_module term.
:- import_module varset.
:- import_module (mdbcomp.prim_data).
:- import_module (mdbcomp.sym_name).
:- import_module (parse_tree.prog_item).
:- type abstract_type_details
    --->    abstract_type_general 
    ;       abstract_enum_type(int)
    ;       abstract_solver_type .
:- type any_inst_info
    --->    any_inst_info(parse_tree.prog_data.inst_name, parse_tree.prog_data.uniqueness, parse_tree.prog_data.is_live, parse_tree.prog_data.unify_is_real).
:- type arg_reg_type_info
    --->    arg_reg_types_unset 
    ;       arg_reg_types(list.list(parse_tree.prog_data.ho_arg_reg)).
:- type arg_width
    --->    full_word 
    ;       double_word 
    ;       partial_word_first(int)
    ;       partial_word_shifted(int, int).
:- type arity == int.
:- type atomic_component_state
    --->    atomic_state_var(parse_tree.prog_data.prog_var)
    ;       atomic_var_pair(parse_tree.prog_data.prog_var, parse_tree.prog_data.prog_var).
:- type bound_inst
    --->    bound_functor(parse_tree.prog_data.cons_id, list.list(parse_tree.prog_data.mer_inst)).
:- type builtin_type
    --->    builtin_type_int 
    ;       builtin_type_float 
    ;       builtin_type_string 
    ;       builtin_type_char .
:- type c_foreign_type
    --->    c_type(string).
:- type can_fail
    --->    can_fail 
    ;       cannot_fail .
:- type class_id
    --->    class_id(parse_tree.prog_data.class_name, parse_tree.prog_data.arity).
:- type class_interface
    --->    class_interface_abstract 
    ;       class_interface_concrete(list.list(parse_tree.prog_item.class_method)).
:- type class_name == mdbcomp.sym_name.sym_name.
:- type comparison_pred == mdbcomp.sym_name.sym_name.
:- type cons_id
    --->    cons(mdbcomp.sym_name.sym_name, parse_tree.prog_data.arity, parse_tree.prog_data.type_ctor)
    ;       tuple_cons(parse_tree.prog_data.arity)
    ;       closure_cons(parse_tree.prog_data.shrouded_pred_proc_id, parse_tree.prog_data.lambda_eval_method)
    ;       int_const(int)
    ;       float_const(float)
    ;       char_const(char.char)
    ;       string_const(string)
    ;       impl_defined_const(string)
    ;       type_ctor_info_const(mdbcomp.sym_name.module_name, string, int)
    ;       base_typeclass_info_const(mdbcomp.sym_name.module_name, parse_tree.prog_data.class_id, int, string)
    ;       type_info_cell_constructor(parse_tree.prog_data.type_ctor)
    ;       typeclass_info_cell_constructor 
    ;       type_info_const(int)
    ;       typeclass_info_const(int)
    ;       ground_term_const(int, parse_tree.prog_data.cons_id)
    ;       tabling_info_const(parse_tree.prog_data.shrouded_pred_proc_id)
    ;       table_io_entry_desc(parse_tree.prog_data.shrouded_pred_proc_id)
    ;       deep_profiling_proc_layout(parse_tree.prog_data.shrouded_pred_proc_id).
:- type constructor
    --->    ctor(((parse_tree.prog_data).cons_exist) :: parse_tree.prog_data.existq_tvars, ((parse_tree.prog_data).cons_constraints) :: list.list(parse_tree.prog_data.prog_constraint), ((parse_tree.prog_data).cons_name) :: mdbcomp.sym_name.sym_name, ((parse_tree.prog_data).cons_args) :: list.list(parse_tree.prog_data.constructor_arg), ((parse_tree.prog_data).cons_num_args) :: int, ((parse_tree.prog_data).cons_context) :: parse_tree.prog_data.prog_context).
:- type constructor_arg
    --->    ctor_arg(((parse_tree.prog_data).arg_field_name) :: maybe.maybe(parse_tree.prog_data.ctor_field_name), ((parse_tree.prog_data).arg_type) :: parse_tree.prog_data.mer_type, ((parse_tree.prog_data).arg_width) :: parse_tree.prog_data.arg_width, ((parse_tree.prog_data).arg_context) :: parse_tree.prog_data.prog_context).
:- type csharp_foreign_type
    --->    csharp_type(string).
:- type ctor_field_name
    --->    ctor_field_name(mdbcomp.sym_name.sym_name, parse_tree.prog_data.prog_context).
:- type determinism
    --->    detism_det 
    ;       detism_semi 
    ;       detism_multi 
    ;       detism_non 
    ;       detism_cc_multi 
    ;       detism_cc_non 
    ;       detism_erroneous 
    ;       detism_failure .
:- type equality_pred == mdbcomp.sym_name.sym_name.
:- type erlang_foreign_type
    --->    erlang_type .
:- type existq_tvars == list.list(parse_tree.prog_data.tvar).
:- type foreign_language_type
    --->    c(parse_tree.prog_data.c_foreign_type)
    ;       java(parse_tree.prog_data.java_foreign_type)
    ;       csharp(parse_tree.prog_data.csharp_foreign_type)
    ;       erlang(parse_tree.prog_data.erlang_foreign_type).
:- type foreign_type_assertion
    --->    foreign_type_can_pass_as_mercury_type 
    ;       foreign_type_stable 
    ;       foreign_type_word_aligned_pointer .
:- type foreign_type_assertions
    --->    foreign_type_assertions(set.set(parse_tree.prog_data.foreign_type_assertion)).
:- type from_to_insts
    --->    from_to_insts(parse_tree.prog_data.mer_inst, parse_tree.prog_data.mer_inst).
:- type ground_inst_info
    --->    ground_inst_info(parse_tree.prog_data.inst_name, parse_tree.prog_data.uniqueness, parse_tree.prog_data.is_live, parse_tree.prog_data.unify_is_real).
:- type has_main
    --->    has_main 
    ;       no_main .
:- type head_inst_vars == map.map(parse_tree.prog_data.inst_var, parse_tree.prog_data.mer_inst).
:- type ho_arg_reg
    --->    ho_arg_reg_r 
    ;       ho_arg_reg_f .
:- type ho_groundness
    --->    ho_ground 
    ;       ho_any .
:- type ho_inst_info
    --->    higher_order(parse_tree.prog_data.pred_inst_info)
    ;       none_or_default_func .
:- type init_pred == mdbcomp.sym_name.sym_name.
:- type inst_defn
    --->    eqv_inst(parse_tree.prog_data.mer_inst)
    ;       abstract_inst .
:- type inst_id
    --->    inst_id(mdbcomp.sym_name.sym_name, parse_tree.prog_data.arity).
:- type inst_name
    --->    user_inst(mdbcomp.sym_name.sym_name, list.list(parse_tree.prog_data.mer_inst))
    ;       unify_inst(parse_tree.prog_data.is_live, parse_tree.prog_data.unify_is_real, parse_tree.prog_data.mer_inst, parse_tree.prog_data.mer_inst)
    ;       merge_inst(parse_tree.prog_data.mer_inst, parse_tree.prog_data.mer_inst)
    ;       ground_inst(parse_tree.prog_data.inst_name, parse_tree.prog_data.uniqueness, parse_tree.prog_data.is_live, parse_tree.prog_data.unify_is_real)
    ;       any_inst(parse_tree.prog_data.inst_name, parse_tree.prog_data.uniqueness, parse_tree.prog_data.is_live, parse_tree.prog_data.unify_is_real)
    ;       shared_inst(parse_tree.prog_data.inst_name)
    ;       mostly_uniq_inst(parse_tree.prog_data.inst_name)
    ;       typed_ground(parse_tree.prog_data.uniqueness, parse_tree.prog_data.mer_type)
    ;       typed_inst(parse_tree.prog_data.mer_type, parse_tree.prog_data.inst_name).
:- type inst_result_contains_any
    --->    inst_result_does_not_contain_any 
    ;       inst_result_does_contain_any 
    ;       inst_result_contains_any_unknown .
:- type inst_result_contains_inst_names
    --->    inst_result_contains_inst_names_known(set.set(parse_tree.prog_data.inst_name))
    ;       inst_result_contains_inst_names_unknown .
:- type inst_result_contains_inst_vars
    --->    inst_result_contains_inst_vars_known(set.set(parse_tree.prog_data.inst_var))
    ;       inst_result_contains_inst_vars_unknown .
:- type inst_result_contains_types
    --->    inst_result_contains_types_known(set.set(parse_tree.prog_data.type_ctor))
    ;       inst_result_contains_types_unknown .
:- type inst_result_groundness
    --->    inst_result_is_not_ground 
    ;       inst_result_is_ground 
    ;       inst_result_groundness_unknown .
:- type inst_result_type_ctor_propagated
    --->    inst_result_no_type_ctor_propagated 
    ;       inst_result_type_ctor_propagated(parse_tree.prog_data.type_ctor).
:- type inst_term == term.term(parse_tree.prog_data.inst_var_type).
:- type inst_test_results
    --->    inst_test_results(parse_tree.prog_data.inst_result_groundness, parse_tree.prog_data.inst_result_contains_any, parse_tree.prog_data.inst_result_contains_inst_names, parse_tree.prog_data.inst_result_contains_inst_vars, parse_tree.prog_data.inst_result_contains_types, parse_tree.prog_data.inst_result_type_ctor_propagated)
    ;       inst_test_no_results 
    ;       inst_test_results_fgtc .
:- type inst_var == term.var(parse_tree.prog_data.inst_var_type).
:- type inst_var_sub == map.map(parse_tree.prog_data.inst_var, parse_tree.prog_data.mer_inst).
:- type inst_var_type
    --->    inst_var_type .
:- type inst_varset == varset.varset(parse_tree.prog_data.inst_var_type).
:- type instance_body
    --->    instance_body_abstract 
    ;       instance_body_concrete(list.list(parse_tree.prog_data.instance_method)).
:- type instance_method
    --->    instance_method(((parse_tree.prog_data).instance_method_p_or_f) :: mdbcomp.prim_data.pred_or_func, ((parse_tree.prog_data).instance_method_name) :: mdbcomp.sym_name.sym_name, ((parse_tree.prog_data).instance_method_proc_def) :: parse_tree.prog_data.instance_proc_def, ((parse_tree.prog_data).instance_method_arity) :: parse_tree.prog_data.arity, ((parse_tree.prog_data).instance_method_decl_context) :: parse_tree.prog_data.prog_context).
:- type instance_proc_def
    --->    instance_proc_def_name(mdbcomp.sym_name.sym_name)
    ;       instance_proc_def_clauses(list.list(parse_tree.prog_item.item_clause_info)).
:- type is_live
    --->    is_live 
    ;       is_dead .
:- type is_solver_type
    --->    non_solver_type 
    ;       solver_type .
:- type java_foreign_type
    --->    java_type(string).
:- type kind
    --->    kind_star 
    ;       kind_arrow(parse_tree.prog_data.kind, parse_tree.prog_data.kind)
    ;       kind_variable(parse_tree.prog_data.kvar).
:- type kvar == term.var(parse_tree.prog_data.kvar_type).
:- type kvar_type
    --->    kind_var .
:- type lambda_eval_method
    --->    lambda_normal .
:- type maybe_class_method
    --->    is_not_a_class_method 
    ;       is_a_class_method .
:- type mer_inst
    --->    free 
    ;       free(parse_tree.prog_data.mer_type)
    ;       any(parse_tree.prog_data.uniqueness, parse_tree.prog_data.ho_inst_info)
    ;       bound(parse_tree.prog_data.uniqueness, parse_tree.prog_data.inst_test_results, list.list(parse_tree.prog_data.bound_inst))
    ;       ground(parse_tree.prog_data.uniqueness, parse_tree.prog_data.ho_inst_info)
    ;       not_reached 
    ;       inst_var(parse_tree.prog_data.inst_var)
    ;       constrained_inst_vars(set.set(parse_tree.prog_data.inst_var), parse_tree.prog_data.mer_inst)
    ;       defined_inst(parse_tree.prog_data.inst_name)
    ;       abstract_inst(mdbcomp.sym_name.sym_name, list.list(parse_tree.prog_data.mer_inst)).
:- type mer_mode
    --->    from_to_mode(parse_tree.prog_data.mer_inst, parse_tree.prog_data.mer_inst)
    ;       user_defined_mode(mdbcomp.sym_name.sym_name, list.list(parse_tree.prog_data.mer_inst)).
:- type mer_type
    --->    type_variable(parse_tree.prog_data.tvar, parse_tree.prog_data.kind)
    ;       defined_type(mdbcomp.sym_name.sym_name, list.list(parse_tree.prog_data.mer_type), parse_tree.prog_data.kind)
    ;       builtin_type(parse_tree.prog_data.builtin_type)
    ;       tuple_type(list.list(parse_tree.prog_data.mer_type), parse_tree.prog_data.kind)
    ;       higher_order_type(mdbcomp.prim_data.pred_or_func, list.list(parse_tree.prog_data.mer_type), parse_tree.prog_data.ho_inst_info, parse_tree.prog_data.purity, parse_tree.prog_data.lambda_eval_method)
    ;       apply_n_type(parse_tree.prog_data.tvar, list.list(parse_tree.prog_data.mer_type), parse_tree.prog_data.kind)
    ;       kinded_type(parse_tree.prog_data.mer_type, parse_tree.prog_data.kind).
:- type merge_inst_info
    --->    merge_inst_info(parse_tree.prog_data.mer_inst, parse_tree.prog_data.mer_inst).
:- type mm_tabling_status
    --->    mm_tabled_may_call 
    ;       mm_tabled_will_not_call 
    ;       mm_tabled_conditional .
:- type mode_defn
    --->    eqv_mode(parse_tree.prog_data.mer_mode).
:- type mode_id
    --->    mode_id(mdbcomp.sym_name.sym_name, parse_tree.prog_data.arity).
:- type need_qualifier
    --->    must_be_qualified 
    ;       may_be_unqualified .
:- type pred_inst_info
    --->    pred_inst_info(mdbcomp.prim_data.pred_or_func, list.list(parse_tree.prog_data.mer_mode), parse_tree.prog_data.arg_reg_type_info, parse_tree.prog_data.determinism).
:- type prog_constraint
    --->    constraint(((parse_tree.prog_data).constraint_class) :: parse_tree.prog_data.class_name, ((parse_tree.prog_data).constraint_arg_types) :: list.list(parse_tree.prog_data.mer_type)).
:- type prog_constraints
    --->    constraints(((parse_tree.prog_data).univ_constraints) :: list.list(parse_tree.prog_data.prog_constraint), ((parse_tree.prog_data).exist_constraints) :: list.list(parse_tree.prog_data.prog_constraint)).
:- type prog_context == term.context.
:- type prog_fundep
    --->    fundep(((parse_tree.prog_data).domain) :: list.list(parse_tree.prog_data.tvar), ((parse_tree.prog_data).range) :: list.list(parse_tree.prog_data.tvar)).
:- type prog_substitution == term.substitution(parse_tree.prog_data.prog_var_type).
:- type prog_term == term.term(parse_tree.prog_data.prog_var_type).
:- type prog_var == term.var(parse_tree.prog_data.prog_var_type).
:- type prog_var_renaming == map.map(parse_tree.prog_data.prog_var, parse_tree.prog_data.prog_var).
:- type prog_var_type
    --->    prog_var_type .
:- type prog_vars == list.list(parse_tree.prog_data.prog_var).
:- type prog_varset == varset.varset(parse_tree.prog_data.prog_var_type).
:- type promise_type
    --->    promise_type_exclusive 
    ;       promise_type_exhaustive 
    ;       promise_type_exclusive_exhaustive 
    ;       promise_type_true .
:- type purity
    --->    purity_pure 
    ;       purity_semipure 
    ;       purity_impure .
:- type shrouded_pred_id
    --->    shrouded_pred_id(int).
:- type shrouded_pred_proc_id
    --->    shrouded_pred_proc_id(int, int).
:- type shrouded_proc_id
    --->    shrouded_proc_id(int).
:- type simple_call_id
    --->    simple_call_id(mdbcomp.prim_data.pred_or_func, mdbcomp.sym_name.sym_name, parse_tree.prog_data.arity).
:- type soln_count
    --->    at_most_zero 
    ;       at_most_one 
    ;       at_most_many_cc 
    ;       at_most_many .
:- type solver_type_details
    --->    solver_type_details(((parse_tree.prog_data).std_representation_type) :: parse_tree.prog_data.mer_type, ((parse_tree.prog_data).std_ground_inst) :: parse_tree.prog_data.mer_inst, ((parse_tree.prog_data).std_any_inst) :: parse_tree.prog_data.mer_inst, ((parse_tree.prog_data).std_mutable_items) :: list.list(parse_tree.prog_item.item_mutable_info)).
:- type sym_name_and_arity
    --->    sym_name_arity(mdbcomp.sym_name.sym_name, parse_tree.prog_data.arity).
:- type sym_name_specifier
    --->    sym_name_specifier_name(mdbcomp.sym_name.sym_name)
    ;       sym_name_specifier_name_arity(mdbcomp.sym_name.sym_name, parse_tree.prog_data.arity).
:- type trace_compiletime
    --->    trace_flag(string)
    ;       trace_grade(parse_tree.prog_data.trace_grade)
    ;       trace_trace_level(parse_tree.prog_data.trace_trace_level).
:- type trace_expr(Base)
    --->    trace_base(Base)
    ;       trace_not(parse_tree.prog_data.trace_expr(Base))
    ;       trace_op(parse_tree.prog_data.trace_op, parse_tree.prog_data.trace_expr(Base), parse_tree.prog_data.trace_expr(Base)).
:- type trace_grade
    --->    trace_grade_debug 
    ;       trace_grade_ssdebug 
    ;       trace_grade_prof 
    ;       trace_grade_profdeep 
    ;       trace_grade_par 
    ;       trace_grade_trail 
    ;       trace_grade_rbmm 
    ;       trace_grade_llds 
    ;       trace_grade_mlds 
    ;       trace_grade_c 
    ;       trace_grade_csharp 
    ;       trace_grade_java 
    ;       trace_grade_erlang .
:- type trace_mutable_var
    --->    trace_mutable_var(((parse_tree.prog_data).trace_mutable_name) :: string, ((parse_tree.prog_data).trace_state_var) :: parse_tree.prog_data.prog_var).
:- type trace_op
    --->    trace_or 
    ;       trace_and .
:- type trace_runtime
    --->    trace_envvar(string).
:- type trace_trace_level
    --->    trace_level_shallow 
    ;       trace_level_deep .
:- type trailing_status
    --->    trail_may_modify 
    ;       trail_will_not_modify 
    ;       trail_conditional .
:- type tsubst == map.map(parse_tree.prog_data.tvar, parse_tree.prog_data.mer_type).
:- type tvar == term.var(parse_tree.prog_data.tvar_type).
:- type tvar_kind_map == map.map(parse_tree.prog_data.tvar, parse_tree.prog_data.kind).
:- type tvar_name_map == map.map(string, parse_tree.prog_data.tvar).
:- type tvar_renaming == map.map(parse_tree.prog_data.tvar, parse_tree.prog_data.tvar).
:- type tvar_type
    --->    type_var .
:- type tvarset == varset.varset(parse_tree.prog_data.tvar_type).
:- type type_and_mode
    --->    type_only(parse_tree.prog_data.mer_type)
    ;       type_and_mode(parse_tree.prog_data.mer_type, parse_tree.prog_data.mer_mode).
:- type type_ctor
    --->    type_ctor(mdbcomp.sym_name.sym_name, parse_tree.prog_data.arity).
:- type type_defn
    --->    parse_tree_du_type(((parse_tree.prog_data).du_ctors) :: list.list(parse_tree.prog_data.constructor), ((parse_tree.prog_data).du_user_uc) :: maybe.maybe(parse_tree.prog_data.unify_compare), ((parse_tree.prog_data).du_direct_arg) :: maybe.maybe(list.list(parse_tree.prog_data.sym_name_and_arity)))
    ;       parse_tree_eqv_type(((parse_tree.prog_data).eqv_type) :: parse_tree.prog_data.mer_type)
    ;       parse_tree_abstract_type(((parse_tree.prog_data).abstract_details) :: parse_tree.prog_data.abstract_type_details)
    ;       parse_tree_solver_type(((parse_tree.prog_data).solver_details) :: parse_tree.prog_data.solver_type_details, ((parse_tree.prog_data).solver_user_uc) :: maybe.maybe(parse_tree.prog_data.unify_compare))
    ;       parse_tree_foreign_type(((parse_tree.prog_data).foreign_lang_type) :: parse_tree.prog_data.foreign_language_type, ((parse_tree.prog_data).foreign_user_uc) :: maybe.maybe(parse_tree.prog_data.unify_compare), ((parse_tree.prog_data).foreign_assertions) :: parse_tree.prog_data.foreign_type_assertions).
:- type type_param == parse_tree.prog_data.tvar.
:- type type_term == term.term(parse_tree.prog_data.tvar_type).
:- type unify_compare
    --->    unify_compare(((parse_tree.prog_data).uc_unify) :: maybe.maybe(parse_tree.prog_data.equality_pred), ((parse_tree.prog_data).uc_compare) :: maybe.maybe(parse_tree.prog_data.comparison_pred))
    ;       abstract_noncanonical_type(parse_tree.prog_data.is_solver_type).
:- type unify_inst_info
    --->    unify_inst_info(parse_tree.prog_data.is_live, parse_tree.prog_data.unify_is_real, parse_tree.prog_data.mer_inst, parse_tree.prog_data.mer_inst).
:- type unify_is_real
    --->    real_unify 
    ;       fake_unify .
:- type uniqueness
    --->    shared 
    ;       unique 
    ;       mostly_unique 
    ;       clobbered 
    ;       mostly_clobbered .
:- type uses_reserved_address
    --->    uses_reserved_address 
    ;       does_not_use_reserved_address .
:- type uses_reserved_tag
    --->    uses_reserved_tag 
    ;       does_not_use_reserved_tag .
:- type var_name_print
    --->    print_name_only 
    ;       print_name_and_num 
    ;       print_num_only .
:- inst (mer_inst_is_bound) == bound(bound(ground, ground, ground)).
:- func best_purity(parse_tree.prog_data.purity, parse_tree.prog_data.purity) = parse_tree.prog_data.purity.
:- func cons_id_dummy_type_ctor = parse_tree.prog_data.type_ctor.
:- pred cons_id_is_const_struct(parse_tree.prog_data.cons_id, int).
:- mode cons_id_is_const_struct((builtin.in), (builtin.out)) is semidet.
:- pred determinism_components(parse_tree.prog_data.determinism, parse_tree.prog_data.can_fail, parse_tree.prog_data.soln_count).
:- mode determinism_components((builtin.in), (builtin.out), (builtin.out)) is det.
:- mode determinism_components((builtin.out), (builtin.in), (builtin.in)) is det.
:- pred equivalent_cons_ids(parse_tree.prog_data.cons_id, parse_tree.prog_data.cons_id).
:- mode equivalent_cons_ids((builtin.in), (builtin.in)) is semidet.
:- pred get_tvar_kind(parse_tree.prog_data.tvar_kind_map, parse_tree.prog_data.tvar, parse_tree.prog_data.kind).
:- mode get_tvar_kind((builtin.in), (builtin.in), (builtin.out)) is det.
:- func get_type_kind(parse_tree.prog_data.mer_type) = parse_tree.prog_data.kind.
:- pred less_pure(parse_tree.prog_data.purity, parse_tree.prog_data.purity).
:- mode less_pure((builtin.in), (builtin.in)) is semidet.
:- pred parse_trace_grade_name(string, parse_tree.prog_data.trace_grade).
:- mode parse_trace_grade_name((builtin.in), (builtin.out)) is semidet.
:- mode parse_trace_grade_name((builtin.out), (builtin.in)) is det.
:- mode parse_trace_grade_name((builtin.out), (builtin.out)) is multi.
:- func prog_constraint_get_arg_types(parse_tree.prog_data.prog_constraint) = list.list(parse_tree.prog_data.mer_type).
:- func prog_constraint_get_class(parse_tree.prog_data.prog_constraint) = parse_tree.prog_data.class_name.
:- pred tvarset_merge_renaming(parse_tree.prog_data.tvarset, parse_tree.prog_data.tvarset, parse_tree.prog_data.tvarset, parse_tree.prog_data.tvar_renaming).
:- mode tvarset_merge_renaming((builtin.in), (builtin.in), (builtin.out), (builtin.out)) is det.
:- pred tvarset_merge_renaming_without_names(parse_tree.prog_data.tvarset, parse_tree.prog_data.tvarset, parse_tree.prog_data.tvarset, parse_tree.prog_data.tvar_renaming).
:- mode tvarset_merge_renaming_without_names((builtin.in), (builtin.in), (builtin.out), (builtin.out)) is det.
:- pred valid_trace_grade_name(string).
:- mode valid_trace_grade_name((builtin.out)) is multi.
:- func worst_purity(parse_tree.prog_data.purity, parse_tree.prog_data.purity) = parse_tree.prog_data.purity.
