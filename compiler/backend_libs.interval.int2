:- module (backend_libs.interval).
:- interface.
:- use_module list.
:- use_module map.
:- use_module (parse_tree.prog_data).
:- type anchor
    --->    anchor_proc_start 
    ;       anchor_proc_end 
    ;       anchor_branch_start(backend_libs.interval.branch_construct, mdbcomp.goal_path.goal_id)
    ;       anchor_cond_then(mdbcomp.goal_path.goal_id)
    ;       anchor_branch_end(backend_libs.interval.branch_construct, mdbcomp.goal_path.goal_id)
    ;       anchor_call_site(mdbcomp.goal_path.goal_id).
:- type anchor_follow_info
    --->    anchor_follow_info(parse_tree.set_of_var.set_of_progvar, set.set(backend_libs.interval.interval_id)).
:- type branch_construct
    --->    branch_ite 
    ;       branch_disj 
    ;       branch_switch 
    ;       branch_neg 
    ;       branch_par_conj .
:- type branch_end_info
    --->    branch_end_info(((backend_libs.interval).flushed_after_branch) :: parse_tree.set_of_var.set_of_progvar, ((backend_libs.interval).accessed_after_branch) :: parse_tree.set_of_var.set_of_progvar, ((backend_libs.interval).interval_after_branch) :: backend_libs.interval.interval_id).
:- type insert_map == map.map(backend_libs.interval.anchor, list.list(backend_libs.interval.insert_spec)).
:- type insert_spec
    --->    insert_spec(hlds.hlds_goal.hlds_goal, parse_tree.set_of_var.set_of_progvar).
:- type interval_id
    --->    interval_id(int).
:- type interval_info
    --->    interval_info(((backend_libs.interval).ii_interval_params) :: backend_libs.interval.interval_params, ((backend_libs.interval).ii_flushed_later) :: parse_tree.set_of_var.set_of_progvar, ((backend_libs.interval).ii_accessed_later) :: parse_tree.set_of_var.set_of_progvar, ((backend_libs.interval).ii_branch_resume_map) :: map.map(mdbcomp.goal_path.goal_id, backend_libs.interval.resume_save_status), ((backend_libs.interval).ii_branch_end_map) :: map.map(mdbcomp.goal_path.goal_id, backend_libs.interval.branch_end_info), ((backend_libs.interval).ii_cond_end_map) :: map.map(mdbcomp.goal_path.goal_id, backend_libs.interval.interval_id), ((backend_libs.interval).ii_cur_interval) :: backend_libs.interval.interval_id, ((backend_libs.interval).ii_interval_counter) :: counter.counter, ((backend_libs.interval).ii_open_intervals) :: set.set(backend_libs.interval.interval_id), ((backend_libs.interval).ii_anchor_follow_map) :: map.map(backend_libs.interval.anchor, backend_libs.interval.anchor_follow_info), ((backend_libs.interval).ii_model_non_anchors) :: set.set(backend_libs.interval.anchor), ((backend_libs.interval).ii_interval_start) :: map.map(backend_libs.interval.interval_id, backend_libs.interval.anchor), ((backend_libs.interval).ii_interval_end) :: map.map(backend_libs.interval.interval_id, backend_libs.interval.anchor), ((backend_libs.interval).ii_interval_succ) :: map.map(backend_libs.interval.interval_id, list.list(backend_libs.interval.interval_id)), ((backend_libs.interval).ii_interval_vars) :: map.map(backend_libs.interval.interval_id, parse_tree.set_of_var.set_of_progvar), ((backend_libs.interval).ii_interval_delvars) :: map.map(backend_libs.interval.interval_id, list.list(parse_tree.set_of_var.set_of_progvar))).
:- type interval_params
    --->    interval_params(((backend_libs.interval).ip_module_info) :: hlds.hlds_module.module_info, ((backend_libs.interval).ip_var_types) :: hlds.vartypes.vartypes, ((backend_libs.interval).ip_at_most_zero_calls) :: bool.bool).
:- type maybe_needs_flush
    --->    needs_flush 
    ;       doesnt_need_flush .
:- type rename_map == map.map(parse_tree.prog_data.prog_var, parse_tree.prog_data.prog_var).
:- type resume_save_status
    --->    has_resume_save 
    ;       has_no_resume_save .
:- type save_point
    --->    save_point(backend_libs.interval.save_point_type, mdbcomp.goal_path.goal_id).
:- type save_point_type
    --->    save_point_call_site 
    ;       save_point_resume_point .
:- typeclass build_interval_info_acc(T).
:- type_representation(anchor_follow_info, is_word_aligned_ptr).
:- type_representation(branch_construct, du_repn(enum("branch_ite", "branch_disj", ["branch_switch", "branch_neg", "branch_par_conj"],  no_c_j_cs_e))).
:- type_representation(branch_end_info, is_word_aligned_ptr).
:- type_representation(insert_map, is_eqv_to(map.map(backend_libs.interval.anchor, list.list(backend_libs.interval.insert_spec)))).
:- type_representation(insert_spec, is_word_aligned_ptr).
:- type_representation(interval_id, du_repn(notag("interval_id", int,  no_c_j_cs_e))).
:- type_representation(interval_info, is_word_aligned_ptr).
:- type_representation(interval_params, is_word_aligned_ptr).
:- type_representation(maybe_needs_flush, du_repn(enum("needs_flush", "doesnt_need_flush", [],  no_c_j_cs_e))).
:- type_representation(rename_map, is_eqv_to(map.map(parse_tree.prog_data.prog_var, parse_tree.prog_data.prog_var))).
:- type_representation(resume_save_status, du_repn(enum("has_resume_save", "has_no_resume_save", [],  no_c_j_cs_e))).
:- type_representation(save_point, is_word_aligned_ptr).
:- type_representation(save_point_type, du_repn(enum("save_point_call_site", "save_point_resume_point", [],  no_c_j_cs_e))).
