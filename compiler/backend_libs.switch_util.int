:- module backend_libs.switch_util.
:- interface.
:- use_module assoc_list.
:- use_module bool.
:- use_module hlds.
:- use_module libs.
:- use_module list.
:- use_module map.
:- use_module one_or_more.
:- use_module pair.
:- use_module parse_tree.
:- use_module set.
:- use_module backend_libs.builtin_ops.
:- use_module backend_libs.rtti.
:- use_module hlds.code_model.
:- use_module hlds.hlds_data.
:- use_module hlds.hlds_goal.
:- use_module hlds.hlds_module.
:- use_module libs.globals.
:- use_module parse_tree.prog_data.
:- use_module parse_tree.prog_type.
:- use_module parse_tree.set_of_var.
:- type case_consts(Key, Rval, SeveralInfo)
    --->    all_one_soln(map.map(Key, list.list(Rval)))
    ;       some_several_solns(map.map(Key, backend_libs.switch_util.soln_consts(Rval)), SeveralInfo).
:- type case_consts_several_llds
    --->    case_consts_several_llds(parse_tree.set_of_var.set_of_progvar, bool.bool).
:- type case_id_ptags_map == map.map(hlds.hlds_goal.case_id, set.set(parse_tree.prog_data.ptag)).
:- type int_switch_info(T)
    --->    int_switch_info((backend_libs.switch_util).lower_limt :: T, (backend_libs.switch_util).upper_limit :: T, (backend_libs.switch_util).num_values :: int).
:- type maybe_int_switch_info
    --->    int_switch(backend_libs.switch_util.int_switch_info(int))
    ;       uint_switch(backend_libs.switch_util.int_switch_info(uint))
    ;       int8_switch(backend_libs.switch_util.int_switch_info(int8))
    ;       uint8_switch(backend_libs.switch_util.int_switch_info(uint8))
    ;       int16_switch(backend_libs.switch_util.int_switch_info(int16))
    ;       uint16_switch(backend_libs.switch_util.int_switch_info(uint16))
    ;       int32_switch(backend_libs.switch_util.int_switch_info(int32))
    ;       uint32_switch(backend_libs.switch_util.int_switch_info(uint32))
    ;       int64_switch(backend_libs.switch_util.int_switch_info(int64))
    ;       uint64_switch(backend_libs.switch_util.int_switch_info(uint64))
    ;       not_int_switch .
:- type need_bit_vec_check
    --->    need_bit_vec_check 
    ;       dont_need_bit_vec_check_no_gaps 
    ;       dont_need_bit_vec_check_with_gaps .
:- type need_range_check
    --->    need_range_check 
    ;       dont_need_range_check .
:- type ptag_case(CaseRep)
    --->    ptag_case_unshared(CaseRep)
    ;       ptag_case_shared(backend_libs.switch_util.shared_sectag_locn, uint, backend_libs.switch_util.stag_goal_map(CaseRep)).
:- type ptag_case_entry(CaseRep)
    --->    ptag_case_entry(parse_tree.prog_data.ptag, backend_libs.switch_util.ptag_case(CaseRep)).
:- type ptag_case_group(CaseRep)
    --->    one_or_more_whole_ptags(backend_libs.switch_util.whole_ptags_info(CaseRep))
    ;       one_shared_ptag(backend_libs.switch_util.shared_ptag_info(CaseRep)).
:- type ptag_case_list(CaseRep) == list.list(backend_libs.switch_util.ptag_case_entry(CaseRep)).
:- type ptag_case_map(CaseRep) == map.map(parse_tree.prog_data.ptag, backend_libs.switch_util.ptag_case(CaseRep)).
:- type ptag_count_map == map.map(parse_tree.prog_data.ptag, backend_libs.switch_util.ptag_sectag_info).
:- type ptag_sectag_info
    --->    ptag_sectag_info(backend_libs.rtti.sectag_locn, int).
:- type shared_ptag_info(CaseRep)
    --->    shared_ptag_info((backend_libs.switch_util).spi_ptag :: parse_tree.prog_data.ptag, (backend_libs.switch_util).spi_sectag_locn :: backend_libs.switch_util.shared_sectag_locn, (backend_libs.switch_util).spi_max_sectag :: uint, (backend_libs.switch_util).spi_num_functors :: uint, (backend_libs.switch_util).spi_sectag_to_goal_map :: backend_libs.switch_util.stag_goal_map(CaseRep), (backend_libs.switch_util).spi_goal_to_sectags_map :: backend_libs.switch_util.stag_case_map(CaseRep)).
:- type shared_sectag_locn =< backend_libs.rtti.sectag_locn
    --->    sectag_local_rest_of_word 
    ;       sectag_local_bits(uint8, uint)
    ;       sectag_remote_word 
    ;       sectag_remote_bits(uint8, uint).
:- type soln_consts(Rval)
    --->    one_soln(list.list(Rval))
    ;       several_solns(list.list(Rval), list.list(list.list(Rval))).
:- type stag_case_list(CaseRep) == assoc_list.assoc_list(CaseRep, one_or_more.one_or_more(uint)).
:- type stag_case_map(CaseRep) == map.map(CaseRep, one_or_more.one_or_more(uint)).
:- type stag_goal_list(CaseRep) == assoc_list.assoc_list(uint, CaseRep).
:- type stag_goal_map(CaseRep) == map.map(uint, CaseRep).
:- type string_hash_slot(CaseRep)
    --->    string_hash_slot(string, int, CaseRep).
:- type switch_category
    --->    ite_chain_switch 
    ;       int_max_32_switch 
    ;       int_64_switch 
    ;       string_switch 
    ;       float_switch 
    ;       tag_switch .
:- type table_size_upgrade
    --->    keep_first_size 
    ;       allow_doubling .
:- type whole_ptags_info(CaseRep)
    --->    whole_ptags_info((backend_libs.switch_util).wpi_head_ptag :: parse_tree.prog_data.ptag, (backend_libs.switch_util).wpi_tail_ptags :: list.list(parse_tree.prog_data.ptag), (backend_libs.switch_util).wpi_num_functors :: uint, (backend_libs.switch_util).wpi_goal :: CaseRep).
:- pred construct_string_hash_cases(assoc_list.assoc_list(string, CaseRep), backend_libs.switch_util.table_size_upgrade, int, map.map(int, backend_libs.switch_util.string_hash_slot(CaseRep)), backend_libs.builtin_ops.unary_op, int).
:- mode construct_string_hash_cases(builtin.in, builtin.in, builtin.out, builtin.out, builtin.out, builtin.out) is det.
:- func estimate_switch_tag_test_cost(hlds.hlds_data.cons_tag) = int.
:- pred filter_out_failing_cases_if_needed(hlds.code_model.code_model, list.list(hlds.hlds_goal.tagged_case), list.list(hlds.hlds_goal.tagged_case), parse_tree.prog_data.can_fail, parse_tree.prog_data.can_fail).
:- mode filter_out_failing_cases_if_needed(builtin.in, builtin.in, builtin.out, builtin.in, builtin.out) is det.
:- pred find_int_lookup_switch_params(hlds.hlds_module.module_info, parse_tree.prog_data.mer_type, parse_tree.prog_data.can_fail, int, int, int, int, backend_libs.switch_util.need_bit_vec_check, backend_libs.switch_util.need_range_check, int, int).
:- mode find_int_lookup_switch_params(builtin.in, builtin.in, builtin.in, builtin.in, builtin.in, builtin.in, builtin.in, builtin.out, builtin.out, builtin.out, builtin.out) is semidet.
:- pred find_switch_category(hlds.hlds_module.module_info, parse_tree.prog_data.mer_type, backend_libs.switch_util.switch_category).
:- mode find_switch_category(builtin.in, builtin.in, builtin.out) is det.
:- pred get_int_tag(hlds.hlds_data.cons_tag, int).
:- mode get_int_tag(builtin.in, builtin.out) is det.
:- pred get_ptag_counts(hlds.hlds_module.module_info, parse_tree.prog_data.mer_type, uint8, backend_libs.switch_util.ptag_count_map).
:- mode get_ptag_counts(builtin.in, builtin.in, builtin.out, builtin.out) is det.
:- pred get_string_tag(hlds.hlds_data.cons_tag, string).
:- mode get_string_tag(builtin.in, builtin.out) is det.
:- pred get_word_bits(libs.globals.globals, int, int).
:- mode get_word_bits(builtin.in, builtin.out, builtin.out) is det.
:- pred group_cases_by_ptag(backend_libs.switch_util.ptag_count_map, list.list(hlds.hlds_goal.tagged_case), pred(hlds.hlds_goal.tagged_case, CaseRep, StateA, StateA, StateB, StateB, StateC, StateC, StateD, StateD), StateA, StateA, StateB, StateB, StateC, StateC, StateD, StateD, backend_libs.switch_util.case_id_ptags_map, backend_libs.switch_util.ptag_case_map(CaseRep), list.list(backend_libs.switch_util.ptag_case_group(CaseRep))).
:- mode group_cases_by_ptag(builtin.in, builtin.in, builtin.in((pred(builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out) is det)), builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out, builtin.out, builtin.out, builtin.out) is det.
:- pred num_cons_ids_in_tagged_cases(list.list(hlds.hlds_goal.tagged_case), int, int).
:- mode num_cons_ids_in_tagged_cases(builtin.in, builtin.out, builtin.out) is det.
:- pred order_ptag_groups_by_count(list.list(backend_libs.switch_util.ptag_case_group(CaseRep)), list.list(backend_libs.switch_util.ptag_case_group(CaseRep))).
:- mode order_ptag_groups_by_count(builtin.in, builtin.out) is det.
:- pred order_ptag_specific_groups_by_value(list.list(backend_libs.switch_util.ptag_case_group(CaseRep)), list.list(backend_libs.switch_util.ptag_case_group(CaseRep))).
:- mode order_ptag_specific_groups_by_value(builtin.in, builtin.out) is det.
:- pred project_all_to_one_solution(map.map(Key, backend_libs.switch_util.soln_consts(Rval)), map.map(Key, list.list(Rval))).
:- mode project_all_to_one_solution(builtin.in, builtin.out) is semidet.
:- pred project_solns_to_rval_lists(assoc_list.assoc_list(T, backend_libs.switch_util.soln_consts(Rval)), list.list(list.list(Rval)), list.list(list.list(Rval))).
:- mode project_solns_to_rval_lists(builtin.in, builtin.in, builtin.out) is det.
:- pred string_binary_cases(list.list(hlds.hlds_goal.tagged_case), pred(hlds.hlds_goal.tagged_case, CaseRep, StateA, StateA, StateB, StateB, StateC, StateC, StateD, StateD), StateA, StateA, StateB, StateB, StateC, StateC, StateD, StateD, assoc_list.assoc_list(string, CaseRep)).
:- mode string_binary_cases(builtin.in, builtin.in((pred(builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out) is det)), builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out, builtin.in, builtin.out, builtin.out) is det.
:- func switch_density(int, int) = int.
:- pred tag_cases(hlds.hlds_module.module_info, parse_tree.prog_data.mer_type, list.list(hlds.hlds_goal.case), list.list(hlds.hlds_goal.tagged_case), backend_libs.switch_util.maybe_int_switch_info).
:- mode tag_cases(builtin.in, builtin.in, builtin.in, builtin.out, builtin.out) is det.
:- pred type_range(hlds.hlds_module.module_info, parse_tree.prog_type.type_ctor_category, parse_tree.prog_data.mer_type, int, int, int).
:- mode type_range(builtin.in, builtin.in, builtin.in, builtin.out, builtin.out, builtin.out) is semidet.
:- implementation.
:- typeclass int_tag_value(T).
