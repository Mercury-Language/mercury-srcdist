:- module (libs.tree).
:- interface.
:- import_module bool.
:- import_module list.
:- type tree(T)
	--->	empty 
	;	node(T)
	;	tree(((libs.tree).tree(T)), ((libs.tree).tree(T)))
	;	tree_list((list.list(((libs.tree).tree(T))))).
:- func flatten(((libs.tree).tree(T))) = (list.list(T)).
:- pred flatten(((libs.tree).tree(T)), (list.list(T))).
:- mode flatten((builtin.in), (builtin.out)) is det.
:- pred foldl(pred(T, A, A), ((libs.tree).tree(T)), A, A).
:- mode foldl(builtin.in((pred((builtin.in), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.in), (builtin.out)) is det.
:- func is_empty(((libs.tree).tree(T))) = (bool.bool).
:- pred is_empty(((libs.tree).tree(T))).
:- mode is_empty((builtin.in)) is semidet.
:- func map(((func T) = U), ((libs.tree).tree(T))) = ((libs.tree).tree(U)).
:- pred map(pred(T, U), ((libs.tree).tree(T)), ((libs.tree).tree(U))).
:- mode map(builtin.in((pred((builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out)) is det.
:- pred map_foldl(pred(T, U, A, A), ((libs.tree).tree(T)), ((libs.tree).tree(U)), A, A).
:- mode map_foldl(builtin.in((pred((builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- pred map_foldl2(pred(T, U, A, A, B, B), ((libs.tree).tree(T)), ((libs.tree).tree(U)), A, A, B, B).
:- mode map_foldl2(builtin.in((pred((builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det)), (builtin.in), (builtin.out), (builtin.in), (builtin.out), (builtin.in), (builtin.out)) is det.
:- func tree_of_lists_is_empty(((libs.tree).tree((list.list(T))))) = (bool.bool).
:- pred tree_of_lists_is_empty(((libs.tree).tree((list.list(T))))).
:- mode tree_of_lists_is_empty((builtin.in)) is semidet.
