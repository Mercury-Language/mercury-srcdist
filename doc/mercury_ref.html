<html lang="en">
<head>
<title>The Mercury Language Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The Mercury Language Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
This file documents the Mercury programming language, version 11.07.2.

   <p>Copyright (C) 1995-2012 The University of Melbourne.

   <p>Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   <p>Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   <p>Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">The Mercury Language Reference Manual, version 11.07.2</a>
<li><a name="toc_Introduction" href="#Introduction">1 Introduction</a>
<li><a name="toc_Syntax" href="#Syntax">2 Syntax</a>
<ul>
<li><a href="#Syntax-Overview">2.1 Syntax overview</a>
<li><a href="#Tokens">2.2 Tokens</a>
<li><a href="#Terms">2.3 Terms</a>
<li><a href="#Builtin-Operators">2.4 Builtin Operators</a>
<li><a href="#Items">2.5 Items</a>
<li><a href="#Declarations">2.6 Declarations</a>
<li><a href="#Facts">2.7 Facts</a>
<li><a href="#Rules">2.8 Rules</a>
<li><a href="#Goals">2.9 Goals</a>
<li><a href="#State-variables">2.10 State variables</a>
<li><a href="#DCG_002drules">2.11 DCG-rules</a>
<li><a href="#DCG_002dgoals">2.12 DCG-goals</a>
<li><a href="#Data_002dterms">2.13 Data-terms</a>
<ul>
<li><a href="#Data_002dfunctors">2.13.1 Data-functors</a>
<li><a href="#Record-syntax">2.13.2 Record syntax</a>
<li><a href="#Unification-expressions">2.13.3 Unification expressions</a>
<li><a href="#Conditional-expressions">2.13.4 Conditional expressions</a>
<li><a href="#Lambda-expressions">2.13.5 Lambda expressions</a>
<li><a href="#Higher_002dorder-function-applications">2.13.6 Higher-order function applications</a>
<li><a href="#Explicit-type-qualification">2.13.7 Explicit type qualification</a>
</li></ul>
<li><a href="#Variable-scoping">2.14 Variable scoping</a>
<li><a href="#Implicit-quantification">2.15 Implicit quantification</a>
<li><a href="#Elimination-of-double-negation">2.16 Elimination of double negation</a>
</li></ul>
<li><a name="toc_Types" href="#Types">3 Types</a>
<ul>
<li><a href="#Builtin-types">3.1 Builtin types</a>
<li><a href="#User_002ddefined-types">3.2 User-defined types</a>
<ul>
<li><a href="#Discriminated-unions">3.2.1 Discriminated unions</a>
<li><a href="#Equivalence-types">3.2.2 Equivalence types</a>
<li><a href="#Abstract-types">3.2.3 Abstract types</a>
</li></ul>
<li><a href="#Predicate-and-function-type-declarations">3.3 Predicate and function type declarations</a>
<li><a href="#Field-access-functions">3.4 Field access functions</a>
<ul>
<li><a href="#Field-selection">3.4.1 Field selection</a>
<li><a href="#Field-update">3.4.2 Field update</a>
<li><a href="#User_002dsupplied-field-access-function-declarations">3.4.3 User-supplied field access function declarations</a>
<li><a href="#Field-access-examples">3.4.4 Field access examples</a>
</li></ul>
</li></ul>
<li><a name="toc_Modes" href="#Modes">4 Modes</a>
<ul>
<li><a href="#Insts-modes-and-mode-definitions">4.1 Insts, modes, and mode definitions</a>
<li><a href="#Predicate-and-function-mode-declarations">4.2 Predicate and function mode declarations</a>
<li><a href="#Constrained-polymorphic-modes">4.3 Constrained polymorphic modes</a>
<li><a href="#Different-clauses-for-different-modes">4.4 Different clauses for different modes</a>
</li></ul>
<li><a name="toc_Unique-modes" href="#Unique-modes">5 Unique modes</a>
<ul>
<li><a href="#Destructive-update">5.1 Destructive update</a>
<li><a href="#Backtrackable-destructive-update">5.2 Backtrackable destructive update</a>
<li><a href="#Limitations-of-the-current-implementation">5.3 Limitations of the current implementation</a>
</li></ul>
<li><a name="toc_Determinism" href="#Determinism">6 Determinism</a>
<ul>
<li><a href="#Determinism-categories">6.1 Determinism categories</a>
<li><a href="#Determinism-checking-and-inference">6.2 Determinism checking and inference</a>
<li><a href="#Replacing-compile_002dtime-checking-with-run_002dtime-checking">6.3 Replacing compile-time checking with run-time checking</a>
<li><a href="#Interfacing-nondeterministic-code-with-the-real-world">6.4 Interfacing nondeterministic code with the real world</a>
<li><a href="#Committed-choice-nondeterminism">6.5 Committed choice nondeterminism</a>
</li></ul>
<li><a name="toc_User_002ddefined-equality-and-comparison" href="#User_002ddefined-equality-and-comparison">7 User-defined equality and comparison</a>
<li><a name="toc_Higher_002dorder" href="#Higher_002dorder">8 Higher-order programming</a>
<ul>
<li><a href="#Creating-higher_002dorder-terms">8.1 Creating higher-order terms</a>
<li><a href="#Calling-higher_002dorder-terms">8.2 Calling higher-order terms</a>
<li><a href="#Higher_002dorder-modes">8.3 Higher-order modes</a>
</li></ul>
<li><a name="toc_Modules" href="#Modules">9 Modules</a>
<ul>
<li><a href="#The-module-system">9.1 The module system</a>
<li><a href="#An-example-module">9.2 An example module.</a>
<li><a href="#Sub_002dmodules">9.3 Sub-modules</a>
<ul>
<li><a href="#Nested-sub_002dmodules">9.3.1 Nested sub-modules</a>
<li><a href="#Separate-sub_002dmodules">9.3.2 Separate sub-modules</a>
<li><a href="#Visibility-rules">9.3.3 Visibility rules</a>
<li><a href="#Implementation-bugs-and-limitations">9.3.4 Implementation bugs and limitations</a>
</li></ul>
<li><a href="#Module-initialisation">9.4 Module initialisation</a>
<li><a href="#Module-finalisation">9.5 Module finalisation</a>
<li><a href="#Module_002dlocal-mutable-variables">9.6 Module-local mutable variables</a>
</li></ul>
<li><a name="toc_Type-classes" href="#Type-classes">10 Type classes</a>
<ul>
<li><a href="#Typeclass-declarations">10.1 Typeclass declarations</a>
<li><a href="#Instance-declarations">10.2 Instance declarations</a>
<li><a href="#Abstract-typeclass-declarations">10.3 Abstract typeclass declarations</a>
<li><a href="#Abstract-instance-declarations">10.4 Abstract instance declarations</a>
<li><a href="#Type-class-constraints-on-predicates-and-functions">10.5 Type class constraints on predicates and functions</a>
<li><a href="#Type-class-constraints-on-type-class-declarations">10.6 Type class constraints on type class declarations</a>
<li><a href="#Type-class-constraints-on-instance-declarations">10.7 Type class constraints on instance declarations</a>
<li><a href="#Functional-dependencies">10.8 Functional dependencies</a>
</li></ul>
<li><a name="toc_Existential-types" href="#Existential-types">11 Existential types</a>
<ul>
<li><a href="#Existentially-typed-predicates-and-functions">11.1 Existentially typed predicates and functions</a>
<ul>
<li><a href="#Syntax-for-explicit-type-quantifiers">11.1.1 Syntax for explicit type quantifiers</a>
<li><a href="#Semantics-of-type-quantifiers">11.1.2 Semantics of type quantifiers</a>
<li><a href="#Examples-of-correct-code-using-type-quantifiers">11.1.3 Examples of correct code using type quantifiers</a>
<li><a href="#Examples-of-incorrect-code-using-type-quantifiers">11.1.4 Examples of incorrect code using type quantifiers</a>
</li></ul>
<li><a href="#Existential-class-constraints">11.2 Existential class constraints</a>
<li><a href="#Existentially-typed-data-types">11.3 Existentially typed data types</a>
<li><a href="#Some-idioms-using-existentially-quantified-types">11.4 Some idioms using existentially quantified types</a>
</li></ul>
<li><a name="toc_Exception-handling" href="#Exception-handling">12 Exception handling</a>
<li><a name="toc_Semantics" href="#Semantics">13 Semantics</a>
<li><a name="toc_Foreign-language-interface" href="#Foreign-language-interface">14 Foreign language interface</a>
<ul>
<li><a href="#Calling-foreign-code-from-Mercury">14.1 Calling foreign code from Mercury</a>
<ul>
<li><a href="#pragma-foreign_005fproc">14.1.1 pragma foreign_proc</a>
<li><a href="#Foreign-code-attributes">14.1.2 Foreign code attributes</a>
</li></ul>
<li><a href="#Calling-Mercury-from-foreign-code">14.2 Calling Mercury from foreign code</a>
<li><a href="#Data-passing-conventions">14.3 Data passing conventions</a>
<ul>
<li><a href="#C-data-passing-conventions">14.3.1 C data passing conventions</a>
<li><a href="#C_0023-data-passing-conventions">14.3.2 C# data passing conventions</a>
<li><a href="#Java-data-passing-conventions">14.3.3 Java data passing conventions</a>
<li><a href="#Erlang-data-passing-conventions">14.3.4 Erlang data passing conventions</a>
</li></ul>
<li><a href="#Using-foreign-types-from-Mercury">14.4 Using foreign types from Mercury</a>
<li><a href="#Using-Mercury-enumerations-in-foreign-code">14.5 Using Mercury enumerations in foreign code</a>
<li><a href="#Using-foreign-enumerations-in-Mercury-code">14.6 Using foreign enumerations in Mercury code</a>
<li><a href="#Adding-foreign-declarations">14.7 Adding foreign declarations</a>
<li><a href="#Adding-foreign-definitions">14.8 Adding foreign definitions</a>
<li><a href="#Language-specific-bindings">14.9 Language specific bindings</a>
<ul>
<li><a href="#Interfacing-with-C">14.9.1 Interfacing with C</a>
<ul>
<li><a href="#Using-pragma-foreign_005ftype-for-C">14.9.1.1 Using pragma foreign_type for C</a>
<li><a href="#Using-pragma-foreign_005fexport_005fenum-for-C">14.9.1.2 Using pragma foreign_export_enum for C</a>
<li><a href="#Using-pragma-foreign_005fenum-for-C">14.9.1.3 Using pragma foreign_enum for C</a>
<li><a href="#Using-pragma-foreign_005fproc-for-C">14.9.1.4 Using pragma foreign_proc for C</a>
<li><a href="#Using-pragma-foreign_005fexport-for-C">14.9.1.5 Using pragma foreign_export for C</a>
<li><a href="#Using-pragma-foreign_005fdecl-for-C">14.9.1.6 Using pragma foreign_decl for C</a>
<li><a href="#Using-pragma-foreign_005fcode-for-C">14.9.1.7 Using pragma foreign_code for C</a>
<li><a href="#Memory-management-for-C">14.9.1.8 Memory management for C</a>
<li><a href="#Linking-with-C-object-files">14.9.1.9 Linking with C object files</a>
</li></ul>
<li><a href="#Interfacing-with-C_0023">14.9.2 Interfacing with C#</a>
<ul>
<li><a href="#Using-pragma-foreign_005ftype-for-C_0023">14.9.2.1 Using pragma foreign_type for C#</a>
<li><a href="#Using-pragma-foreign_005fexport_005fenum-for-C_0023">14.9.2.2 Using pragma foreign_export_enum for C#</a>
<li><a href="#Using-pragma-foreign_005fenum-for-C_0023">14.9.2.3 Using pragma foreign_enum for C#</a>
<li><a href="#Using-pragma-foreign_005fproc-for-C_0023">14.9.2.4 Using pragma foreign_proc for C#</a>
<li><a href="#Using-pragma-foreign_005fexport-for-C_0023">14.9.2.5 Using pragma foreign_export for C#</a>
<li><a href="#Using-pragma-foreign_005fdecl-for-C_0023">14.9.2.6 Using pragma foreign_decl for C#</a>
<li><a href="#Using-pragma-foreign_005fcode-for-C_0023">14.9.2.7 Using pragma foreign_code for C#</a>
</li></ul>
<li><a href="#Interfacing-with-Java">14.9.3 Interfacing with Java</a>
<ul>
<li><a href="#Using-pragma-foreign_005ftype-for-Java">14.9.3.1 Using pragma foreign_type for Java</a>
<li><a href="#Using-pragma-foreign_005fexport_005fenum-for-Java">14.9.3.2 Using pragma foreign_export_enum for Java</a>
<li><a href="#Using-pragma-foreign_005fenum-for-Java">14.9.3.3 Using pragma foreign_enum for Java</a>
<li><a href="#Using-pragma-foreign_005fproc-for-Java">14.9.3.4 Using pragma foreign_proc for Java</a>
<li><a href="#Using-pragma-foreign_005fexport-for-Java">14.9.3.5 Using pragma foreign_export for Java</a>
<li><a href="#Using-pragma-foreign_005fdecl-for-Java">14.9.3.6 Using pragma foreign_decl for Java</a>
<li><a href="#Using-pragma-foreign_005fcode-for-Java">14.9.3.7 Using pragma foreign_code for Java</a>
</li></ul>
<li><a href="#Interfacing-with-Erlang">14.9.4 Interfacing with Erlang</a>
<ul>
<li><a href="#Using-pragma-foreign_005ftype-for-Erlang">14.9.4.1 Using pragma foreign_type for Erlang</a>
<li><a href="#Using-pragma-foreign_005fproc-for-Erlang">14.9.4.2 Using pragma foreign_proc for Erlang</a>
<li><a href="#Using-pragma-foreign_005fexport-for-Erlang">14.9.4.3 Using pragma foreign_export for Erlang</a>
<li><a href="#Using-pragma-foreign_005fdecl-for-Erlang">14.9.4.4 Using pragma foreign_decl for Erlang</a>
<li><a href="#Using-pragma-foreign_005fcode-for-Erlang">14.9.4.5 Using pragma foreign_code for Erlang</a>
</li></ul>
</li></ul>
</li></ul>
<li><a name="toc_Impurity" href="#Impurity">15 Impurity declarations</a>
<ul>
<li><a href="#Purity-levels">15.1 Choosing the right level of purity</a>
<li><a href="#Purity-ordering">15.2 Purity ordering</a>
<li><a href="#Impurity-semantics">15.3 Semantics</a>
<li><a href="#Declaring-impurity">15.4 Declaring impure functions and predicates</a>
<li><a href="#Impure-goals">15.5 Marking a goal as impure</a>
<li><a href="#Promising-purity">15.6 Promising that a predicate is pure</a>
<li><a href="#Impurity-Example">15.7 An example using impurity</a>
<li><a href="#Higher_002dorder-impurity">15.8 Using impurity with higher-order code</a>
<ul>
<li><a href="#Purity-annotations-on-higher_002dorder-types">15.8.1 Purity annotations on higher-order types</a>
<li><a href="#Purity-annotations-on-lambda-expressions">15.8.2 Purity annotations on lambda expressions</a>
<li><a href="#Purity-annotations-on-higher_002dorder-calls">15.8.3 Purity annotations on higher-order calls</a>
</li></ul>
</li></ul>
<li><a name="toc_Solver-types" href="#Solver-types">16 Solver types</a>
<ul>
<li><a href="#The-any-inst">16.1 The &lsquo;<samp><span class="samp">any</span></samp>&rsquo; inst</a>
<li><a href="#Abstract-solver-type-declarations">16.2 Abstract solver type declarations</a>
<li><a href="#Solver-type-definitions">16.3 Solver type definitions</a>
<li><a href="#Implementing-solver-types">16.4 Implementing solver types</a>
<li><a href="#Solver-types-and-negated-contexts">16.5 Solver types and negated contexts</a>
</li></ul>
<li><a name="toc_Trace-goals" href="#Trace-goals">17 Trace goals</a>
<li><a name="toc_Pragmas" href="#Pragmas">18 Pragmas</a>
<ul>
<li><a href="#Inlining">18.1 Inlining</a>
<li><a href="#Type-specialization">18.2 Type specialization</a>
<ul>
<li><a href="#Syntax-and-semantics-of-type-specialization-pragmas">18.2.1 Syntax and semantics of type specialization pragmas</a>
<li><a href="#When-to-use-type-specialization">18.2.2 When to use type specialization</a>
<li><a href="#Implementation-specific-details">18.2.3 Implementation specific details</a>
</li></ul>
<li><a href="#Obsolescence">18.3 Obsolescence</a>
<li><a href="#No-determinism-warnings">18.4 No determinism warnings</a>
<li><a href="#Source-file-name">18.5 Source file name</a>
</li></ul>
<li><a name="toc_Implementation_002ddependent-extensions" href="#Implementation_002ddependent-extensions">19 Implementation-dependent extensions</a>
<ul>
<li><a href="#Fact-tables">19.1 Fact tables</a>
<li><a href="#Tabled-evaluation">19.2 Tabled evaluation</a>
<li><a href="#Termination-analysis">19.3 Termination analysis</a>
<li><a href="#Feature-sets">19.4 Feature sets</a>
<li><a href="#Trailing">19.5 Trailing</a>
<ul>
<li><a href="#Choice-points">19.5.1 Choice points</a>
<li><a href="#Value-trailing">19.5.2 Value trailing</a>
<li><a href="#Function-trailing">19.5.3 Function trailing</a>
<li><a href="#Delayed-goals-and-floundering">19.5.4 Delayed goals and floundering</a>
<li><a href="#Avoiding-redundant-trailing">19.5.5 Avoiding redundant trailing</a>
</li></ul>
</li></ul>
<li><a name="toc_Bibliography" href="#Bibliography">20 Bibliography</a>
<ul>
<li><a href="#_005b1_005d">[1]</a>
<li><a href="#_005b2_005d">[2]</a>
<li><a href="#_005b3_005d">[3]</a>
<li><a href="#_005b4_005d">[4]</a>
<li><a href="#_005b5_005d">[5]</a>
</li></ul>
</li></ul>
</div>

<!--  -->
<div class="node">
<a name="Top"></a>
<p><hr>
Up:&nbsp;<a rel="up" accesskey="u" href="#g_t_0028mercury_0029">(mercury)</a>

</div>

<h2 class="unnumbered">The Mercury Language Reference Manual, version 11.07.2</h2>

<!-- XXX Move to after Determinism -->
<!-- * Assertions::        Assertion declarations allow you to declare laws -->
<!-- that hold. -->
<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>:       A brief introduction to Mercury. 
<li><a accesskey="2" href="#Syntax">Syntax</a>:             Mercury's syntax is similar to ISO Prolog. 
<li><a accesskey="3" href="#Types">Types</a>:              Mercury has a strong parametric polymorphic type system. 
<li><a accesskey="4" href="#Modes">Modes</a>:              Modes allow you to specify the direction of data flow. 
<li><a accesskey="5" href="#Unique-modes">Unique modes</a>:       Unique modes allow you to specify when there is only one
                      reference to a particular value, so the compiler can
                      safely use destructive update to modify that value. 
<li><a accesskey="6" href="#Determinism">Determinism</a>:        Determinism declarations let you specify that a predicate
                      should never fail or should never succeed more than once. 
<li><a accesskey="7" href="#User_002ddefined-equality-and-comparison">User-defined equality and comparison</a>
                      User-defined types can have user-defined equality and
                      comparison predicates. 
<li><a accesskey="8" href="#Higher_002dorder">Higher-order</a>:       Mercury supports higher-order predicates and functions,
                      with closures, lambda expressions, and currying. 
<li><a accesskey="9" href="#Modules">Modules</a>:            Modules allow you to divide a program into smaller parts. 
<li><a href="#Type-classes">Type classes</a>:       Constrained polymorphism. 
<li><a href="#Existential-types">Existential types</a>:  Support for data abstraction and heterogeneous
                      collections. 
<li><a href="#Exception-handling">Exception handling</a>:  Catching exceptions to recover from exceptional
                      situations. 
<li><a href="#Semantics">Semantics</a>:          Declarative and operational semantics of Mercury
                      programs. 
<li><a href="#Foreign-language-interface">Foreign language interface</a>:  Calling code written in other programming
                      languages from Mercury code
<li><a href="#Impurity">Impurity</a>:           Users can write impure Mercury code. 
<li><a href="#Solver-types">Solver types</a>:       Support for constraint logic programming
<li><a href="#Trace-goals">Trace goals</a>:        Trace goals allow programmers to add debugging and
                      logging code to their programs. 
<li><a href="#Pragmas">Pragmas</a>:            Various compiler directives, used for example to
                      control optimization. 
<li><a href="#Implementation_002ddependent-extensions">Implementation-dependent extensions</a>
                      The University of Melbourne Mercury implementation
                      supports several extensions to the Mercury language. 
<li><a href="#Bibliography">Bibliography</a>:       References for further reading. 
</ul>

<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Syntax">Syntax</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction</h2>

<p>Mercury is a new general-purpose programming language, designed
and implemented by a small group of researchers at the University
of Melbourne, Australia.  Mercury is based on the paradigm of
purely declarative programming, and was designed to be
useful for the development of large and robust &ldquo;real-world&rdquo; applications. 
It improves on existing logic programming languages by providing
increased productivity, reliability and efficiency, and by avoiding the
need for non-logical program constructs.  Mercury provides the
traditional logic programming syntax, but also allows the
syntactic convenience of user-defined functions, smoothly integrating
logic and functional programming into a single paradigm.

   <p>Mercury requires programmers to supply
type, mode and determinism declarations for the predicates
and functions they write. 
The compiler checks these declarations,
and rejects the program if it cannot prove
that every predicate or function satisfies its declarations. 
This improves reliability,
since many kinds of errors simply cannot happen
in successfully compiled Mercury programs. 
It also improves productivity,
since the compiler pinpoints many errors
that would otherwise require manual debugging to locate. 
The fact that declarations are checked by the compiler
makes them much more useful than comments
to anyone who has to maintain the program. 
The compiler also exploits the guaranteed correctness of the declarations
for significantly improving the efficiency of the code it generates.

   <p>To facilitate programming-in-the-large, to allow separate compilation,
and to support encapsulation, Mercury has a simple module system. 
Mercury's standard library has a variety of pre-defined modules
for common programming tasks &mdash; see the Mercury Library Reference Manual.

<div class="node">
<a name="Syntax"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Types">Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Syntax</h2>

<ul class="menu">
<li><a accesskey="1" href="#Syntax-Overview">Syntax Overview</a>
<li><a accesskey="2" href="#Tokens">Tokens</a>
<li><a accesskey="3" href="#Terms">Terms</a>
<li><a accesskey="4" href="#Builtin-Operators">Builtin Operators</a>
<li><a accesskey="5" href="#Items">Items</a>
<li><a accesskey="6" href="#Declarations">Declarations</a>
<li><a accesskey="7" href="#Facts">Facts</a>
<li><a accesskey="8" href="#Rules">Rules</a>
<li><a accesskey="9" href="#Goals">Goals</a>
<li><a href="#State-variables">State variables</a>
<li><a href="#DCG_002drules">DCG-rules</a>
<li><a href="#DCG_002dgoals">DCG-goals</a>
<li><a href="#Data_002dterms">Data-terms</a>
<li><a href="#Variable-scoping">Variable scoping</a>
<li><a href="#Implicit-quantification">Implicit quantification</a>
<li><a href="#Elimination-of-double-negation">Elimination of double negation</a>
</ul>

<div class="node">
<a name="Syntax-Overview"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tokens">Tokens</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.1 Syntax overview</h3>

<p>Mercury's syntax is similar to the syntax of Prolog, with some
additional declarations for types, modes, determinism, the module system,
and pragmas, and with the distinction that function symbols may stand also
for invocations of user-defined functions as well as for data constructors.

   <p>A Mercury program consists of a set of modules.  Each module is a file
containing a sequence of items (declarations and clauses).  Each item
is a term followed by a period.  Each term is composed of a sequence
of tokens, and each token is composed of a sequence of characters. 
Like Prolog, Mercury has the Definite Clause Grammar (DCG) notation
for clauses.

<div class="node">
<a name="Tokens"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Terms">Terms</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Syntax-Overview">Syntax Overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.2 Tokens</h3>

<p>Tokens in Mercury are the same as in ISO Prolog. 
The only differences are the &lsquo;<samp><span class="samp">#</span><var>line</var></samp>&rsquo; token, which
is used as a line number directive (see below) and the
backquote (&lsquo;<samp><span class="samp">`</span></samp>&rsquo;) token.

   <p>The different tokens are as follows.  Tokens may be separated by
whitespace or line number directives.

     <dl>
<dt><em>line number directive</em><dd>A line number directive consists of the character &lsquo;<samp><span class="samp">#</span></samp>&rsquo;,
a positive integer specifying the line number, and then a newline. 
A &lsquo;<samp><span class="samp">#</span><var>line</var></samp>&rsquo; directive's only role is to
specifying the line number; it is otherwise ignored by the syntax. 
Line number directives may occur anywhere a token may occur. 
They are used in conjunction with the &lsquo;<samp><span class="samp">pragma source_file</span></samp>&rsquo;
declaration to indicate that the Mercury code following was
generated by another tool; they serve to associate each line
in the Mercury code with the source file name and line number of
the original source from which the Mercury code was derived,
so that the Mercury compiler can issue more informative error
messages using the original source code locations. 
A &lsquo;<samp><span class="samp">#</span><var>line</var></samp>&rsquo; directive specifies the line number
for the immediately following line.  Line numbers for lines
after that are incremented as usual, so the second line
after a &lsquo;<samp><span class="samp">#100</span></samp>&rsquo; directive would be considered to be line
number 101.

     <br><dt><em>string</em><dd>A string is a sequence of characters enclosed in double quotes (<code>"</code>).

     <p>Within a string, two adjacent double quotes stand for a single double quote. 
For example, the string &lsquo;<samp><span class="samp"> """" </span></samp>&rsquo; is a string of length one, containing
a single double quote: the outermost pair of double quotes encloses the
string, and the innermost pair stand for a single double quote.

     <p>Strings may also contain backslash escapes.  &lsquo;<samp><span class="samp">\a</span></samp>&rsquo; stands for &ldquo;alert&rdquo;
(a beep character), &lsquo;<samp><span class="samp">\b</span></samp>&rsquo; for backspace, &lsquo;<samp><span class="samp">\r</span></samp>&rsquo; for carriage-return,
&lsquo;<samp><span class="samp">\f</span></samp>&rsquo; for form-feed, &lsquo;<samp><span class="samp">\t</span></samp>&rsquo; for tab, &lsquo;<samp><span class="samp">\n</span></samp>&rsquo; for newline,
&lsquo;<samp><span class="samp">\v</span></samp>&rsquo; for vertical-tab.  An escaped backslash, single-quote, or
double-quote stands for itself.

     <p>The sequence &lsquo;<samp><span class="samp">\x</span></samp>&rsquo; introduces
a hexadecimal escape; it must be followed by a sequence of hexadecimal
digits and then a closing backslash.  It is replaced
with the character whose character code is identified by the hexadecimal
number.  Similarly, a backslash followed by an octal digit is the
beginning of an octal escape; as with hexadecimal escapes, the sequence
of octal digits must be terminated with a closing backslash.

     <p>The sequence &lsquo;<samp><span class="samp">\u</span></samp>&rsquo; or &lsquo;<samp><span class="samp">\U</span></samp>&rsquo; can be used to escape Unicode characters. 
&lsquo;<samp><span class="samp">\u</span></samp>&rsquo; must be followed by the Unicode character code expressed as four
hexadecimal digits. 
&lsquo;<samp><span class="samp">\U</span></samp>&rsquo; must be followed by the Unicode character code expressed as eight
hexadecimal digits.  The highest allowed value is &lsquo;<samp><span class="samp">\U0010FFFF</span></samp>&rsquo;.

     <p>A backslash followed immediately by a newline is deleted; thus an
escaped newline can be used to continue a string over more than one
source line.  (String literals may also contain embedded newlines.)

     <br><dt><em>name</em><dd>A name is either an unquoted name or a quoted name. 
An unquoted name is a lowercase letter followed by zero or more letters,
underscores, and digits.  A quoted name is any sequence of zero or more
characters enclosed in single quotes (<code>'</code>). 
Within a quoted name, two adjacent single quotes stand for a single
single quote.  Quoted names can also contain
backslash escapes of the same form as for strings.

     <br><dt><em>variable</em><dd>A variable is an uppercase letter or underscore followed by zero or
more letters, underscores, and digits. 
A variable token consisting of single underscore is treated
specially: each instance of &lsquo;<samp><span class="samp">_</span></samp>&rsquo; denotes a distinct variable. 
(In addition, variables starting with an underscore are presumed to be
&ldquo;don't-care&rdquo; variables; the compiler will issue a warning if a
variable that does not start with an underscore occurs only once, or if
a variable starting with an underscore occurs more than once in the
same scope.)

     <br><dt><em>integer</em><dd>An integer is either a decimal, binary, octal, hexadecimal, or character-code
literal. 
A decimal literal is any sequence of decimal digits. 
A binary literal is &lsquo;<samp><span class="samp">0b</span></samp>&rsquo; followed by any sequence of binary digits. 
An octal literal is &lsquo;<samp><span class="samp">0o</span></samp>&rsquo; followed by any sequence of octal digits. 
A hexadecimal literal is &lsquo;<samp><span class="samp">0x</span></samp>&rsquo; followed by any sequence of hexadecimal
digits. 
A character-code literal is &lsquo;<samp><span class="samp">0'</span></samp>&rsquo; followed by any single character.

     <br><dt><em>float</em><dd>A floating point literal consists of a sequence of decimal digits,
a decimal point and a sequence of digits (the fraction part), and
the letter &lsquo;<samp><span class="samp">E</span></samp>&rsquo; (or &lsquo;<samp><span class="samp">e</span></samp>&rsquo;), an optional sign (&lsquo;<samp><span class="samp">+</span></samp>&rsquo; or &lsquo;<samp><span class="samp">-</span></samp>&rsquo;),
and then another sequence of decimal digits (the exponent). 
The fraction part or the exponent (but not both) may be omitted.

     <br><dt><em>implementation_defined_literal</em><dd>An implementation-defined literal consists of a dollar sign (<code>$</code>)
followed by an unquoted name.

     <br><dt><em>open_ct</em><dd>A left parenthesis, &lsquo;<samp><span class="samp">(</span></samp>&rsquo;, that is not preceded by whitespace.

     <br><dt><em>open</em><dd>A left parenthesis, &lsquo;<samp><span class="samp">(</span></samp>&rsquo;, that is preceded by whitespace.

     <br><dt><em>close</em><dd>A right parenthesis, &lsquo;<samp><span class="samp">)</span></samp>&rsquo;.

     <br><dt><em>open_list</em><dd>A left square bracket, &lsquo;<samp><span class="samp">[</span></samp>&rsquo;.

     <br><dt><em>close_list</em><dd>A right square bracket, &lsquo;<samp><span class="samp">]</span></samp>&rsquo;.

     <br><dt><em>open_curly</em><dd>A left curly bracket, &lsquo;<samp><span class="samp">{</span></samp>&rsquo;.

     <br><dt><em>close_curly</em><dd>A right curly bracket, &lsquo;<samp><span class="samp">}</span></samp>&rsquo;.

     <br><dt><em>ht_sep</em><dd>A &ldquo;head-tail separator&rdquo;, i.e. a vertical bar, &lsquo;<samp><span class="samp">|</span></samp>&rsquo;.

     <br><dt><em>comma</em><dd>A comma, &lsquo;<samp><span class="samp">,</span></samp>&rsquo;.

     <br><dt><em>end</em><dd>A full stop (period), &lsquo;<samp><span class="samp">.</span></samp>&rsquo;.

     <br><dt><em>eof</em><dd>The end of file.

   </dl>

<div class="node">
<a name="Terms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Builtin-Operators">Builtin Operators</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tokens">Tokens</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.3 Terms</h3>

<p>Syntactically, terms in Mercury are exactly the same as in ISO Prolog,
except that as extensions we permit higher-order terms and the
introduction of infix operators by the use of grave accents (backquotes),
as described below,
and we support an extended set of builtin operators.  See <a href="#Builtin-Operators">Builtin Operators</a>. 
Also, the constructor for list terms in Mercury is <code>[|]/2</code>, not
<code>./2</code> as in Prolog.

   <p>Note, however, that the meaning of some terms in Mercury is
different to that in Prolog.  See <a href="#Data_002dterms">Data-terms</a>.

   <p>A term is either a variable or a functor.

   <p>A functor is an integer, a float, a string, a name, a compound term,
or a higher-order term.

   <p>A compound term is a simple compound term, a list term, a tuple term,
an operator term, or a parenthesized term.

   <p>A simple compound term is a name followed without any intervening
whitespace by an open parenthesis (i.e. an open_ct token),
a sequence of argument terms separated by commas, and a close
parenthesis.

   <p>A list term is an open square bracket (i.e. an open_list token)
followed by a sequence of argument terms separated by commas,
optionally followed by a vertical bar (i.e. a ht_sep token)
followed by a term, followed by a close square bracket (i.e. a
close_list token).  An empty list term is an open_list token
followed by a close_list token.  List terms are parsed as follows:
<pre class="example">     parse('[' ']') = [].
     parse('[' List) = parse_list(List).
     parse_list(Head ',' Tail) = '[|]'(parse_term(Head), parse_list(Tail)).
     parse_list(Head '|' Tail ']') = '[|]'(parse_term(Head), parse_term(Tail)).
     parse_list(Head ']') = '[|]'(parse_term(Head), []).
</pre>
   <p>The following terms are all equivalent:
<pre class="example">     [1, 2, 3]
     [1, 2, 3 | []]
     [1, 2 | [3]]
     [1 | [2, 3]]
     '[|]'(1, '[|]'(2, '[|]'(3, [])))
</pre>
   <p>A tuple term is a left curly bracket (i.e. an open_curly token)
followed by a sequence of argument terms separated by commas,
and a right curly bracket.  For example, <code>{1, '2', "three"}</code>
is a valid tuple term.

   <p>An operator term is a term specified using operator notation, as in Prolog. 
Operators can also be formed by enclosing a name, a module qualified name
(see <a href="#The-module-system">The module system</a>), or a variable between grave accents (backquotes). 
Any name or variable may be used as an operator in this way. 
If <var>fun</var> is a variable or name,
then a term of the form <var>X</var><code> `</code><var>fun</var><code>` </code><var>Y</var> is equivalent to
<var>fun</var><code>(</code><var>X</var><code>, </code><var>Y</var><code>)</code>. The operator is left associative
and binds more tightly than every operator other than &lsquo;<samp><span class="samp">^</span></samp>&rsquo;
(see <a href="#Builtin-Operators">Builtin Operators</a>).

   <p>A parenthesized term is just an open parenthesis
followed by a term and a close parenthesis.

   <p>A higher-order term is a &ldquo;closure&rdquo; term, which can be any term
other than a name or an operator term, followed without
any intervening whitespace by an open parenthesis (i.e. an open_ct token),
a sequence of argument terms separated by commas, and a close
parenthesis.  A higher-order term is equivalent to a simple compound term
whose functor is the empty name, and whose arguments are the
closure term followed by the argument terms of the higher-order term. 
That is, a term such as <code>Term(Arg1, ..., ArgN)</code> is
parsed as <code>''(Term, Arg1, ..., ArgN)</code>. 
Note that the closure term can be a parenthesized
term; for example, <code>(Term ^ FieldName)(Arg1, Arg2)</code>
is a higher-order term, and so it gets parsed as
if it were <code>''((Term ^ FieldName), Arg1, Arg2)</code>.

<div class="node">
<a name="Builtin-Operators"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Items">Items</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Terms">Terms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.4 Builtin Operators</h3>

<p>The following table lists all of Mercury's builtin operators. 
Operators with a low &ldquo;Priority&rdquo; bind more tightly than those
with a high &ldquo;Priority&rdquo;. For example, given that <code>+</code> has priority
500 and <code>*</code> has priority 400, the term <code>2 * X + Y</code> would parse
as <code>(2 * X) + Y</code>.

   <p>The &ldquo;Specifier&rdquo; field indicates what structure terms
constructed with an operator are allowed to take. 
&ldquo;f&rdquo; represents the operator and &ldquo;x&rdquo; and &ldquo;y&rdquo; represent arguments. 
&ldquo;x&rdquo; represents an argument whose priority must be
strictly lower than that of the operator. 
&ldquo;y&rdquo; represents an argument whose priority is
lower or equal to that of the operator. 
For example, &ldquo;yfx&rdquo; indicates a left-associative infix operator,
while &ldquo;xfy&rdquo; indicates a right-associative infix operator.

<pre class="example">     
     Operator                        Specifier         Priority
     
     .                               yfx               10
     !                               fx                40
     !.                              fx                40
     !:                              fx                40
     @                               xfx               90
     ^                               xfy               99
     ^                               fx                100
     :                               yfx               120
     `<var>op</var>`                      yfx               120       <a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>
     **                              xfy               200
     -                               fx                200
     \\                              fx                200
     *                               yfx               400
     /                               yfx               400
     //                              yfx               400
     &lt;&lt;                              yfx               400
     &gt;&gt;                              yfx               400
     div                             yfx               400
     mod                             xfx               400
     rem                             xfx               400
     +                               fx                500
     +                               yfx               500
     ++                              xfy               500
     -                               yfx               500
     --                              yfx               500
     /\\                             yfx               500
     \\/                             yfx               500
     ..                              xfx               550
     :=                              xfx               650
     =^                              xfx               650
     &lt;                               xfx               700
     =                               xfx               700
     =..                             xfx               700
     =:=                             xfx               700
     =&lt;                              xfx               700
     ==                              xfx               700
     =\\=                            xfx               700
     &gt;                               xfx               700
     &gt;=                              xfx               700
     @&lt;                              xfx               700
     @=&lt;                             xfx               700
     @&gt;                              xfx               700
     @&gt;=                             xfx               700
     \\=                             xfx               700
     \\==                            xfx               700
     ~=                              xfx               700
     is                              xfx               701
     and                             xfy               720
     or                              xfy               740
     func                            fx                800
     impure                          fy                800
     pred                            fx                800
     semipure                        fy                800
     \\+                             fy                900
     not                             fy                900
     when                            xfx               900
     ~                               fy                900
     &lt;=                              xfy               920
     &lt;=&gt;                             xfy               920
     =&gt;                              xfy               920
     all                             fxy               950
     arbitrary                       fxy               950
     promise_equivalent_solutions    fxy               950
     promise_equivalent_solution_sets fxy              950
     promise_exclusive               fy                950
     promise_exclusive_exhaustive    fy                950
     promise_exhaustive              fy                950
     promise_impure                  fx                950
     promise_pure                    fx                950
     promise_semipure                fx                950
     require_complete_switch         fxy               950
     require_det                     fx                950
     require_semidet                 fx                950
     require_multi                   fx                950
     require_nondet                  fx                950
     require_cc_multi                fx                950
     require_cc_nondet               fx                950
     require_erroneous               fx                950
     require_failure                 fx                950
     some                            fxy               950
     ,                               xfy               1000
     &amp;                               xfy               1025
     -&gt;                              xfy               1050
     ;                               xfy               1100
     then                            xfx               1150
     if                              fx                1160
     else                            xfy               1170
     ::                              xfx               1175
     ==&gt;                             xfx               1175
     where                           xfx               1175
     ---&gt;                            xfy               1179
     type                            fx                1180
     solver                          fy                1181
     end_module                      fx                1199
     import_module                   fx                1199
     include_module                  fx                1199
     initialise                      fx                1199
     initialize			fx		  1199
     finalise			fx		  1199
     finalize			fx		  1199
     inst                            fx                1199
     instance                        fx                1199
     mode                            fx                1199
     module                          fx                1199
     pragma                          fx                1199
     promise                         fx                1199
     rule                            fx                1199
     typeclass                       fx                1199
     use_module                      fx                1199
     --&gt;                             xfx               1200
     :-                              fx                1200
     :-                              xfx               1200
     ?-                              fx                1200
     
</pre>
   <div class="node">
<a name="Items"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Declarations">Declarations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Builtin-Operators">Builtin Operators</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.5 Items</h3>

<p>Each item in a Mercury module is either a declaration or a clause. 
If the top-level functor of the term is &lsquo;<samp><span class="samp">:-/1</span></samp>&rsquo;,
the item is a declaration, otherwise it is a clause. 
There are three types of clauses. 
If the top-level functor of the item is &lsquo;<samp><span class="samp">:-/2</span></samp>&rsquo;, the item is a rule. 
If the top-level functor is &lsquo;<samp><span class="samp">--&gt;/2</span></samp>&rsquo;, the item is a DCG rule. 
Otherwise, the item is a fact. 
There are two types of rules and facts. 
If the top-level functor of the head of a rule is &lsquo;<samp><span class="samp">=/2</span></samp>&rsquo;, the rule
is a function rule, otherwise it is a predicate rule. 
If the top-level functor of the head of a fact is &lsquo;<samp><span class="samp">=/2</span></samp>&rsquo;, the fact
is a function fact, otherwise it is a predicate fact.

<div class="node">
<a name="Declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Facts">Facts</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Items">Items</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.6 Declarations</h3>

<p>The allowed declarations are:

<pre class="example">     :- type
     :- solver type
     :- pred
     :- func
     :- inst
     :- mode
     :- typeclass
     :- instance
     :- pragma
     :- promise
     :- initialise
     :- finalise
     :- mutable
     :- module
     :- interface
     :- implementation
     :- import_module
     :- use_module
     :- include_module
     :- end_module
</pre>
   <p>The &lsquo;<samp><span class="samp">type</span></samp>&rsquo;, &lsquo;<samp><span class="samp">pred</span></samp>&rsquo; and &lsquo;<samp><span class="samp">func</span></samp>&rsquo; declarations are used for the
type system,
the &lsquo;<samp><span class="samp">inst</span></samp>&rsquo; and &lsquo;<samp><span class="samp">mode</span></samp>&rsquo; declarations are for the mode system,
the &lsquo;<samp><span class="samp">pragma</span></samp>&rsquo; declarations are for the foreign language interface, and for
compiler hints about inlining, and the remainder are for the module system. 
They are described in more detail in their respective chapters.

<div class="node">
<a name="Facts"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Rules">Rules</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Declarations">Declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.7 Facts</h3>

<p>A function fact is an item of the form &lsquo;<samp><var>Head</var><span class="samp"> = </span><var>Result</var></samp>&rsquo;. 
A predicate fact is an item of the form &lsquo;<samp><var>Head</var></samp>&rsquo;,
where the top-level functor of <var>Head</var>
is not <code>:-/1</code>, <code>:-/2</code>, <code>--&gt;/2</code>, or <code>=/2</code>. 
In both cases, the <var>Head</var> term must not be a variable. 
The top-level functor of the <var>Head</var>
determines which predicate or function the fact belongs to;
the predicate or function must have been declared
in a preceding &lsquo;<samp><span class="samp">pred</span></samp>&rsquo; or &lsquo;<samp><span class="samp">func</span></samp>&rsquo; declaration in this module. 
The <var>Result</var> (if any) and the arguments of the <var>Head</var> must
be valid data-terms (optionally annotated with a mode qualifier;
see <a href="#Different-clauses-for-different-modes">Different clauses for different modes</a>).

   <p>A fact is equivalent to a rule whose body is &lsquo;<samp><span class="samp">true</span></samp>&rsquo;.

<div class="node">
<a name="Rules"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Goals">Goals</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Facts">Facts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.8 Rules</h3>

<p>A function rule is an item of the form
&lsquo;<samp><var>Head</var><span class="samp"> = </span><var>Result</var><span class="samp"> :- </span><var>Body</var></samp>&rsquo;. 
A predicate rule is an item of the form
&lsquo;<samp><var>Head</var><span class="samp"> :- </span><var>Body</var></samp>&rsquo; where the top-level
functor of &lsquo;<samp><span class="samp">Head</span></samp>&rsquo; is not <code>=/2</code>. 
In both cases, the <var>Head</var> term must not be a variable. 
The top-level functor of the <var>Head</var> determines which predicate or
function the clause belongs to; the predicate or function must have
been declared in a preceding &lsquo;<samp><span class="samp">pred</span></samp>&rsquo; or &lsquo;<samp><span class="samp">func</span></samp>&rsquo; declaration in
this module. 
The <var>Result</var> and the arguments of the <var>Head</var> must be
valid data-terms (optionally annotated with a mode qualifier;
see <a href="#Different-clauses-for-different-modes">Different clauses for different modes</a>). 
The <var>Body</var> must be a valid goal.

<div class="node">
<a name="Goals"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#State-variables">State variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Rules">Rules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.9 Goals</h3>

<p>A goal is a term of one of the following forms:

     <dl>
<dt><code>some </code><var>Vars</var> <var>Goal</var><dd>An existential quantification. 
<var>Vars</var> must be a list of variables. 
<var>Goal</var> must be a valid goal.

     <p>Each existential quantification introduces a new scope. 
The variables in <var>Vars</var> are local to the goal <var>Goal</var>:
for each variable named in <var>Vars</var>,
any occurrences of variables with that name in <var>Goal</var>
are considered to name a different variable than any
variables with the same name that occur outside of the
existential quantification.

     <p>Operationally, existential quantification has no effect,
so apart from its effect on variable scoping,
&lsquo;<samp><span class="samp">some </span><var>Vars</var> <var>Goal</var></samp>&rsquo; is the
same as &lsquo;<samp><var>Goal</var></samp>&rsquo;.

     <p>Mercury's rules for implicit quantification (see <a href="#Implicit-quantification">Implicit quantification</a>)
mean that variables are often implicitly existentially quantified. 
There is usually no need to write existential quantifiers explicitly.

     <br><dt><code>all </code><var>Vars</var> <var>Goal</var><dd>A universal quantification. 
<var>Vars</var> must be a list of variables. 
<var>Goal</var> must be a valid goal. 
This is an abbreviation for &lsquo;<samp><span class="samp">not (some </span><var>Vars</var><span class="samp"> not </span><var>Goal</var><span class="samp">)</span></samp>&rsquo;.

     <br><dt><var>Goal1</var><code>, </code><var>Goal2</var><dd>A conjunction. 
<var>Goal1</var> and <var>Goal2</var> must be valid goals.

     <br><dt><var>Goal1</var><code> &amp; </code><var>Goal2</var><dd>A parallel conjunction. 
This has the same declarative semantics as the normal conjunction. 
Operationally, implementations may execute <var>Goal1</var> &amp; <var>Goal2</var>
in parallel. 
The order in which parallel conjuncts begin execution is
not fixed. 
It is an error for <var>Goal1</var> or <var>Goal2</var> to have a
determinism other than &lsquo;<samp><span class="samp">det</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo;. 
See <a href="#Determinism-categories">Determinism categories</a>.

     <br><dt><var>Goal1</var><code> ; </code><var>Goal2</var><dd>where <var>Goal1</var> is not of the form &lsquo;<samp><span class="samp">Goal1a -&gt; Goal1b</span></samp>&rsquo;:
a disjunction. 
<var>Goal1</var> and <var>Goal2</var> must be valid goals.

     <br><dt><code>true</code><dd>The empty conjunction. 
Always succeeds.

     <br><dt><code>fail</code><dd>The empty disjunction. 
Always fails.

     <br><dt><code>not </code><var>Goal</var><dt><code>\+ </code><var>Goal</var><dd>A negation. 
The two different syntaxes have identical semantics. 
<var>Goal</var> must be a valid goal. 
Both forms are equivalent to &lsquo;<samp><span class="samp">if </span><var>Goal</var><span class="samp"> then fail else true</span></samp>&rsquo;.

     <br><dt><var>Goal1</var><code> =&gt; </code><var>Goal2</var><dd>An implication. 
This is an abbreviation for &lsquo;<samp><span class="samp">not (</span><var>Goal1</var><span class="samp">, not </span><var>Goal2</var><span class="samp">)</span></samp>&rsquo;.

     <br><dt><var>Goal1</var><code> &lt;= </code><var>Goal2</var><dd>A reverse implication. 
This is an abbreviation for &lsquo;<samp><span class="samp">not (</span><var>Goal2</var><span class="samp">, not </span><var>Goal1</var><span class="samp">)</span></samp>&rsquo;.

     <br><dt><var>Goal1</var><code> &lt;=&gt; </code><var>Goal2</var><dd>A logical equivalence. 
This is an abbreviation for
&lsquo;<samp><span class="samp">(</span><var>Goal1</var><span class="samp"> =&gt; </span><var>Goal2</var><span class="samp">), (</span><var>Goal1</var><span class="samp"> &lt;= </span><var>Goal2</var></samp>&rsquo;).

     <br><dt><code>if </code><var>CondGoal</var><code> then </code><var>ThenGoal</var><code> else </code><var>ElseGoal</var><dt><var>CondGoal</var><code> -&gt; </code><var>ThenGoal</var><code> ; </code><var>ElseGoal</var><dd>An if-then-else. 
The two different syntaxes have identical semantics. 
<var>CondGoal</var>, <var>ThenGoal</var>, and <var>ElseGoal</var> must be valid goals. 
Note that the &ldquo;else&rdquo; part is <em>not</em> optional.

     <p>The declarative semantics of an if-then-else is given by
<code>( </code><var>CondGoal</var><code>, </code><var>ThenGoal</var><code> ; not(</code><var>CondGoal</var><code>), </code><var>ElseGoal</var><code>)</code>,
but the operational semantics are different, and it is treated
differently for the purposes of determinism inference (see <a href="#Determinism">Determinism</a>). 
Operationally, it executes the <var>CondGoal</var>, and if that succeeds, then
execution continues with the <var>ThenGoal</var>; otherwise, i.e. if <var>CondGoal</var>
fails, it executes the <var>ElseGoal</var>.  Note that <var>CondGoal</var> can be
nondeterministic &mdash; unlike Prolog, Mercury's if-then-else does not commit
to the first solution of the condition if the condition succeeds.

     <p>If <var>CondGoal</var> is an explicit existential quantification,
<code>some </code><var>Vars</var> <var>QuantifiedCondGoal</var>, then the variables
<var>Vars</var> are existentially quantified over the conjunction of the goals
<var>QuantifiedCondGoal</var> and <var>ThenGoal</var>. 
Explicit existential quantifications that occur as subgoals of <var>CondGoal</var>
do <em>not</em> affect the scope of variables in the &ldquo;then&rdquo; part. 
For example, in
     <pre class="example">             ( if some [V] <var>C</var> then <var>T</var> else <var>E</var> )
</pre>
     <p class="noindent">the variable <var>V</var> is quantified over the conjunction of the goals
<var>C</var> and <var>T</var> because the top-level goal of the condition is
an explicit existential quantification, but in
     <pre class="example">             ( if true, some [V] <var>C</var> then <var>T</var> else <var>E</var> )
</pre>
     <p class="noindent">the variable <var>V</var> is only quantified over <var>C</var>
because the top-level goal of the condition is not an explicit
existential quantification.

     <br><dt><var>Term1</var><code> = </code><var>Term2</var><dd>A unification. 
<var>Term1</var> and <var>Term2</var> must be valid data-terms.

     <br><dt><var>Term1</var><code> \= </code><var>Term2</var><dd>An inequality. 
<var>Term1</var> and <var>Term2</var> must be valid data-terms. 
This is an abbreviation for &lsquo;<samp><span class="samp">not (</span><var>Term1</var><span class="samp"> = </span><var>Term2</var><span class="samp">)</span></samp>&rsquo;.

     <br><dt><code>call(Closure)</code><dt><code>call(Closure1, Arg1)</code><dt><code>call(Closure2, Arg1, Arg2)</code><dt><code>call(Closure3, Arg1, Arg2, Arg3)</code><dt><small class="dots">...</small><dd>A higher-order predicate call. 
The closure and arguments must be valid data-terms. 
&lsquo;<samp><span class="samp">call(Closure)</span></samp>&rsquo; just calls
the specified closure.  The other forms append the specified
arguments onto the argument list of the closure before calling it. 
See <a href="#Higher_002dorder">Higher-order</a>.

     <br><dt><code>Var</code><dt><code>Var(Arg1)</code><dt><code>Var(Arg2)</code><dt><code>Var(Arg2, Arg3)</code><dt><small class="dots">...</small><dd>A higher-order predicate call. 
<var>Var</var> must be a variable. 
The semantics are exactly the same as for the corresponding
higher-order call using the <code>call/N</code> syntax, i.e. 
&lsquo;<samp><span class="samp">call(Var)</span></samp>&rsquo;, &lsquo;<samp><span class="samp">call(Var, Arg1)</span></samp>&rsquo;, etc.

     <br><dt><code>promise_pure </code><var>Goal</var><dd>A purity cast. 
<var>Goal</var> must be a valid goal. 
This goal promises that <var>Goal</var> implements a pure interface,
even though it may include impure and semipure components.

     <br><dt><code>promise_semipure </code><var>Goal</var><dd>A purity cast. 
<var>Goal</var> must be a valid goal. 
This goal promises that <var>Goal</var> implements a semipure interface,
even though it may include impure components.

     <br><dt><code>promise_impure </code><var>Goal</var><dd>A purity cast. 
<var>Goal</var> must be a valid goal. 
This goal instructs the compiler to treat <var>Goal</var> as though it were impure,
regardless of its actual purity.

     <br><dt><code>promise_equivalent_solutions </code><var>Vars</var> <var>Goal</var><dd>A determinism cast. 
<var>Vars</var> must be a list of variables. 
<var>Goal</var> must be a valid goal. 
This goal promises that <var>Vars</var>
is the set of variables bound by <var>Goal</var>,
and that while <var>Goal</var> may have more than one solution,
all of these solutions are equivalent
with respect to the equality theories of the variables in <var>Vars</var>. 
It is an error for <var>Vars</var> to include a variable not bound by <var>Goal</var>
or for <var>Goal</var> to bind a non-local variable
that is not listed in <var>Vars</var>
(non-local variables with inst <var>any</var> are assumed to be further constrained
by <var>Goal</var> and must also be included in <var>Vars</var>). 
If <var>Goal</var> has determinism &lsquo;<samp><span class="samp">multi</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo; then
<code>promise_equivalent_solutions </code><var>Vars</var> <var>Goal</var>
has determinism &lsquo;<samp><span class="samp">det</span></samp>&rsquo;. 
If <var>Goal</var> has determinism &lsquo;<samp><span class="samp">nondet</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cc_nondet</span></samp>&rsquo; then
<code>promise_equivalent_solutions </code><var>Vars</var> <var>Goal</var>
has determinism &lsquo;<samp><span class="samp">semidet</span></samp>&rsquo;.

     <br><dt><code>promise_equivalent_solution_sets </code><var>Vars</var> <var>Goal</var><dd>A determinism cast,
of the kind performed by <code>promise_equivalent_solutions</code>,
on any goals of the form
<code>arbitrary </code><var>ArbVars</var> <var>ArbGoal</var> inside <var>Goal</var>,
of which there should be at least one. 
<var>Vars</var> and <var>ArbVars</var> must be lists of variables,
and <var>Goal</var> and <var>ArbGoal</var> must be valid goals. 
<var>Vars</var> must be the set of variables bound by <var>Goal</var>,
and <var>ArbVars</var> must be the set of variables bound by <var>ArbGoal</var>,
It is an error for <var>Vars</var> to include a variable not bound by <var>Goal</var>
or for <var>Goal</var> to bind a non-local variable
that is not listed in <var>Vars</var>,
and similarly for <var>ArbVars</var> and <var>ArbGoal</var>. 
The intersection of <var>Vars</var> and the <var>ArbVars</var> list
of any <code>arbitrary </code><var>ArbVars</var> <var>ArbGoal</var> goal
included inside <var>Goal</var> must be empty.

     <p>The overall <var>promise_equivalent_solution_sets</var> goal promises that
the set of solutions computed for <var>Vars</var> by <var>Goal</var>
is not influenced by which of the possible solutions
for <var>ArbVars</var> is computed by each <var>ArbGoal</var>;
while different choices of solutions for some of the <var>ArbGoal</var>s
may lead to syntactically different solutions for <var>Vars</var> for <var>Goal</var>,
all of these solutions are equivalent
with respect to the equality theories of the variables in <var>Vars</var>. 
If an <var>ArbGoal</var> has determinism &lsquo;<samp><span class="samp">multi</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo; then
<code>arbitrary </code><var>ArbVars</var> <var>ArbGoal</var> has determinism &lsquo;<samp><span class="samp">det</span></samp>&rsquo;. 
If <var>ArbGoal</var> has determinism &lsquo;<samp><span class="samp">nondet</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cc_nondet</span></samp>&rsquo; then
<code>arbitrary </code><var>ArbVars</var> <var>ArbGoal</var> has determinism &lsquo;<samp><span class="samp">semidet</span></samp>&rsquo;. 
<var>Goal</var> itself may have any determinism.

     <p>There is no requirement that given one of the <var>ArbGoal</var>s,
all its solutions must be equivalent with respect to the equality theories
of the corresponding <var>ArbVars</var>;
in fact, in typical usage, this won't be the case. 
The different solutions of the nested <var>arbitrary</var> goals
are not required to be equivalent in any context
except the <var>promise_equivalent_solution_sets</var> goal they are nested inside.

     <p>Goals of the form <code>arbitrary </code><var>ArbVars</var> <var>ArbGoal</var>
are not allowed to occur outside
<code>promise_equivalent_solution_sets </code><var>Vars</var> <var>Goal</var> goals.

     <br><dt><code>require_det </code><var>Goal</var><dt><code>require_semidet </code><var>Goal</var><dt><code>require_multi </code><var>Goal</var><dt><code>require_nondet </code><var>Goal</var><dt><code>require_cc_multi </code><var>Goal</var><dt><code>require_cc_nondet </code><var>Goal</var><dt><code>require_erroneous </code><var>Goal</var><dt><code>require_failure </code><var>Goal</var><dd>A determinism check, typically used to enhance the robustness of code. 
<var>Goal</var> must be a valid goal. 
If <var>Goal</var> is det, then
<code>require_det </code><var>Goal</var> is equivalent to just <var>Goal</var>. 
If <var>Goal</var> is not det,
then the compiler is required to generate an error message.

     <p>The <code>require_det</code> keyword
may be replaced with
<code>require_semidet</code>,
<code>require_multi</code>,
<code>require_nondet</code>,
<code>require_cc_multi</code>,
<code>require_cc_nondet</code>,
<code>require_erroneous</code> or
<code>require_failure</code>,
each of which requires <var>Goal</var> to have the named determinism.

     <br><dt><code>require_complete_switch [</code><var>Var</var><code>] </code><var>Goal</var><dd>A switch completeness check, typically used to enhance the robustness of code. 
If <var>Goal</var> is a complete switch on <var>Var</var>,
i.e. a switch that has an arm
for all the function symbols in the type of <var>Var</var>,
then <code>require_complete_switch [</code><var>Var</var><code>] </code><var>Goal</var>
is equivalent to <var>Goal</var>. 
If <var>Goal</var> is a switch on <var>Var</var> but it is not a complete switch,
i.e. it has no arm
for at least one of the function symbols in the type of <var>Var</var>,
then the compiler is required to generate an error message. 
If <var>Goal</var> is not a switch on <var>Var</var>,
then <code>require_complete_switch [</code><var>Var</var><code>] </code><var>Goal</var>
is equivalent to <var>Goal</var>. 
This is intended to allow these scopes to be used
even if <var>Var</var> is input to the scope
only in some but not all modes of the containing predicate.

     <br><dt><code>trace </code><var>Params</var> <var>Goal</var><dd>A trace goal, typically used for debugging or logging. 
<var>Goal</var> must be a valid goal;
<var>Params</var> must be a valid list of trace parameters. 
Some trace parameters specify compile time or run time conditions;
if any of these conditions are false, <var>Goal</var> will not be executed. 
Since in some program invocations
<var>Goal</var> may be replaced by &lsquo;<samp><span class="samp">true</span></samp>&rsquo; in this way,
<var>Goal</var> may not bind or change the instantiation state
of any variables it shares with the surrounding context. 
The things it may do are thus restricted to side effects;
good programming style requires these side effects
to not have any affect on the execution of the program itself,
but to be confined to the provision of extra information
for the user of the program. 
See <a href="#Trace-goals">Trace goals</a> for the details.

     <br><dt><code>try </code><var>Params</var> <var>Goal</var><code> ... catch </code><var>Term</var><code> -&gt; </code><var>CGoal</var><code> ...</code><dd>A try goal. Exceptions thrown during the execution of <var>Goal</var>
may be caught and handled. A summary of the try goal syntax is:

     <pre class="example">              try <var>Params</var> <var>Goal</var>
              then <var>ThenGoal</var>
              else <var>ElseGoal</var>
              catch <var>Term</var> -&gt; <var>CatchGoal</var>
              ...
              catch_any <var>CatchAnyVar</var> -&gt; <var>CatchAnyGoal</var>
</pre>
     <p>See <a href="#Exception-handling">Exception handling</a> for the full details.

     <br><dt><code>event </code><var>Goal</var><dd>An event goal.  <var>Goal</var> must be a predicate call. 
Event goals are an extension used by the Melbourne Mercury implementation
to support user defined events in the Mercury debugger, &lsquo;<samp><span class="samp">mdb</span></samp>&rsquo;. 
See the &ldquo;Debugging&rdquo; chapter of the Mercury User's Guide for further details.

     <br><dt><var>Call</var><dd>Any goal which does not match any of the above forms
must be a predicate call. 
The top-level functor of the term
determines the predicate called;
the predicate must be declared in a <code>pred</code> declaration
in the module or in the interface of an imported module. 
The arguments must be valid data-terms.

   </dl>

<div class="node">
<a name="State-variables"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DCG_002drules">DCG-rules</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Goals">Goals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.10 State variables</h3>

<p>Clauses may use &lsquo;<samp><span class="samp">state variables</span></samp>&rsquo; as a shorthand for naming
intermediate values in a sequence.  That is, where in the plain syntax one
might write
<pre class="example">     	main(IO0, IO) :-
     		io.write_string("The answer is ", IO0, IO1),
     		io.write_int(calculate_answer(...), IO1, IO2),
     		io.nl(IO3, IO).
</pre>
   <p class="noindent">using state variable syntax one could write
<pre class="example">     	main(!IO) :-
     		io.write_string("The answer is ", !IO),
     		io.write_int(calculate_answer(...), !IO),
     		io.nl(!IO).
</pre>
   <p>A state variable is written &lsquo;<samp><span class="samp">!.</span><var>X</var></samp>&rsquo; or &lsquo;<samp><span class="samp">!:</span><var>X</var></samp>&rsquo;,
denoting the &ldquo;current&rdquo; or &ldquo;next&rdquo; value of the sequence labelled
<var>X</var>.  An argument &lsquo;<samp><span class="samp">!</span><var>X</var></samp>&rsquo; is shorthand for two state
variable arguments &lsquo;<samp><span class="samp">!.</span><var>X</var><span class="samp">, !:</span><var>X</var></samp>&rsquo;; that is,
&lsquo;<samp><span class="samp">p(..., !</span><var>X</var><span class="samp">, ...)</span></samp>&rsquo; is parsed as
&lsquo;<samp><span class="samp">p(..., !.</span><var>X</var><span class="samp">, !:</span><var>X</var><span class="samp">, ...)</span></samp>&rsquo;.

   <p>Within each clause, a transformation converts state variables into
sequences of ordinary logic variables.  The syntactic conversion is
described in terms of the notional &lsquo;<samp><span class="samp">transform</span></samp>&rsquo; function defined
next.

   <p>The transformation is applied once for each state variable <var>X</var>
with some fresh variables which we shall call <var>ThisX</var> and <var>NextX</var>.

   <p>The expression
&lsquo;<samp><span class="samp">substitute(</span><var>Term</var><span class="samp">, </span><var>X</var><span class="samp">, </span><var>ThisX</var><span class="samp">, </span><var>NextX</var><span class="samp">)</span></samp>&rsquo;
stands for a copy of <var>Term</var>
with free occurrences of &lsquo;<samp><span class="samp">!.</span><var>X</var></samp>&rsquo; replaced with <var>ThisX</var>
and free occurrences of &lsquo;<samp><span class="samp">!:</span><var>X</var></samp>&rsquo; replaced with <var>NextX</var>
(a free occurrence is one not bound by the head of a clause or lambda
or by explicit quantification.)

   <p>State variables obey the special scope rules. 
A state variable <var>X</var> must be explicitly introduced either in the head of
the clause or lambda (in which case it may appear as either or both of
&lsquo;<samp><span class="samp">!.</span><var>X</var></samp>&rsquo; or &lsquo;<samp><span class="samp">!:</span><var>X</var></samp>&rsquo;) or in an explicit quantification (in
which case it must appear as &lsquo;<samp><span class="samp">!</span><var>X</var></samp>&rsquo;.)  A state variable <var>X</var> in
the enclosing scope of a lambda or if-then-else expression may only be
referred to as &lsquo;<samp><span class="samp">!.</span><var>X</var></samp>&rsquo; (unless the enclosing <var>X</var> is masked
by a more local state variable of the same name.)

   <p>For instance, the following clause employing a lambda expression
<pre class="example">             p(<var>A</var>, <var>B</var>, !<var>S</var>) :-
                     F = (pred(<var>C</var>::in, <var>D</var>::out) is det :-
                             q(<var>C</var>, <var>D</var>, !<var>S</var>)
                     ),
                     ( F(<var>A</var>, <var>E</var>) -&gt;
                             <var>B</var> = <var>E</var>
                     ;
                             <var>B</var> = <var>A</var>
                     ).
</pre>
   <p class="noindent">is illegal because
it implicitly refers to &lsquo;<samp><span class="samp">!:</span><var>S</var></samp>&rsquo; inside the lambda expression. 
However
<pre class="example">             p(<var>A</var>, <var>B</var>, !<var>S</var>) :-
                     F = (pred(<var>C</var>::in, <var>D</var>::out, !.<var>S</var>::in, !:<var>S</var>::out) is det :-
                             q(<var>C</var>, <var>D</var>, !<var>S</var>)
                     ),
                     ( F(<var>A</var>, <var>E</var>, !<var>S</var>) -&gt;
                             <var>B</var> = <var>E</var>
                     ;
                             <var>B</var> = <var>A</var>
                     ).
</pre>
   <p class="noindent">is acceptable because the state variable <var>S</var> accessed
inside the lambda expression is locally scoped to the lambda expression
(shadowing the state variable of the same name outside the lambda expression),
and the lambda expression may refer to
the next version of a local state variable.

   <p>There are three restrictions concerning state variables in lambdas: first,
&lsquo;<samp><span class="samp">!</span><var>X</var></samp>&rsquo; is not a legitimate function result, since it stands for two
arguments, rather than one; second, &lsquo;<samp><span class="samp">!</span><var>X</var></samp>&rsquo; may not appear as a
parameter term in the head of a lambda since there is no syntax for specifying
the modes of the two implied parameters; third, &lsquo;<samp><span class="samp">!</span><var>X</var></samp>&rsquo; may not appear
as an argument in a function application since this would not make sense given
the usual interpretation of state variables and functions.

     <dl>
<dt><var>Head</var><code> :- </code><var>Body</var><dd>
     <pre class="example">          transform((<var>Head</var> :- <var>Body</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          substitute(<var>Head</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>) :- transform(<var>Body</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>)
</pre>
     <br><dt><var>Head</var><code> --&gt; </code><var>Body</var><dd>
     <pre class="example">          transform((<var>Head</var> --&gt; <var>Body</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          substitute(<var>Head</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>) :- transform(<var>Body</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>)
</pre>
     <br><dt><var>Goal1</var><code>, </code><var>Goal2</var><dd>
     <pre class="example">          transform((<var>Goal1</var>, <var>Goal2</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          transform(<var>Goal1</var>, <var>X</var>, <var>ThisX</var>, <var>TmpX</var>), transform(<var>Goal2</var>, <var>X</var>, <var>TmpX</var>, <var>NextX</var>)
</pre>
     <p>for some fresh variable <var>TmpX</var>.

     <br><dt><var>Goal1</var><code> ; </code><var>Goal2</var><dd>
     <pre class="example">          transform((<var>Goal1</var> ; <var>Goal2</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          transform(<var>Goal1</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>) ; transform(<var>Goal2</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>)
</pre>
     <br><dt><code>not </code><var>Goal</var><br><dt><code>\+ </code><var>Goal</var><dd>A negation.  The two different syntaxes have identical semantics.
     <pre class="example">          transform((not <var>Goal</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          not transform(<var>Goal1</var>, <var>X</var>, <var>ThisX</var>, <var>DummyX</var>), <var>NextX</var> = <var>ThisX</var>
</pre>
     <p>for some fresh variable <var>DummyX</var>.

     <br><dt><code>if </code><var>Goal1</var><code> then </code><var>Goal2</var><code> else </code><var>Goal3</var><br><dt><var>Goal1</var><code> -&gt; </code><var>Goal2</var><code> ; </code><var>Goal3</var><dd>An if-then-else.  The two different syntaxes have identical semantics.
     <pre class="example">          transform((if <var>Goal1</var> then <var>Goal2</var> else <var>Goal3</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          if transform(<var>Goal1</var>, <var>X</var>, <var>ThisX</var>, <var>TmpX</var>) then transform(<var>Goal2</var>, <var>X</var>, <var>TmpX</var>,  <var>NextX</var>)
                                              else transform(<var>Goal3</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>)
</pre>
     <p>for some fresh variable <var>TmpX</var>.

     <br><dt><var>Goal1</var><code> =&gt; </code><var>Goal2</var><br><dt><var>Goal2</var><code> &lt;= </code><var>Goal1</var><dd>An implication.  The two different syntaxes have identical semantics.
     <pre class="example">          transform((<var>Goal1</var> =&gt; <var>Goal2</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          transform(<var>Goal1</var>, <var>X</var>, <var>ThisX</var>, <var>TmpX</var>) =&gt; transform(<var>Goal2</var>, <var>X</var>, <var>TmpX</var>,  <var>NextX</var>),
          <var>NextX</var> = <var>ThisX</var>
</pre>
     <p>for some fresh variable <var>TmpX</var>.

     <br><dt><code>all </code><var>Vars</var> <var>Goal</var><dd>
     <pre class="example">          transform((all <var>Vars</var> <var>Goal</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          all <var>Vars</var> transform(<var>Goal</var>, <var>X</var>, <var>ThisX</var>, <var>DummyX</var>), <var>NextX</var> = <var>ThisX</var>
</pre>
     <p>for some fresh variable <var>DummyX</var>.

     <br><dt><code>some </code><var>Vars</var> <var>Goal</var><dd>
     <pre class="example">          transform((some <var>Vars</var> <var>Goal</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          some <var>Vars</var> transform(<var>Goal</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>)
</pre>
     <br><dt><code>!</code><var>X</var><code> ^ </code><var>field_list</var><code> := </code><var>Term</var><dd>A field update. 
Replaces a field in the argument. 
<var>Term</var> must be a valid data-term. 
<var>field_list</var> must be a valid field list. 
See <a href="#Record-syntax">Record syntax</a>.
     <pre class="example">          transform((!<var>X</var> ^ <var>field_list</var> := <var>Term</var>), <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          NextX = ThisX ^ field_list := Term
</pre>
     <br><dt><var>Call_or_Unification</var><dd>If &lsquo;<samp><span class="samp">!:</span><var>X</var></samp>&rsquo; does not appear in <var>Call_or_Unification</var> then
     <pre class="example">          transform(<var>Call_or_Unification</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          substitute(<var>Call_or_Unification</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>), <var>NextX</var> = <var>ThisX</var>
</pre>
     <p>If &lsquo;<samp><span class="samp">!:</span><var>X</var></samp>&rsquo; does appear in <var>Call_or_Unification</var> then
     <pre class="example">          transform(<var>Call_or_Unification</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>) =
          substitute(<var>Call_or_Unification</var>, <var>X</var>, <var>ThisX</var>, <var>NextX</var>)
</pre>
     </dl>

   <p>This transformation can lead to the introduction of chains of
unifications for variables that do not otherwise play a role in the
definition.  Such chains are removed transparently.

   <p>The following code fragments illustrate appropriate use of state
variable syntax.

     <dl>
<dt><b>Threading the I/O state</b><dd>
     <pre class="example">          main(!IO) :-
          	io.write_string("The 100th prime is ", !IO),
          	X = prime(100),
          	io.write_int(X, !IO),
          	io.nl(!IO).
</pre>
     <br><dt><b>Handling accumulators (1)</b><dd>
     <pre class="example">          foldl2(_, [], !A, !B).
          
          foldl2(P, [X | Xs], !A, !B) :-
          	P(X, !A, !B),
          	foldl2(P, Xs, !A, !B).
</pre>
     <br><dt><b>Handling accumulators (2)</b><dd>
     <pre class="example">          iterate_while2(P, F, !A, !B) :-
          	( if P(!.A, !.B) then
          		F(!A, !B),
          		iterate_while2(P, F, !A, !B)
          	  else
          	  	true
          	).
</pre>
     </dl>

<div class="node">
<a name="DCG-rules"></a>
<a name="DCG_002drules"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DCG_002dgoals">DCG-goals</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#State-variables">State variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.11 DCG-rules</h3>

<p>(DCG notation is intended for writing parsers and sequence generators
in a particular style; in the past it has also been used to thread an
implicit state variable, typically the I/O state, through code.  As a
matter of style, we recommend that in future DCG notation be reserved
for writing parsers and sequence generators and that state variable
syntax be used for passing state threads.)

   <p>DCG-rules in Mercury have identical syntax and semantics to
DCG-rules in Prolog.

   <p>A DCG-rule is an item of the form &lsquo;<samp><var>Head</var><span class="samp"> --&gt; </span><var>Body</var></samp>&rsquo;. 
The <var>Head</var> term must not be a variable. 
A DCG-rule is an abbreviation for an ordinary rule with two
additional implicit arguments appended to the arguments of <var>Head</var>. 
These arguments are fresh variables which we shall call
<var>V_in</var> and <var>V_out</var>. 
The <var>Body</var> must be a valid DCG-goal,
and is an abbreviation for an ordinary goal. 
The next section defines a mathematical function
&lsquo;<samp><span class="samp">DCG-transform(</span><var>V_in</var><span class="samp">, </span><var>V_out</var><span class="samp">, </span><var>DCG-goal</var><span class="samp">)</span></samp>&rsquo;
which specifies the semantics of how DCG goals are transformed into
ordinary goals.  (The &lsquo;<samp><span class="samp">DCG-transform</span></samp>&rsquo; function is purely for the
purposes of exposition, to define the semantics &mdash; it is not part of the
language.)

<div class="node">
<a name="DCG-goals"></a>
<a name="DCG_002dgoals"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Data_002dterms">Data-terms</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DCG_002drules">DCG-rules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.12 DCG-goals</h3>

<p>A DCG-goal is a term of one of the following forms:

     <dl>
<dt><code>some </code><var>Vars</var> <var>DCG-goal</var><dd>A DCG existential quantification. 
<var>Vars</var> must be a list of variables. 
<var>DCG-goal</var> must be a valid DCG-goal.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, some Vars DCG_goal) =
          some Vars transform(V_in, V_out, DCG_goal)
</pre>
     <br><dt><code>all </code><var>Vars</var> <var>DCG-goal</var><dd>A DCG universal quantification. 
<var>Vars</var> must be a list of variables. 
<var>DCG-goal</var> must be a valid DCG-goal.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, all Vars DCG_goal) =
          all Vars transform(V_in, V_out, DCG_goal)
</pre>
     <br><dt><var>DCG-goal1</var><code>, </code><var>DCG-goal2</var><dd>A DCG sequence. 
Intuitively, this means &ldquo;parse DCG-goal1 and then parse DCG-goal2&rdquo;
or &ldquo;do DCG-goal1 and then do DCG-goal2&rdquo;. 
(Note that the only way this construct actually forces the desired sequencing
is by the modes of the implicit DCG arguments.) 
<var>DCG-goal1</var> and <var>DCG-goal2</var> must be valid DCG-goals.

     <p>Semantics:
<!-- XXX too indented -->
     <pre class="example">          transform(V_in, V_out, (DCG-goal1, DCG-goal2)) =
          (transform(V_in, V_new, DCG_goal1),
           transform(V_new, V_out, DCG_goal2))
</pre>
     <p>where V_new is a fresh variable.

     <br><dt><var>DCG-goal1</var><code> ; </code><var>DCG-goal2</var><dd>A disjunction.  <var>DCG-goal1</var> and <var>DCG-goal2</var> must be valid goals. 
<var>DCG-goal1</var> must not be of the form &lsquo;<samp><span class="samp">DCG-goal1a -&gt; DCG-goal1b</span></samp>&rsquo;. 
(If it is, then the goal is an if-then-else, not a disjunction.)

     <p>Semantics:
<!-- XXX too indented -->
     <pre class="example">          transform(V_in, V_out, (DCG_goal1 ; DCG_goal2)) =
          ( transform(V_in, V_out, DCG_goal1)
          ; transform(V_in, V_out, DCG_goal2) )
</pre>
     <br><dt><code>{ </code><var>Goal</var><code> }</code><dd>A brace-enclosed ordinary goal. 
<var>Goal</var> must be a valid goal.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, { Goal }) = (Goal, V_out = V_in)
</pre>
     <dt><code>[</code><var>Term</var><code>, ...]</code><dd>A DCG input match. 
Unifies the implicit DCG input variable V_in,
which must have type &lsquo;<samp><span class="samp">list(_)</span></samp>&rsquo;,
with a list whose initial elements are the terms specified
and whose tail is the implicit DCG output variable V_out. 
The terms must be valid data-terms.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, [Term1, ...]) = (V_in = [Term, ... | V_Out])
</pre>
     <br><dt><code>[]</code><dd>The null DCG goal (an empty DCG input match). 
Equivalent to &lsquo;<samp><span class="samp">{ true }</span></samp>&rsquo;.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, []) = (V_out = V_in)
</pre>
     <br><dt><code>not </code><var>DCG-goal</var><dt><code>\+ </code><var>DCG-goal</var><dd>A DCG negation. 
The two different syntaxes have identical semantics. 
<var>Goal</var> must be a valid goal.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, not DCG_goal) =
          (not transform(V_in, V_new, DCG_goal), V_out = V_in)
</pre>
     <p>where V_new is a fresh variable.

     <br><dt><code>if </code><var>CondGoal</var><code> then </code><var>ThenGoal</var><code> else </code><var>ElseGoal</var><dt><var>CondGoal</var><code> -&gt; </code><var>ThenGoal</var><code> ; </code><var>ElseGoal</var><dd>A DCG if-then-else. 
The two different syntaxes have identical semantics. 
<var>CondGoal</var>, <var>ThenGoal</var>, and <var>ElseGoal</var> must be valid DCG-goals.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, if CondGoal then ThenGoal else ElseGoal) =
          if transform(V_in, V_cond, CondGoal) then
                  transform(V_cond, V_out, ThenGoal)
          else
                  transform(V_in, V_out, ElseGoal)
</pre>
     <br><dt><code>=(</code><var>Term</var><code>)</code><dd>A DCG unification.  Unifies <var>Term</var> with the implicit DCG argument. 
<var>Term</var> must be a valid data-term.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, =(Term)) = (Term = V_in, V_out = V_in)
</pre>
     <br><dt><code>:=(</code><var>Term</var><code>)</code><dd>A DCG output unification.  Unifies <var>Term</var> with the implicit DCG output
argument, ignoring the input DCG argument. 
<var>Term</var> must be a valid data-term.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, :=(Term)) = (V_out = Term)
</pre>
     <br><dt><var>Term</var><code> =^ </code><var>field_list</var><dd>A DCG field selection. 
Unifies <var>Term</var> with the result of applying the field
selection <var>field_list</var> to the implicit DCG argument. 
<var>Term</var> must be a valid data-term. 
<var>field_list</var> must be a valid field list. 
See <a href="#Record-syntax">Record syntax</a>.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, Term =^ field_list) =
                  (Term = V_in ^ field_list, V_out = V_in)
</pre>
     <br><dt><code>^ </code><var>field_list</var><code> := </code><var>Term</var><dd>A DCG field update. 
Replaces a field in the implicit DCG argument. 
<var>Term</var> must be a valid data-term. 
<var>field_list</var> must be a valid field list. 
See <a href="#Record-syntax">Record syntax</a>.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, ^ field_list := Term) =
                  (V_out = V_in ^ field_list := Term)
</pre>
     <br><dt><var>DCG-call</var><dd>Any term which does not match any of the above forms
must be a DCG predicate call. 
If the term is a variable <var>Var</var>,
it is treated as if it were &lsquo;<samp><span class="samp">call(</span><var>Var</var><span class="samp">)</span></samp>&rsquo;. 
Then, the two implicit DCG arguments are appended to the specified arguments.

     <p>Semantics:
     <pre class="example">          transform(V_in, V_out, p(A1, ..., AN)) =
          p(A1, ..., AN, V_in, V_out)
</pre>
     </dl>

<div class="node">
<a name="Data-terms"></a>
<a name="Data_002dterms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Variable-scoping">Variable scoping</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DCG_002dgoals">DCG-goals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.13 Data-terms</h3>

<p>Syntactically, a data-term is just a term.

   <p>There are a couple of differences from Prolog. 
The first one is that double-quoted strings are atomic in
Mercury, they are not abbreviations for lists of character codes. 
The second is that Mercury provides several extensions to Prolog's
term syntax: Mercury terms may contain record field selection and
field update expressions, conditional (if-then-else) expressions,
function applications, higher-order function applications, lambda
expressions, and explicit type qualifications.

   <p>A data-term is either a variable, a data-functor, or a special data-term. 
A special data-term is a conditional expression, a record syntax expression,
a lambda expression, a higher-order function application,
or an explicit type qualification.

<ul class="menu">
<li><a accesskey="1" href="#Data_002dfunctors">Data-functors</a>
<li><a accesskey="2" href="#Record-syntax">Record syntax</a>
<li><a accesskey="3" href="#Unification-expressions">Unification expressions</a>
<li><a accesskey="4" href="#Conditional-expressions">Conditional expressions</a>
<li><a accesskey="5" href="#Lambda-expressions">Lambda expressions</a>
<li><a accesskey="6" href="#Higher_002dorder-function-applications">Higher-order function applications</a>
<li><a accesskey="7" href="#Explicit-type-qualification">Explicit type qualification</a>
</ul>

<div class="node">
<a name="Data-functors"></a>
<a name="Data_002dfunctors"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Record-syntax">Record syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data_002dterms">Data-terms</a>

</div>

<h4 class="subsection">2.13.1 Data-functors</h4>

<p>A data-functor is an integer, a float, a string, a character literal
(any single-character name), a name, an implementation-defined literal,
or a compound data-term. 
A compound data-term is a compound term which does not match
the form of a special data-term (see <a href="#Data_002dterms">Data-terms</a>),
and whose arguments are data-terms. 
If a data-functor is a name or a compound data-term, its top-level functor
must name a function, predicate, or data constructor declared
in the program or in the interface of an imported module.

   <p>Implementation-defined literals are symbolic names whose value represents
a property of the compilation environment or the context in which it
appears. The implementation replaces these symbolic names with actual
constants during compilation.  Implementation-defined literals can only
appear within clauses. The following literals must be supported by all
Mercury implementations:

     <dl>
<dt>&lsquo;<samp><span class="samp">$file</span></samp>&rsquo;<dd>a string that gives the name of the file that contains the module
being compiled. If the name of the file cannot be determined then it is
replaced by an arbitrary string.

     <br><dt>&lsquo;<samp><span class="samp">$line</span></samp>&rsquo;<dd>the line number (integer) of the goal in which the literal appears
or -1 if it cannot be determined.

     <br><dt>&lsquo;<samp><span class="samp">$module</span></samp>&rsquo;<dd>a string representation of the fully-qualified module name.

     <br><dt>&lsquo;<samp><span class="samp">$pred</span></samp>&rsquo;<dd>a string containing the fully-qualified predicate or function name and arity.

   </dl>

   <p>The Mercury Melbourne implementation additionally supports the following
extension:

     <dl>
<dt>&lsquo;<samp><span class="samp">$grade</span></samp>&rsquo;<dd>the grade (string) in which the module is compiled.

   </dl>

<div class="node">
<a name="Record-syntax"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Unification-expressions">Unification expressions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Data_002dfunctors">Data-functors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data_002dterms">Data-terms</a>

</div>

<h4 class="subsection">2.13.2 Record syntax</h4>

<p>Record syntax provides a convenient way to select or update fields
of data constructors, independent of the definition of the constructor. 
Record syntax expressions are transformed into sequences of calls
to field selection or update functions (see <a href="#Field-access-functions">Field access functions</a>).

   <p>A field specifier is a name or a compound data-term. 
A field list is a list of field specifiers separated by <code>^</code>. 
<code>field</code>, <code>field1 ^ field2</code> and <code>field1(A) ^ field2(B, C)</code> are
all valid field lists.

   <p>If the top-level functor of a field specifier is &lsquo;<samp><var>field</var><span class="samp">/N</span></samp>&rsquo;,
there must be a visible selection function &lsquo;<samp><var>field</var><span class="samp">/(N + 1)</span></samp>&rsquo;. If the
field specifier occurs in a field update expression, there must also be a
visible update function named &lsquo;<samp><span class="samp">'</span><var>field</var><span class="samp"> :='/(N + 2)</span></samp>&rsquo;.

   <p>Record syntax expressions have one of the following forms. 
There are also record syntax DCG goals (see <a href="#DCG_002dgoals">DCG-goals</a>),
which provide similar functionality to record syntax expressions,
except that they act on the DCG arguments of a DCG clause.

     <dl>
<dt><var>Term</var><code> ^ </code><var>field_list</var><dd>
A field selection. For each field specifier in <var>field_list</var>, apply
the corresponding selection function in turn.

     <p><var>Term</var> must be a valid data-term. 
<var>field_list</var> must be a valid field list.

     <p>A field selection is transformed using the following rules:
     <pre class="example">          transform(Term ^ Field(Arg1, ...)) = Field(Arg1, ..., Term).
          transform(Term ^ Field(Arg1, ...) ^ Rest) =
                          transform(Field(Arg1, ..., Term) ^ Rest).
</pre>
     <p>Examples:

     <p><code>Term ^ field</code> is equivalent to <code>field(Term)</code>.

     <p><code>Term ^ field(Arg)</code> is equivalent to <code>field(Arg, Term)</code>.

     <p><code>Term&nbsp;^&nbsp;field1(Arg1)&nbsp;^&nbsp;field2(Arg2,&nbsp;Arg3)</code><!-- /@w --> is equivalent
to <code>field2(Arg2,&nbsp;Arg3,&nbsp;field1(Arg1,&nbsp;Term))</code><!-- /@w -->.

     <br><dt><var>Term</var><code> ^ </code><var>field_list</var><code> := </code><var>FieldValue</var><dd>
A field update, returning a copy of <var>Term</var> with the value of
the field specified by <var>field_list</var> replaced with <var>FieldValue</var>.

     <p><var>Term</var> must be a valid data-term. 
<var>field_list</var> must be a valid field list.

     <p>A field update is transformed using the following rules:
     <pre class="example">          transform(Term ^ Field(Arg1, ...) := FieldValue) =
                          'Field :='(Arg1, ..., Term, FieldValue)).
          
          transform(Term0 ^ Field(Arg1, ...) ^ Rest := FieldValue) = Term :-
                  OldFieldValue = Field(Arg1, ..., Term0),
                  NewFieldValue = transform(OldFieldValue ^ Rest := FieldValue),
                  Term = 'Field :='(Arg1, ..., Term0, NewFieldValue).
</pre>
     <p>Examples:

     <p><code>Term&nbsp;^&nbsp;field&nbsp;:=&nbsp;FieldValue</code><!-- /@w --> is equivalent
to <code>'field&nbsp;:='(Term,&nbsp;FieldValue)</code><!-- /@w -->.

     <p><code>Term&nbsp;^&nbsp;field(Arg)&nbsp;:=&nbsp;FieldValue</code><!-- /@w --> is equivalent
to <code>'field&nbsp;:='(Arg,&nbsp;Term,&nbsp;FieldValue)</code><!-- /@w -->.

     <p><code>Term&nbsp;^&nbsp;field1(Arg1)&nbsp;^&nbsp;field2(Arg2)&nbsp;:=&nbsp;FieldValue</code><!-- /@w --> is equivalent
to the code
     <pre class="example">          OldField1 = field1(Arg1, Term),
          NewField1 = 'field2 :='(Arg2, OldField1, FieldValue),
          Result = 'field1 :='(Arg1, Term, NewField1)
</pre>
     </dl>

<div class="node">
<a name="Unification-expressions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Conditional-expressions">Conditional expressions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Record-syntax">Record syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data_002dterms">Data-terms</a>

</div>

<h4 class="subsection">2.13.3 Unification expressions</h4>

<p>A unification expression is an expression of the form

<pre class="example">     X @ Y
</pre>
   <p class="noindent">where <var>X</var> and <var>Y</var> are data-terms.

   <p>The meaning of a unification expression is that the arguments are unified,
and the expression is equivalent to the unified value.

   <p>The strict sequential operational semantics (see <a href="#Semantics">Semantics</a>) of an
expression <code>X&nbsp;@&nbsp;Y</code><!-- /@w --> is that the expression is replaced by a
fresh variable <var>Z</var>, and immediately after <var>Z</var> is evaluated,
the conjunction <code>Z&nbsp;=&nbsp;X,&nbsp;Z&nbsp;=&nbsp;Y</code><!-- /@w --> is evaluated.

   <p>For example

<pre class="example">     p(X @ f(_, _), X).
</pre>
   <p class="noindent">is equivalent to

<pre class="example">     p(H1, H2) :-
             H1 = X,
             H1 = f(_, _),
             H2 = X.
</pre>
   <p>Unification expressions are most useful when writing switches
(see <a href="#Determinism-checking-and-inference">Determinism checking and inference</a>).  The arguments
of a unification expression are examined when checking for
switches.  The arguments of an equivalent user-defined function
would not be.

<div class="node">
<a name="Conditional-expressions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Lambda-expressions">Lambda expressions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Unification-expressions">Unification expressions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data_002dterms">Data-terms</a>

</div>

<h4 class="subsection">2.13.4 Conditional expressions</h4>

<p>A conditional expression is an expression of either of the two following
forms

<pre class="example">     (if <var>Goal</var> then <var>Expression1</var> else <var>Expression2</var>)
     (<var>Goal</var> -&gt; <var>Expression1</var> ; <var>Expression2</var>)
</pre>
   <p class="noindent"><var>Goal</var> is a goal; <var>Expression1</var> and <var>Expression2</var> are
both data-terms. The semantics of a conditional expression is that
if <var>Goal</var> is true, then the expression has the meaning of
<var>Expression1</var>, else the expression has the meaning of <var>Expression2</var>.

   <p>If <var>Goal</var> takes the form <code>some [X, Y, Z] ...</code> then the scope of
<var>X</var>, <var>Y</var>, and <var>Z</var> includes <var>Expression1</var>.

<div class="node">
<a name="Lambda-expressions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Higher_002dorder-function-applications">Higher-order function applications</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Conditional-expressions">Conditional expressions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data_002dterms">Data-terms</a>

</div>

<h4 class="subsection">2.13.5 Lambda expressions</h4>

<p>A lambda expression is a compound term of one of the following forms

<pre class="example">     pred(Arg1::Mode1, Arg2::Mode2, ...) is Det :- Goal
     pred(Arg1::Mode1, Arg2::Mode2, ..., DCGMode0, DCGMode1) is Det --&gt; DCGGoal
     func(Arg1::Mode1, Arg2::Mode2, ...) = (Result::Mode) is Det :- Goal
     func(Arg1, Arg2, ...) = (Result) is Det :- Goal
     func(Arg1, Arg2, ...) = Result :- Goal
</pre>
   <p class="noindent">where Arg1, Arg2, <small class="dots">...</small> are zero or more data-terms,
Result is a data-term,
Mode1, Mode2, <small class="dots">...</small> are zero or more modes (see <a href="#Modes">Modes</a>),
DCGMode0 and DCGMode1 are modes (see <a href="#Modes">Modes</a>),
Det is a determinism (see <a href="#Determinism">Determinism</a>),
Goal is a goal (see <a href="#Goals">Goals</a>),
and DCGGoal is a DCG Goal (see <a href="#DCG_002dgoals">DCG-goals</a>). 
The &lsquo;<samp><span class="samp">:- Goal</span></samp>&rsquo; part is optional;
if it is not specified, then &lsquo;<samp><span class="samp">:- true</span></samp>&rsquo; is assumed. 
A lambda expression denotes a higher-order predicate or function term
whose value is the predicate or function of the specified arguments
determined by the specified goal.  See <a href="#Higher_002dorder">Higher-order</a>.

   <p>A lambda expression introduces a new scope: any variables occurring in
the arguments Arg1, Arg2, <small class="dots">...</small> are locally quantified, i.e. 
any occurrences of variables with that name in the lambda
expression are considered to name a different variable than any
variables with the same name that occur outside of the
lambda expression.  For variables which occur in Result or Goal,
but not in the arguments, the usual Mercury rules for implicit
quantification apply (see <a href="#Implicit-quantification">Implicit quantification</a>).

   <p>The form of lambda expression using &lsquo;<samp><span class="samp">--&gt;</span></samp>&rsquo; as its top level functor
is a syntactic abbreviation: an expression of the form

<pre class="example">     pred(Var1::Mode1, Var2::Mode2, ..., DCGMode0, DCGMode1) is Det --&gt; DCGGoal
</pre>
   <p class="noindent">is equivalent to

<pre class="example">     pred(Var1::Mode1, Var2::Mode2, ...,
         DCGVar0::DCGMode0, DCGVar1::DCGMode1) is Det :- Goal
</pre>
   <p class="noindent">where DCGVar0 and DCGVar1 are fresh variables,
and Goal is the result of &lsquo;<samp><span class="samp">DCG-transform(DCGVar0, DCGVar1, DCGGoal)</span></samp>&rsquo;
where DCG-transform is the function specified in <a href="#DCG_002dgoals">DCG-goals</a>.

<div class="node">
<a name="Higher-order-function-applications"></a>
<a name="Higher_002dorder-function-applications"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Explicit-type-qualification">Explicit type qualification</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Lambda-expressions">Lambda expressions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data_002dterms">Data-terms</a>

</div>

<h4 class="subsection">2.13.6 Higher-order function applications</h4>

<p>A higher-order function application is a compound term of one
of the following two forms

<pre class="example">     apply(<var>Func</var>, <var>Arg1</var>, <var>Arg2</var>, ..., <var>ArgN</var>)
     <var>FuncVar</var>(<var>Arg1</var>, <var>Arg2</var>, ..., <var>ArgN</var>)
</pre>
   <p class="noindent">where <var>N</var> &gt;= 0, <var>Func</var> is a term of type
&lsquo;<samp><span class="samp">func(T1, T2, ..., Tn) = T</span></samp>&rsquo;, <var>FuncVar</var> is a variable
of that type, and
<var>Arg1</var>, <var>Arg2</var>, <small class="dots">...</small>, <var>ArgN</var> are terms of types
&lsquo;<samp><span class="samp">T1</span></samp>&rsquo;, &lsquo;<samp><span class="samp">T2</span></samp>&rsquo;, <small class="dots">...</small>, &lsquo;<samp><span class="samp">Tn</span></samp>&rsquo;. 
The type of the higher-order function application term is <var>T</var>. 
It denotes the result of applying the specified function to the
specified arguments.  See <a href="#Higher_002dorder">Higher-order</a>.

<div class="node">
<a name="Explicit-type-qualification"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Higher_002dorder-function-applications">Higher-order function applications</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data_002dterms">Data-terms</a>

</div>

<h4 class="subsection">2.13.7 Explicit type qualification</h4>

<p>Explicit type qualifications are occasionally useful
to resolve ambiguities that can arise from overloading
or polymorphic types.

   <p>An explicit type qualification expression is a term of the form

<pre class="example">     <var>Term</var> : <var>Type</var>
</pre>
   <p class="noindent"><var>Term</var> must be a valid data-term. 
<var>Type</var> must be a valid type (see <a href="#Types">Types</a>).

   <p>An explicit type qualification expression constrains
the specified term to have the specified type. 
Apart from that, the meaning of an explicit type qualification
expression is just the same as the specified <var>Term</var>.

   <p>Currently we also support the following alternative syntax for
type qualification:

<pre class="example">     with_type(<var>Term</var>, <var>Type</var>)
</pre>
   <p class="noindent">or equivalently, as it is more commonly written,

<pre class="example">     <var>Term</var> `with_type` <var>Type</var>
</pre>
   <div class="node">
<a name="Variable-scoping"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Implicit-quantification">Implicit quantification</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Data_002dterms">Data-terms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.14 Variable scoping</h3>

<p>There are three sorts of variables in Mercury: ordinary variables,
type variables, and inst variables.

   <p>Variables occurring in types are called type variables. 
Variables occurring in insts or modes are called inst variables. 
Variables that occur in data-terms,
and that are not inst variables
or type variables, are called ordinary variables.

   <p>(Type variables can occur in data-terms in the right-hand [<var>Type</var>]
operand of an explicit type qualification. 
Inst variables can occur in data-terms in the right-hand [<var>Mode</var>]
operand of an explicit mode qualification.  Apart from that,
all other variables in data-terms are ordinary variables.)

   <p>The three different variable sorts occupy different namespaces:
there is no semantic relationship between two variables of different sorts
(e.g. a type variable and an ordinary variable) even if they happen to
share the same name. 
(However, as a matter of programming style, it is generally a
bad idea to use the same name for variables of different sorts
in the same clause.)

   <p>The scope of ordinary variables is the clause or declaration in which
they occur, unless they are quantified, either explicitly
(see <a href="#Goals">Goals</a>) or implicitly (see <a href="#Implicit-quantification">Implicit quantification</a>).

   <p>The scope of type variables in a predicate or function's type
declaration extends over any explicit type qualifications
(see <a href="#Explicit-type-qualification">Explicit type qualification</a>) in the clauses for that
predicate or function, and over &lsquo;<samp><span class="samp">pragma type_spec</span></samp>&rsquo;
(see <a href="#Type-specialization">Type specialization</a>) declarations for that predicate or
function, so that explicit type qualifications and
&lsquo;<samp><span class="samp">pragma type_spec</span></samp>&rsquo; declarations can refer to those
type variables. The scope of any type variables in an explicit
type qualification which do not occur in the predicate or function's
type declaration is the clause in which they occur.

   <p>The scope of inst variables is the clause or declaration in which
they occur.

<div class="node">
<a name="Implicit-quantification"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Elimination-of-double-negation">Elimination of double negation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variable-scoping">Variable scoping</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.15 Implicit quantification</h3>

<p>The rule for implicit quantification in Mercury
is not the same as the usual one in mathematical logic. 
In Mercury, variables that do not occur in the head of a clause
are implicitly existentially quantified around their closest enclosing scope
(in a sense to be made precise in the following paragraphs). 
This allows most existential quantifiers to be omitted,
and leads to more concise code.

   <p>An occurrence of a variable is <dfn>in a negated context</dfn>
if it is in a negation,
in a universal quantification,
in the condition of an if-then-else,
in an inequality,
or in a lambda expression.

   <p>Two goals are <dfn>parallel</dfn>
if they are different disjuncts of the same disjunction,
or if one is the &ldquo;else&rdquo; part of an if-then-else
and the other goal is either the &ldquo;then&rdquo; part or the condition
of the if-then-else,
or if they are the goals of disjoint (distinct and non-overlapping)
lambda expressions.

   <p>If a variable occurs in a negated context
and does not occur outside of that negated context other than in parallel goals
(and in the case of a variable in the condition of an if-then-else,
other than in the &ldquo;then&rdquo; part of the if-then-else),
then that variable is implicitly existentially quantified inside the negation.

<div class="node">
<a name="Elimination-of-double-negation"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Implicit-quantification">Implicit quantification</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syntax">Syntax</a>

</div>

<h3 class="section">2.16 Elimination of double negation</h3>

<p>The treatment of inequality, universal quantification,
implication, and logical equivalence as abbreviations
can cause the introduction of double negations
which could make otherwise well-formed code mode-incorrect. 
To avoid this problem, the language specifies that
after syntax analysis and implicit quantification,
and before mode analysis is performed,
the implementation must delete any double negations
and must replace any negations of conjunctions of negations
with disjunctions.  (Both of these transformations
preserve the logical meaning and type-correctness of the code,
and they preserve or improve mode-correctness:
they never transform code fragments that would be
well-moded into ones that would be ill-moded.)

<div class="node">
<a name="Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Modes">Modes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Syntax">Syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Types</h2>

<p>The type system is based on many-sorted logic, and supports polymorphism,
type classes (see <a href="#Type-classes">Type classes</a>), and existentially quantified types
(see <a href="#Existential-types">Existential types</a>).

<ul class="menu">
<li><a accesskey="1" href="#Builtin-types">Builtin types</a>
<li><a accesskey="2" href="#User_002ddefined-types">User-defined types</a>
<li><a accesskey="3" href="#Predicate-and-function-type-declarations">Predicate and function type declarations</a>
<li><a accesskey="4" href="#Field-access-functions">Field access functions</a>
</ul>

<div class="node">
<a name="Builtin-types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#User_002ddefined-types">User-defined types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Types">Types</a>

</div>

<h3 class="section">3.1 Builtin types</h3>

<p>Certain special types are builtin, or are defined in the Mercury library:

     <dl>
<dt>Primitive types: <code>char</code>, <code>int</code>, <code>float</code>, <code>string</code>.<dd>There is a special syntax for constants of type <code>int</code>, <code>float</code>,
and <code>string</code>.  (For <code>char</code>, the standard syntax suffices.)

     <br><dt>Predicate types: <code>pred</code>, <code>pred(T)</code>, <code>pred(T1, T2)</code>, <small class="dots">...</small><dt>Function types: <code>(func) = T</code>, <code>func(T1) = T</code>,<dt><code>func(T1, T2) = T</code>, <small class="dots">...</small><dd>These higher-order function and predicate types are used to pass procedure
addresses and closures to other predicates.  See <a href="#Higher_002dorder">Higher-order</a>.

     <br><dt>Tuple types: <code>{}</code>, <code>{T}</code>, <code>{T1, T2}</code>, <small class="dots">...</small>.<dd>A tuple type is equivalent to a discriminated union type
(see <a href="#Discriminated-unions">Discriminated unions</a>) with declaration
     <pre class="example">          :- type {Arg1, Arg2, ..., ArgN}
                  ---&gt; { {Arg1, Arg2, ..., ArgN} }.
</pre>
     <br><dt>The universal type: <code>univ</code>.<dd>The type <code>univ</code> is defined in the standard library module <code>univ</code>,
along with the predicates <code>type_to_univ/2</code> and <code>univ_to_type/2</code>. 
With those predicates, any type can be converted to the universal type
and back again. 
The universal type is useful for situations
where you need heterogeneous collections.

     <br><dt>The &ldquo;state-of-the-world&rdquo; type: <code>io.state</code>.<dd>The type <code>io.state</code> is defined in the standard library module <code>io</code>,
and represents the state of the world. 
Predicates which perform I/O are passed the old state of the world
and produce a new state of the world. 
In this way, we can give a declarative semantics to code that performs I/O.

   </dl>

<div class="node">
<a name="User-defined-types"></a>
<a name="User_002ddefined-types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Predicate-and-function-type-declarations">Predicate and function type declarations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Builtin-types">Builtin types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Types">Types</a>

</div>

<h3 class="section">3.2 User-defined types</h3>

<p>New types can be introduced with &lsquo;<samp><span class="samp">:- type</span></samp>&rsquo; declarations. 
There are several categories of derived types:

<ul class="menu">
<li><a accesskey="1" href="#Discriminated-unions">Discriminated unions</a>
<li><a accesskey="2" href="#Equivalence-types">Equivalence types</a>
<li><a accesskey="3" href="#Abstract-types">Abstract types</a>
</ul>

<div class="node">
<a name="Discriminated-unions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Equivalence-types">Equivalence types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User_002ddefined-types">User-defined types</a>

</div>

<h4 class="subsection">3.2.1 Discriminated unions</h4>

<p>These encompass both enumeration and record types in other languages. 
A derived type is defined using &lsquo;<samp><span class="samp">:- type </span><var>type</var><span class="samp"> ---&gt; </span><var>body</var></samp>&rsquo;. 
(Note there are <em>three</em> dashes in that arrow. 
It should not be confused with the two-dash arrow used for DCGs
or the one-dash arrow used for if-then-else.) 
If the <var>type</var> term is a functor of arity zero
(i.e. one having zero arguments),
it names a monomorphic type. 
Otherwise, it names a polymorphic type;
the arguments of the functor must be distinct type variables. 
The <var>body</var> term is defined as
a sequence of constructor definitions separated by semi-colons.

   <p>Ordinarily, each constructor definition must be a functor whose arguments
(if any) are types.  Ordinary discriminated union definitions must be
<dfn>transparent</dfn>: all type variables occurring in the <var>body</var> must
also occur in the <var>type</var>.

   <p>However, constructor definitions can optionally be existentially typed. 
In that case, the functor will be preceded by an existential type
quantifier and can optionally be followed by an existential type
class constraint.  For details, see <a href="#Existential-types">Existential types</a>. 
Existentially typed discriminated union definitions need not be
transparent.

   <p>The arguments of constructor definitions may be labelled. 
These labels cause the compiler to generate functions which can
be used to conveniently select and update fields of a term
in a manner independent of the definition of the type
(see <a href="#Field-access-functions">Field access functions</a>). A labelled argument has the
form <var>fieldname</var><code>&nbsp;::&nbsp;</code><var>Type</var><!-- /@w -->. It is an error for
two fields in the same module to have the same label.

   <p>Here are some examples of discriminated union definitions:

<pre class="example">     :- type fruit
             ---&gt;    apple
             ;       orange
             ;       banana
             ;       pear.
     
     :- type strange
             ---&gt;    foo(int)
             ;       bar(string).
     
     :- type employee
             ---&gt;    employee(
                            name        :: string,
                            age         :: int,
                            department  :: string
                     ).
     
     :- type tree
             ---&gt;    empty
             ;       leaf(int)
             ;       branch(tree, tree).
     
     :- type list(T)
             ---&gt;    []
             ;       [T | list(T)].
     
     :- type pair(T1, T2)
             ---&gt;    T1 - T2.
</pre>
   <p>If the body of a discriminated union type definition
contains a term whose top-level functor is <code>';'/2</code>,
the semi-colon is normally assumed to be a separator. 
This makes it difficult to define a type
whose constructors include <code>';'/2</code>. 
To allow this, curly braces can be used to quote the semi-colon. 
It is then also necessary to quote curly braces. 
The following example illustrates this:

<pre class="example">     :- type tricky
             ---&gt;    { int ; int }
             ;       { { int } }.
</pre>
   <p>This defines a type with two constructors, <code>';'/2</code> and <code>'{}'/1</code>,
whose argument types are all <code>int</code>. We recommend against using
constructors named <code>'{}'</code> because of the possibility of confusion
with the builtin tuple types.

   <p>Each discriminated union type definition introduces a distinct type. 
Mercury considers two discriminated union types that have the same bodies
to be distinct types (name equivalence). 
Having two different definitions of a type with the same name and arity in
the same module is an error.

   <p>Constructors may be overloaded among different types:
there may be any number of constructors with a given name and arity,
so long as they all have different types. 
However, there must not be more than one constructor
with the same name, arity, and result type in the same module. 
(There is no particularly good reason for this restriction;
in the future we may allow several such functors
as long as they have different argument types.) 
Note that excessive overloading of constructors can slow down type checking
and can make the program confusing for human readers,
so overloading should not be over-used.

<!-- XXX The `where direct_arg' attribute is not documented because it requires -->
<!-- the user has a detailed understanding of the type representation, and -->
<!-- is very implementation specific. The following is for implementors. -->
<!-- Discriminated union type definitions may be followed by a -->
<!-- @samp{direct_arg} attribute of the following form: -->
<!-- @example -->
<!-- where direct_arg is @var{ctors} -->
<!-- @end example -->
<!-- @noindent -->
<!-- where @var{ctors} is a list of @var{functor-name} / @var{functor-arity}. -->
<!-- The functor arities must always be one. -->
<!-- The attribute notifies importing modules that each of the functors -->
<!-- listed is to be represented as a tagged pointer to its argument. The -->
<!-- argument type must be known, when compiling the module that the type is -->
<!-- defined in, to not require the use of the tag bits. The compiler will -->
<!-- emit an error message otherwise.  The compiler will silently ignore -->
<!-- functors which require a secondary tag. -->
<!-- The optimised type representation is usually only applied if the -->
<!-- argument type is defined in the interface section of the same module. -->
<!-- This attribute allows the programmer to also apply it when the argument -->
<!-- type is known to the defining module, but not necessarily modules which -->
<!-- import the top-level type. -->
<!-- Ideally, the @samp{direct_arg} attribute would be automatically -->
<!-- generated when making an interface file, so the user would never need to -->
<!-- write it manually.  At this time, the compiler does not have enough -->
<!-- information when making interface files. -->
<div class="node">
<a name="Equivalence-types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Abstract-types">Abstract types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Discriminated-unions">Discriminated unions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User_002ddefined-types">User-defined types</a>

</div>

<h4 class="subsection">3.2.2 Equivalence types</h4>

<p>These are type abbreviations. 
They are defined using &lsquo;<samp><span class="samp">==</span></samp>&rsquo; as follows. 
They may be polymorphic.

<pre class="example">     :- type money == int.
     :- type assoc_list(KeyType, ValueType)
             == list(pair(KeyType, ValueType)).
</pre>
   <p>Equivalence type definitions must be transparent. 
Unlike discriminated union type definitions,
equivalence type definitions must not be cyclic;
that is, the type on the left hand side of the &lsquo;<samp><span class="samp">==</span></samp>&rsquo;
(&lsquo;<samp><span class="samp">assoc_list</span></samp>&rsquo; and &lsquo;<samp><span class="samp">money</span></samp>&rsquo; in the examples above)
must not occur on the right hand side of the &lsquo;<samp><span class="samp">==</span></samp>&rsquo;.

   <p>Mercury treats an equivalence type
as an abbreviation for the type on the right hand side of the definition;
the two are equivalent in all respects
in scopes where the equivalence type is visible.

<div class="node">
<a name="Abstract-types"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Equivalence-types">Equivalence types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User_002ddefined-types">User-defined types</a>

</div>

<h4 class="subsection">3.2.3 Abstract types</h4>

<p>These are types whose implementation is hidden. 
The type declarations

<pre class="example">     :- type t1.
     :- type t2(T1, T2).
</pre>
   <p class="noindent">declare types <code>t1/0</code> and <code>t2/2</code> to be abstract types. 
Such declarations are only useful in the interface section of a module. 
This means that the type names will be exported,
but the constructors (functors) for these types will not be exported. 
The implementation section of a module
must give a definition for all of the abstract types
named in the interface section of the module. 
Abstract types may be defined as either discriminated union types
or as equivalence types.

<div class="node">
<a name="Predicate-and-function-type-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Field-access-functions">Field access functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#User_002ddefined-types">User-defined types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Types">Types</a>

</div>

<h3 class="section">3.3 Predicate and function type declarations</h3>

<p>The argument types of each predicate
must be explicitly declared with a &lsquo;<samp><span class="samp">:- pred</span></samp>&rsquo; declaration. 
The argument types and return type of each function must be
explicitly declared with a &lsquo;<samp><span class="samp">:- func</span></samp>&rsquo; declaration. 
For example:

<pre class="example">     :- pred is_all_uppercase(string).
     
     :- func strlen(string) = int.
</pre>
   <p>Predicates and functions can be polymorphic; that is, their
declarations can include type variables.  For example:

<pre class="example">     :- pred member(T, list(T)).
     
     :- func length(list(T)) = int.
</pre>
   <p>A predicate or function can by declared to have a given higher-order
type (see <a href="#Higher_002dorder">Higher-order</a>) by using <code>`with_type`</code> in the type declaration. 
This is useful where several predicates or functions need to have the
same type signature, which often occurs for typeclass method implementations
(see <a href="#Type-classes">Type classes</a>), and for predicates to be passed as higher-order terms.

   <p>For example,

<pre class="example">     :- type foldl_pred(T, U) == pred(T, U, U).
     :- type foldl_func(T, U) == (func(T, U) = U).
     
     :- pred p(int) `with_type` foldl_pred(T, U).
     :- func f(int) `with_type` foldl_func(T, U).
</pre>
   <p class="noindent">is equivalent to

<pre class="example">     :- pred p(int, T, U, U).
     :- pred f(int, T, U) = U.
</pre>
   <p>Type variables in predicate and function declarations
are implicitly universally quantified by default;
that is, the predicate or function may be called with arguments
and (in the case of functions) return value
whose actual types are any instance of the types
specified in the declaration.  For example,
the function &lsquo;<samp><span class="samp">length/1</span></samp>&rsquo; declared above
could be called with the argument having
type &lsquo;<samp><span class="samp">list(int)</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">list(float)</span></samp>&rsquo;,
or &lsquo;<samp><span class="samp">list(list(int))</span></samp>&rsquo;, etc.

   <p>Type variables in predicate and function declarations can
also be existentially quantified; this is discussed in
<a href="#Existential-types">Existential types</a>.

   <p>There must only be one predicate with a given name and arity in each module,
and only one function with a given name and arity in each module. 
It is an error to declare the same predicate or function twice.

   <p>There must be at least one clause defined for each declared predicate or
function, except for those defined using the foreign language interface
(see <a href="#Foreign-language-interface">Foreign language interface</a>). 
However, Mercury implementations are permitted to provide a method
of processing Mercury programs in which such errors are not reported
until and unless the predicate or function is actually called. 
(The University of Melbourne Mercury implementation provides this
with its &lsquo;<samp><span class="samp">--allow-stubs</span></samp>&rsquo; option.  This can be useful during
program development, since it allows you to execute parts of
a program while the program's implementation is still incomplete.)

   <p>Note that a predicate defined using DCG notation (see <a href="#DCG_002drules">DCG-rules</a>)
will appear to be defined with two fewer arguments than it is declared
with.  It will also appear to be called with two fewer arguments when
called from predicates defined using DCG notation.  However, when called
from an ordinary predicate or function, it must have all the arguments
it was declared with.

   <p>The compiler infers the types of data-terms, and in particular the types
of variables and overloaded constructors, functions, and predicates. 
A <dfn>type assignment</dfn> is an assignment of a type
to every variable and of a particular constructor, function, or predicate
to every name in a clause. 
A type assignment is <dfn>valid</dfn> if it satisfies the following conditions.

   <p>Each constructor in a clause
must have been declared in at least one visible type declaration. 
The type assigned to each constructor term
must match one of the type declarations for that constructor,
and the types assigned to the arguments of that constructor
must match the argument types specified in that type declaration.

   <p>The type assigned to each function call term
must match the return type of one of the &lsquo;<samp><span class="samp">:- func</span></samp>&rsquo; declarations
for that function, and the types assigned to the arguments of that function
must match the argument types specified in that type declaration.

   <p>The type assigned to each predicate argument must match
the type specified in one of the &lsquo;<samp><span class="samp">:- pred</span></samp>&rsquo; declarations for that predicate. 
The type assigned to each head argument in a predicate clause must exactly match
the argument type specified in the corresponding &lsquo;<samp><span class="samp">:- pred</span></samp>&rsquo; declaration.

   <p>The type assigned to each head argument in a function clause must exactly match
the argument type specified in the corresponding &lsquo;<samp><span class="samp">:- func</span></samp>&rsquo; declaration,
and the type assigned to the result term in a function clause must exactly
match the result type specified in the corresponding &lsquo;<samp><span class="samp">:- func</span></samp>&rsquo; declaration.

   <p>The type assigned to each data-term with an explicit type qualification
(see <a href="#Explicit-type-qualification">Explicit type qualification</a>) must match the type specified
by the type qualification expression<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>.

   <p>(Here &ldquo;match&rdquo; means to be an instance of,
i.e. to be identical to for some substitution of the type parameters,
and &ldquo;exactly match&rdquo; means to be identical up to renaming of type parameters.)

   <p>One type assignment <var>A</var> is said to be
<dfn>more general</dfn> than another type assignment <var>B</var>
if there is a binding of the type parameters in A
that makes it identical (up to renaming of parameters) to B. 
If there is more than one valid type assignment,
the compiler must choose the most general one. 
If there are two valid type assignments which are not identical up to renaming
and neither of which is more general than the other,
then there is a type ambiguity, and compiler must report an error. 
A clause is <dfn>type-correct</dfn>
if there is a unique (up to renaming) most general valid type assignment. 
Every clause in a Mercury program must be type-correct.

<div class="node">
<a name="Field-access-functions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Predicate-and-function-type-declarations">Predicate and function type declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Types">Types</a>

</div>

<h3 class="section">3.4 Field access functions</h3>

<p>Fields of constructors of discriminated union types may be
labelled (see <a href="#Discriminated-unions">Discriminated unions</a>). These labels cause the
compiler to generate functions which can be used to select and update
fields of a term in a manner independent of the definition of the type.

   <p>The Mercury language includes syntactic sugar to make it more convenient
to select and update fields inside nested terms (see <a href="#Record-syntax">Record syntax</a>)
and to select and update fields of the DCG arguments of a
clause (see <a href="#DCG_002dgoals">DCG-goals</a>).

<ul class="menu">
<li><a accesskey="1" href="#Field-selection">Field selection</a>
<li><a accesskey="2" href="#Field-update">Field update</a>
<li><a accesskey="3" href="#User_002dsupplied-field-access-function-declarations">User-supplied field access function declarations</a>
<li><a accesskey="4" href="#Field-access-examples">Field access examples</a>
</ul>

<div class="node">
<a name="Field-selection"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Field-update">Field update</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Field-access-functions">Field access functions</a>

</div>

<h4 class="subsection">3.4.1 Field selection</h4>

<pre class="example">     <var>field</var>(<var>Term</var>)
</pre>
   <p>Each field label &lsquo;<samp><var>field</var></samp>&rsquo; in a constructor causes generation
of a field selection function &lsquo;<samp><var>field</var><span class="samp">/1</span></samp>&rsquo;, which takes a data-term
of the same type as the constructor and returns the value of the
labelled field, failing if the top-level constructor of the argument
is not the constructor containing the field.

   <p>If the declaration of the field is in the interface section of the module,
the corresponding field selection function is also exported from the module.

   <p>By default, this function has no declared modes &mdash; the modes are inferred at
each call to the function. However, the type and modes of this function may be
explicitly declared, in which case it will have only the declared modes.

   <p>To create a higher-order term from a field selection function, an
explicit lambda expression must be used, unless a single mode
declaration is supplied for the field selection function.

<div class="node">
<a name="Field-update"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#User_002dsupplied-field-access-function-declarations">User-supplied field access function declarations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Field-selection">Field selection</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Field-access-functions">Field access functions</a>

</div>

<h4 class="subsection">3.4.2 Field update</h4>

<pre class="example">     '<var>field</var> :='(<var>Term</var>, <var>ValueTerm</var>)
</pre>
   <p>Each field label &lsquo;<samp><var>field</var></samp>&rsquo; in a constructor causes generation
of a field update function &lsquo;<samp><span class="samp">'</span><var>field</var><span class="samp"> :='/2</span></samp>&rsquo;. 
The first argument of this function is a data-term of the same type as the
constructor. The second argument is a data-term of the same type as the
labelled field. The return value is a copy of the first argument with
value of the labelled field replaced by the second argument. 
&lsquo;<samp><span class="samp">'</span><var>field</var><span class="samp"> :='/2</span></samp>&rsquo; fails if the top-level constructor of the
first argument is not the constructor containing the labelled field.

   <p>If the declaration of the field is in the interface section of the module,
the corresponding field update function is also exported from the module.

   <p>By default, this function has no declared modes &mdash; the modes are inferred at
each call to the function. However, the type and modes of this function may be
explicitly declared, in which case it will have only the declared modes.

   <p>To create a higher-order term from a field update function, an
explicit lambda expression must be used, unless a single mode
declaration is supplied for the field update function.

   <p>Some fields cannot be updated using field update functions. 
For the constructor &lsquo;<samp><span class="samp">unsettable/2</span></samp>&rsquo; below, neither field may be updated
because the resulting term would not be well-typed. A future release
may allow multiple fields to be updated by a single expression to avoid
this problem.

<pre class="example">     :- type unsettable
             ---&gt; some [T] unsettable(
                     unsettable1 :: T,
                     unsettable2 :: T
             ).
</pre>
   <div class="node">
<a name="User-supplied-field-access-function-declarations"></a>
<a name="User_002dsupplied-field-access-function-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Field-access-examples">Field access examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Field-update">Field update</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Field-access-functions">Field access functions</a>

</div>

<h4 class="subsection">3.4.3 User-supplied field access function declarations</h4>

<p>Type and mode declarations for compiler-generated field access functions
for fields of constructors local to a module may be placed in the interface
section of the module. This allows the implementation of a type to be hidden
while still allowing client modules to use record syntax to manipulate values
of the type. Supplying a type declaration and a single mode declaration also
allows higher-order terms to be created from a field access function without
using explicit lambda expressions.

   <p>Declarations for field access functions for fields occurring in the interface
section of a module must also occur in the interface section.

   <p>Declarations and clauses for field access functions can also be supplied
for fields which are not a part of any type. This is useful when the data
structures of a program change so that a value which was previously stored
as part of a type is now computed each time it is requested. It also
allows record syntax to be used for type class methods.

   <p>User-declared field access functions may take extra arguments. 
For example, the Mercury standard library module <code>map</code> contains
the following functions:
<pre class="example">     :- func elem(K, map(K, V)) = V is semidet.
     :- func 'elem :='(K, map(K, V), V) = map(K, V).
</pre>
   <p>Field access syntax may be used at the top-level of <code>func</code> and
<code>mode</code> declarations and in the head of clauses.  For instance:
<pre class="example">     :- func map(K, V) ^ elem(K) = V.
     :- mode in        ^ in      = out is semidet.
     Map ^ elem(Key) = map.lookup(Map, Key).
     
     :- func (map(K, V) ^ elem(K) := V)  = V.
     :- mode (in        ^ in      := in) = out is semidet.
     (Map ^ elem(Key) := Value) = map.set(Map, Key, Value).
</pre>
   <p>The Mercury standard library modules <code>array</code> and <code>bt_array</code>
define similar functions.

<div class="node">
<a name="Field-access-examples"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#User_002dsupplied-field-access-function-declarations">User-supplied field access function declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Field-access-functions">Field access functions</a>

</div>

<h4 class="subsection">3.4.4 Field access examples</h4>

<p>The examples make use of the following type declarations:

<pre class="example">     :- type type1
             ---&gt; type1(
                     field1 :: type2,
                     field2 :: string
             ).
     
     :- type type2
             ---&gt; type2(
                     field3 :: int,
                     field4 :: int
             ).
     
</pre>
   <p>The compiler generates some field access functions for &lsquo;<samp><span class="samp">field1</span></samp>&rsquo;. 
The functions generated for the other fields are similar.

<pre class="example">     +:- func type1 ^ field1 = type2.
     +type1(Field1, _) ^ field1 = Field1.
     
     +:- func (type1 ^ field1 := type2) = type1.
     +(type1(_, Field2) ^ field1 := Field1) = type1(Field1, Field2).
</pre>
   <p>Using these functions and the syntactic sugar described in
<a href="#Record-syntax">Record syntax</a>, programmers can write code such as

<pre class="example">     +:- func type1 ^ increment_field3 = type1.
     
     +Term0 ^ increment_field3 =
             Term0 ^ field1 ^ field3 := Term0 ^ field1 ^ field3 + 1.
</pre>
   <p>The compiler expands this into

<pre class="example">     incremental_field3(Term0) = Term :-
             OldField3 = field3(field1(Term0)),
     
             OldField1 = field1(Term0),
             NewField1 = 'field3 :='(OldField1, OldField3 + 1),
             Term = 'field1 :='(Term0, NewField1).
</pre>
   <p>The field access functions defined in the Mercury standard library
module &lsquo;<samp><span class="samp">map</span></samp>&rsquo; can be used as follows:

<pre class="example">     :- func update_field_in_map(map(int, type1), int, string)
                     = map(int, type1) is semidet.
     
     update_field_in_map(Map, Index, Value) =
                     Map ^ elem(Index) ^ field2 := Value.
</pre>
   <div class="node">
<a name="Modes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Unique-modes">Unique modes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Types">Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Modes</h2>

<ul class="menu">
<li><a accesskey="1" href="#Insts-modes-and-mode-definitions">Insts modes and mode definitions</a>
<li><a accesskey="2" href="#Predicate-and-function-mode-declarations">Predicate and function mode declarations</a>
<li><a accesskey="3" href="#Constrained-polymorphic-modes">Constrained polymorphic modes</a>
<li><a accesskey="4" href="#Different-clauses-for-different-modes">Different clauses for different modes</a>
</ul>

<div class="node">
<a name="Insts-modes-and-mode-definitions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Predicate-and-function-mode-declarations">Predicate and function mode declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modes">Modes</a>

</div>

<h3 class="section">4.1 Insts, modes, and mode definitions</h3>

<p>The <dfn>mode</dfn> of a predicate, or function, is a mapping
from the initial state of instantiation of the arguments of the predicate,
or the arguments and result of a function,
to their final state of instantiation. 
To describe states of instantiation,
we use information provided by the type system. 
Types can be viewed as regular trees with two kinds of nodes:
or-nodes representing types
and and-nodes representing constructors. 
The children of an or-node are the constructors
that can be used to construct terms of that type;
the children of an and-node are the types
of the arguments of the constructors. 
We attach mode information to the or-nodes of type trees.

   <p>An <dfn>instantiatedness tree</dfn> is an assignment
of an <dfn>instantiatedness</dfn> &mdash; either <dfn>free</dfn> or <dfn>bound</dfn> &mdash;
to each or-node of a type tree,
with the constraint that all descendants of a free node must be free.

   <p>A term is <dfn>approximated by</dfn> an instantiatedness tree
if for every node in the instantiatedness tree,

     <ul>
<li>if the node is &ldquo;free&rdquo;,
then the corresponding node in the term (if any)
is a free variable that does not share with any other variable
(we call such variables <dfn>distinct</dfn>);

     <li>if the node is &ldquo;bound&rdquo;,
then the corresponding node in the term (if any)
is a function symbol.

   </ul>

   <p>When an instantiatedness tree tells us that a variable is bound,
there may be several alternative function symbols to which it could be bound. 
The instantiatedness tree does not tell us which of these it is bound to;
instead for each possible function symbol it tells us exactly
which arguments of the function symbol will be free and which will be bound. 
The same principle applies recursively to these bound arguments.

   <p>Mercury's mode system allows users
to declare names for instantiatedness trees using declarations such as

<pre class="example">     :- inst listskel == bound( [] ; [free | listskel] ).
</pre>
   <p>This instantiatedness tree describes lists
whose skeleton is known but whose elements are distinct variables. 
As such, it approximates the term <code>[A,B]</code>
but not the term <code>[H|T]</code> (only part of the skeleton is known),
the term <code>[A,2]</code> (not all elements are variables),
or the term <code>[A,A]</code> (the elements are not distinct variables).

   <p>As a shorthand, the mode system provides <code>free</code> and <code>ground</code>
as names for instantiatedness trees all of whose nodes are free and
bound respectively (with the exception of solver type values which may
be semantically ground, but be defined in terms of non-ground solver
type values; see <a href="#Solver-types">Solver types</a> for more detail).  The shape of
these trees is determined by the type of the variable to which they
apply.

   <p>A more concise, alternative syntax exists for <code>bound</code> instantiatedness
trees:

<pre class="example">     :- inst maybeskel ---&gt; no ; yes(ground).
</pre>
   <p class="noindent">which is equivalent to writing

<pre class="example">     :- inst maybeskel == bound(no ; yes(ground)).
</pre>
   <p>As execution proceeds, variables may become more instantiated. 
A <dfn>mode mapping</dfn> is a mapping
from an initial instantiatedness tree to a final instantiatedness tree,
with the constraint that no node of the type tree
is transformed from bound to free. 
Mercury allows the user to specify mode mappings directly
by expressions such as <code>inst1 &gt;&gt; inst2</code>,
or to give them a name using declarations such as

<pre class="example">     :- mode m == inst1 &gt;&gt; inst2.
</pre>
   <p>Two standard shorthand modes are provided,
corresponding to the standard notions of inputs and outputs:

<pre class="example">     :- mode in == ground &gt;&gt; ground.
     :- mode out == free &gt;&gt; ground.
</pre>
   <p>Prolog fans who want to use the symbols &lsquo;<samp><span class="samp">+</span></samp>&rsquo; and &lsquo;<samp><span class="samp">-</span></samp>&rsquo;
can do so by simply defining them using a mode declaration:

<pre class="example">     :- mode (+) == in.
     :- mode (-) == out.
</pre>
   <p>These two modes are enough for most functions and predicates. 
Nevertheless, Mercury's mode system is sufficiently
expressive to handle more complex data-flow patterns,
including those involving partially instantiated data structures. 
(The current implementation does not handle
partially instantiated data structures yet.)

   <p>For example, consider an
interface to a database that associates data with keys, and provides
read and write access to the items it stores.  To represent accesses to
the database over a network, you would need declarations such as

<pre class="example">     :- type operation
             ---&gt;    lookup(key, data)
             ;       set(key, data).
     :- inst request
     	---&gt;	lookup(ground, free)
             ;       set(ground, ground).
     :- mode create_request == free &gt;&gt; request.
     :- mode satisfy_request == request &gt;&gt; ground.
</pre>
   <p>&lsquo;<samp><span class="samp">inst</span></samp>&rsquo; and &lsquo;<samp><span class="samp">mode</span></samp>&rsquo; declarations can be parametric. 
For example, the following declaration

<pre class="example">     :- inst listskel(Inst) ---&gt; [] ; [Inst | listskel(Inst)].
</pre>
   <p class="noindent">defines the inst &lsquo;<samp><span class="samp">listskel(Inst)</span></samp>&rsquo; to be a list skeleton
whose elements have inst &lsquo;<samp><span class="samp">Inst</span></samp>&rsquo;; you can then use insts
such as &lsquo;<samp><span class="samp">listskel(listskel(free))</span></samp>&rsquo;, which represents
the instantiation state of a list of lists of free variables. 
The standard library provides the parametric modes

<pre class="example">     :- mode in(Inst) == Inst &gt;&gt; Inst.
     :- mode out(Inst) == free &gt;&gt; Inst.
</pre>
   <p class="noindent">so that for example the mode &lsquo;<samp><span class="samp">create_request</span></samp>&rsquo; defined above
could have be defined as

<pre class="example">     :- mode create_request == out(request).
</pre>
   <p>There must not be more than one inst definition with the same name
and arity in the same module.  Similarly, there must not be more
than one mode definition with the same name and arity in the same module.

<div class="node">
<a name="Predicate-and-function-mode-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Constrained-polymorphic-modes">Constrained polymorphic modes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Insts-modes-and-mode-definitions">Insts modes and mode definitions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modes">Modes</a>

</div>

<h3 class="section">4.2 Predicate and function mode declarations</h3>

<p>A <dfn>predicate mode declaration</dfn>
assigns a mode mapping to each argument of a predicate. 
A <dfn>function mode declaration</dfn>
assigns a mode mapping to each argument of a function,
and a mode mapping to the function result. 
Each mode of a predicate or function is called a <dfn>procedure</dfn>. 
For example, given the mode names defined by

<pre class="example">     :- mode out_listskel ==
             free &gt;&gt; listskel.
     :- mode in_listskel ==
             listskel &gt;&gt; listskel.
</pre>
   <p class="noindent">the (type and) mode declarations of the function length and predicate append
are as follows:

<pre class="example">     :- func length(list(T)) = int.
     :- mode length(in_listskel) = out.
     :- mode length(out_listskel) = in.
     
     :- pred append(list(T), list(T), list(T)).
     :- mode append(in, in, out).
     :- mode append(out, out, in).
</pre>
   <p>Note that functions may have more than one mode, just like predicates;
functions can be reversible.

   <p>Alternately, the mode declarations for &lsquo;<samp><span class="samp">length</span></samp>&rsquo; could use
the standard library modes &lsquo;<samp><span class="samp">in/1</span></samp>&rsquo; and &lsquo;<samp><span class="samp">out/1</span></samp>&rsquo;:

<pre class="example">     :- func length(list(T)) = int.
     :- mode length(in(listskel)) = out.
     :- mode length(out(listskel)) = in.
</pre>
   <p>As for type declarations, a predicate or function can be defined
to have a given higher-order inst (see <a href="#Higher_002dorder-modes">Higher-order modes</a>) by using
<code>`with_inst`</code> in the mode declaration.

   <p>For example,

<pre class="example">     :- inst foldl_pred == (pred(in, in, out) is det).
     :- inst foldl_func == (func(in, in) = out is det).
     
     :- mode p(in) `with_inst` foldl_pred.
     :- mode f(in) `with_inst` foldl_func.
</pre>
   <p class="noindent">is equivalent to

<pre class="example">     :- mode p(in, in, in, out) is det.
     :- mode f(in, in, in) = out is det.
</pre>
   <p class="noindent">(&lsquo;<samp><span class="samp">is det</span></samp>&rsquo; is explained in <a href="#Determinism">Determinism</a>.)

   <p>If a predicate or function has only one mode, the &lsquo;<samp><span class="samp">pred</span></samp>&rsquo; and &lsquo;<samp><span class="samp">mode</span></samp>&rsquo;
declaration can be combined:

<pre class="example">     :- func length(list(T)::in) = (int::out).
     :- pred append(list(T)::in, list(T)::in, list(T)::out).
     
     :- pred p `with_type` foldl_pred(T, U) `with_inst` foldl_pred.
</pre>
   <p>If there is no mode declaration for a function, the compiler assumes
a default mode for the function in which all the arguments have mode &lsquo;<samp><span class="samp">in</span></samp>&rsquo;
and the result of the function has mode &lsquo;<samp><span class="samp">out</span></samp>&rsquo;.  (However, there
is no requirement that a function have such a mode; if there is any
explicit mode declaration, it overrides the default.)

   <p>A function or predicate mode declaration is an assertion by the programmer
that for all possible argument terms and (if applicable) result term
for the function or predicate
that are approximated (in our technical sense)
by the initial instantiatedness trees of the mode declaration
and all of whose free variables are distinct,
if the function or predicate succeeds then
the resulting binding of those argument terms and (if applicable)
result term will in turn be approximated
by the final instantiatedness trees of the mode declaration,
with all free variables again being distinct. 
We refer to such assertions as <dfn>mode declaration constraints</dfn>. 
These assertions are checked by the compiler,
which rejects programs if it cannot prove
that their mode declaration constraints are satisfied.

   <p>Note that with the usual definition of append, the mode

<pre class="example">     :- mode append(in_listskel, in_listskel, out_listskel).
</pre>
   <p class="noindent">would not be allowed, since it would create aliasing between the
different arguments &mdash; on success of the predicate, the list elements
would be free variables but they would not be distinct.

   <p>In Mercury it is always possible to call a procedure with an
argument that is more bound than the initial inst specified for that
argument in the procedure's mode declaration.  In such cases, the
compiler will insert additional unifications to ensure that the
argument actually passed to the procedure will have the inst specified. 
For example, if the predicate <code>p/1</code> has mode &lsquo;<samp><span class="samp">p(out)</span></samp>&rsquo;, you
can still call &lsquo;<samp><span class="samp">p(X)</span></samp>&rsquo; if <code>X</code> is ground.  The compiler will
transform this code to &lsquo;<samp><span class="samp">p(Y), X = Y</span></samp>&rsquo; where <code>Y</code> is a fresh
variable.  It is almost as if the predicate <code>p/1</code> has another mode
&lsquo;<samp><span class="samp">p(in)</span></samp>&rsquo;; we call such modes &ldquo;implied modes&rdquo;.

   <p>To make this concept precise, we introduce the following definition. 
A term <dfn>satisfies</dfn> an instantiatedness tree
if for every node in the instantiatedness tree,

     <ul>
<li>if the node is &ldquo;free&rdquo;,
then the corresponding node in the term (if any)
is either a distinct free variable,
or a function symbol.

     <li>if the node is &ldquo;bound&rdquo;,
then the corresponding node in the term (if any)
is a function symbol.

   </ul>

   <p>The <dfn>mode set</dfn> for a predicate or function
is the set of mode declarations for the predicate or function. 
A mode set is an assertion by the programmer
that the predicate should only be called with argument terms
that satisfy the initial instantiatedness trees
of one of the mode declarations in the set
(i.e. the specified modes and the modes they imply
are the only allowed modes for this predicate or function). 
We refer to the assertion associated with a mode set
as the <dfn>mode set constraint</dfn>;
these are also checked by the compiler.

   <p>A predicate or function <var>p</var> is <dfn>well-moded
with respect to a given mode declaration</dfn>
if given that the predicates and functions called by <var>p</var>
all satisfy their mode declaration constraints,
there exists an ordering of the conjuncts in each conjunction
in the clauses of <var>p</var> such that

     <ul>
<li><var>p</var> satisfies its mode declaration constraint, and
<li><var>p</var> satisfies the mode set constraint of all of the predicates and
functions it calls
</ul>

   <p>We say that a predicate or function is well-moded
if it is well-moded with respect to
all the mode declarations in its mode set,
and we say that a program is well-moded
if all its predicates and functions are well-moded.

   <p>The mode analysis algorithm checks one procedure at a time. 
It abstractly interprets the definition of the predicate or function,
keeping track of the instantiatedness of each variable,
and selecting a mode for each call and unification in the definition. 
To ensure that
the mode set constraints of called predicates and functions are satisfied,
the compiler may reorder the elements of conjunctions;
it reports an error if no satisfactory order exists. 
Finally it checks that
the resulting instantiatedness of the procedure's arguments
is the same as the one given by the procedure's declaration.

   <p>The mode analysis algorithm annotates each call with the mode used.

<div class="node">
<a name="Constrained-polymorphic-modes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Different-clauses-for-different-modes">Different clauses for different modes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Predicate-and-function-mode-declarations">Predicate and function mode declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modes">Modes</a>

</div>

<h3 class="section">4.3 Constrained polymorphic modes</h3>

<p>Mode declarations for predicates and functions may also have inst parameters. 
However, such parameters must be constrained to be <em>compatible</em> with some
other inst. 
In a predicate or function mode declaration,
an inst of the form &lsquo;<samp><var>InstParam</var><span class="samp"> =&lt; </span><var>Inst</var></samp>&rsquo;,
where <var>InstParam</var> is a variable and <var>Inst</var> is an inst,
states that
<var>InstParam</var> is constrained to be <em>compatible</em> with <var>Inst</var>,
that is,
<var>InstParam</var> represents some inst that can be used anywhere where
<var>Inst</var> is required. 
If an inst parameter occurs more than once in a declaration, it must have the
same constraint on each occurrence.

   <p>For example, in the mode declaration
<pre class="example">     	:- mode append(in(list_skel(I =&lt; ground)), in(list_skel(I =&lt; ground)),
     	        out(list_skel(I =&lt; ground))) is det.
</pre>
   <p class="noindent"><code>I</code> is an inst parameter which is constrained to be ground. 
If &lsquo;<samp><span class="samp">append</span></samp>&rsquo; is called with the first two arguments having an inst of, say,
&lsquo;<samp><span class="samp">list_skel(bound(f))</span></samp>&rsquo; then after &lsquo;<samp><span class="samp">append</span></samp>&rsquo; returns, all three arguments
will have inst &lsquo;<samp><span class="samp">list_skel(bound(f))</span></samp>&rsquo;. 
If the mode of append had been simply
<pre class="example">     	:- mode append(in(list_skel(ground)), in(list_skel(ground)),
     	        out(list_skel(ground))) is det.
</pre>
   <p class="noindent">then we would only have been able to infer an inst of &lsquo;<samp><span class="samp">list_skel(ground)</span></samp>&rsquo;
for the third argument, not the more specific inst.

   <p>Note that attempting to call &lsquo;<samp><span class="samp">append</span></samp>&rsquo; when the first two arguments do not
have ground insts (e.g. &lsquo;<samp><span class="samp">list_skel(bound(g(free)))</span></samp>&rsquo;) is a mode error
because it violates the constraint on the inst parameter.

   <p>To avoid having to repeat a constraint everywhere that an inst parameter occurs,
it is possible to list the constraints after the rest of the mode declaration,
following a &lsquo;<samp><span class="samp">&lt;=</span></samp>&rsquo;. 
E.g. the above example could have been written as
<pre class="example">     	:- (mode append(in(list_skel(I)), in(list_skel(I)),
                     out(list_skel(I))) is det) &lt;= I =&lt; ground.
</pre>
   <p>Note that in the current Mercury implementation this syntax requires
parentheses around the &lsquo;<samp><span class="samp">mode(...) is </span><var>Det</var></samp>&rsquo; part of the
declaration.

   <p>Also, if the constraint on an inst parameter is &lsquo;<samp><span class="samp">ground</span></samp>&rsquo; then it
is not necessary to give the constraint in the declaration. 
The example can be further shortened to
<pre class="example">     	:- mode append(in(list_skel(I)), in(list_skel(I)), out(list_skel(I)))
                     is det.
</pre>
   <p>Constrained polymorphic modes are particularly useful when passing
objects with higher-order types to polymorphic predicates
since they allow the higher-order mode information to be retained
(see <a href="#Higher_002dorder">Higher-order</a>).

<div class="node">
<a name="Different-clauses-for-different-modes"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Constrained-polymorphic-modes">Constrained polymorphic modes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modes">Modes</a>

</div>

<h3 class="section">4.4 Different clauses for different modes</h3>

<p>Because the compiler automatically reorders conjunctions to
satisfy the modes, it is often possible for a single clause
to satisfy different modes.  However, occasionally reordering
of conjunctions is not sufficient; you may want to write different
code for different modes.

   <p>For example, the usual code for list append

<pre class="example">     	append([], Ys, Ys).
     	append([X|Xs], Ys, [X|Zs]) :- append(Xs, Ys, Zs).
</pre>
   <p class="noindent">works fine in most modes, but is not very satisfactory for the
&lsquo;<samp><span class="samp">append(out, in, in)</span></samp>&rsquo; mode of append, because although
every call in this mode only has at most one solution,
the compiler's determinism inference will not be able to
infer that.  This means that using the usual code for append in
this mode will be inefficient, and the overly conservative determinism
inference may cause spurious determinism errors later.

   <p>For this mode, it is better to use a completely different algorithm:

<pre class="example">     	append(Prefix, Suffix, List) :-
     		list.length(List, ListLength),
     		list.length(Suffix, SuffixLength),
     		PrefixLength = ListLength - SuffixLength,
     		list.split_list(PrefixLength, List, Prefix, Suffix).
</pre>
   <p class="noindent">However, that code doesn't work in the other modes of append.

   <p>To handle such cases, you can use mode annotations on clauses, which
indicate that particular clauses should only be used for particular modes. 
To specify that a clause only applies to a given mode, each argument
<var>Arg</var> of the clause head should be annotated with the corresponding
argument mode <var>Mode</var>, using the &lsquo;<samp><span class="samp">::</span></samp>&rsquo; mode qualification operator,
i.e. &lsquo;<samp><var>Arg</var><span class="samp"> :: </span><var>Mode</var></samp>&rsquo;.

   <p>For example, if append was declared as

<pre class="example">     	:- pred append(list(T), list(T), list(T)).
     	:- mode append(in, in, out).
     	:- mode append(out, out, in).
     	:- mode append(in, out, in).
     	:- mode append(out, in, in).
</pre>
   <p class="noindent">then you could implement it as

<pre class="example">     	append(L1::in,  L2::in,  L3::out) :- usual_append(L1, L2, L3).
     	append(L1::out, L2::out, L3::in)  :- usual_append(L1, L2, L3).
     	append(L1::in,  L2::out, L3::in)  :- usual_append(L1, L2, L3).
     	append(L1::out, L2::in,  L3::in)  :- other_append(L1, L2, L3).
     
     	usual_append([], Ys, Ys).
     	usual_append([X|Xs], Ys, [X|Zs]) :- usual_append(Xs, Ys, Zs).
     
     	other_append(Prefix, Suffix, List) :-
     		list.length(List, ListLength),
     		list.length(Suffix, SuffixLength),
     		PrefixLength = ListLength - SuffixLength,
     		list.split_list(PrefixLength, List, Prefix, Suffix).
</pre>
   <p>This language feature can be used to write &ldquo;impure&rdquo; code that
doesn't have any consistent declarative semantics.  For example,
you can easily use it to write something similar to Prolog's (in)famous
var/1 predicate:

<pre class="example">     	:- mode var(in).
     	:- mode var(free&gt;&gt;free).
     	var(_::in) :- fail.
     	var(_::free&gt;&gt;free) :- true.
</pre>
   <p class="noindent">As you can see, in this case the two clauses are <em>not</em> equivalent.

   <p>Because of this possibility, predicates or functions which are defined
using different code for different modes are by default assumed to be
impure; the programmer must either
(1) carefully ensure that the logical meaning of the clauses
is the same for all modes,
which can be declared to the compiler
through a &lsquo;<samp><span class="samp">pragma promise_equivalent_clauses</span></samp>&rsquo; declaration,
or a &lsquo;<samp><span class="samp">pragma promise_pure</span></samp>&rsquo; declaration,
or (2) declare the predicate or function as impure. 
See <a href="#Impurity">Impurity</a>.

   <p>In the example with &lsquo;<samp><span class="samp">append</span></samp>&rsquo; above, the two ways of implementing
append do have the same declarative semantics, so we can safely use
the first approach:

<pre class="example">     	:- pragma promise_equivalent_clauses(append/3).
</pre>
   <p>The pragma

<pre class="example">     	:- pragma promise_pure(append/3).
</pre>
   <p>would also promise that the clauses are equivalent,
but on top of that would also promise that the code of each clause is pure. 
Sometimes, if some clauses contain impure code,
that is a promise that the programmer wants to make,
but this extra promise is unnecessary in this case.

   <p>In the example with &lsquo;<samp><span class="samp">var/1</span></samp>&rsquo; above, the two clauses have different
semantics, so the predicate must be declared as impure:

<pre class="example">     	:- impure pred var(T).
</pre>
   <div class="node">
<a name="Unique-modes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Determinism">Determinism</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Modes">Modes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Unique modes</h2>

<p>Mode declarations can also specify so-called &ldquo;unique modes&rdquo;. 
Mercury's unique modes are similar to &ldquo;linear types&rdquo; in some
functional programming languages such as Clean.  They allow you to
specify when there is only one reference to a particular value, and
when there will be no more references to that value.  If the compiler
knows there will be no more references to a value, it can perform
&ldquo;compile-time garbage collection&rdquo; by automatically inserting code
to deallocate the storage associated with that value.  Even more
importantly, the compiler can also simply reuse the storage immediately,
for example by destructively updating one element of an array rather
than making a new copy of the entire array in order to change one element. 
Unique modes are also the mechanism Mercury uses to provide declarative I/O.

   <p>We have not yet implemented unique modes fully, and the details are
still in a state of flux.  So the following should be considered
tentative.

<ul class="menu">
<li><a accesskey="1" href="#Destructive-update">Destructive update</a>
<li><a accesskey="2" href="#Backtrackable-destructive-update">Backtrackable destructive update</a>
<li><a accesskey="3" href="#Limitations-of-the-current-implementation">Limitations of the current implementation</a>
</ul>

<div class="node">
<a name="Destructive-update"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Backtrackable-destructive-update">Backtrackable destructive update</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Unique-modes">Unique modes</a>

</div>

<h3 class="section">5.1 Destructive update</h3>

<p>In addition to the insts mentioned above (&lsquo;<samp><span class="samp">free</span></samp>&rsquo;, &lsquo;<samp><span class="samp">ground</span></samp>&rsquo;,
and &lsquo;<samp><span class="samp">bound(...)</span></samp>&rsquo;), Mercury also provides &ldquo;unique&rdquo; insts
&lsquo;<samp><span class="samp">unique</span></samp>&rsquo; and &lsquo;<samp><span class="samp">unique(...)</span></samp>&rsquo; which are like &lsquo;<samp><span class="samp">ground</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">bound(...)</span></samp>&rsquo; respectively, except that they carry the
additional constraint that there can only be one reference to the
corresponding value.  There is also an inst &lsquo;<samp><span class="samp">dead</span></samp>&rsquo; which means
that there are no references to the corresponding value, so the compiler
is free to generate code that reuses that value. 
There are three standard modes for manipulation unique values:

<pre class="example">     % unique output
     :- mode uo == free &gt;&gt; unique.
     
     % unique input
     :- mode ui == unique &gt;&gt; unique.
     
     % destructive input
     :- mode di == unique &gt;&gt; dead.
</pre>
   <p>Mode &lsquo;<samp><span class="samp">uo</span></samp>&rsquo; is used to create a unique value. 
Mode &lsquo;<samp><span class="samp">ui</span></samp>&rsquo; is used to inspect a unique value without
losing its uniqueness. 
Mode &lsquo;<samp><span class="samp">di</span></samp>&rsquo; is used to deallocate or reuse the memory
occupied by a value that will not be used.

   <p>Note that a value is not considered &lsquo;<samp><span class="samp">unique</span></samp>&rsquo; if it might be
needed on backtracking.  This means that unique modes are generally
only useful for code whose determinism is &lsquo;<samp><span class="samp">det</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo;
(see <a href="#Determinism">Determinism</a>).

   <p>Unlike &lsquo;<samp><span class="samp">bound</span></samp>&rsquo; instantiatedness trees, there is no alternative
syntax for &lsquo;<samp><span class="samp">unique</span></samp>&rsquo; instantiatedness trees.

<div class="node">
<a name="Backtrackable-destructive-update"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Limitations-of-the-current-implementation">Limitations of the current implementation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Destructive-update">Destructive update</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Unique-modes">Unique modes</a>

</div>

<h3 class="section">5.2 Backtrackable destructive update</h3>

<blockquote>
&ldquo;Well it just so happens that your friend here is only <em>mostly</em> dead. 
<br>There's a big difference between mostly dead and all dead<small class="dots">...</small>
<br>Now, mostly dead is slightly alive. 
<br>Now, all dead &mdash; well, with all dead, there's usually only
one thing that you can do.&rdquo;

   <p>&ldquo;What's that?&rdquo;

   <p>&ldquo;Go through his clothes and look for loose change!&rdquo;

   <p>&mdash; from the movie &ldquo;The Princess Bride&rdquo;. 
</blockquote>

   <p>To allow for backtrackable destructive updates &mdash; that is, updates
whose effect is undone on backtracking, perhaps by recording the
overwritten values on a &ldquo;trail&rdquo; so that they can be restored
after backtracking &mdash; Mercury also provides &ldquo;mostly unique&rdquo;
modes.  The insts &lsquo;<samp><span class="samp">mostly_unique</span></samp>&rsquo; and &lsquo;<samp><span class="samp">mostly_dead</span></samp>&rsquo;
are equivalent to &lsquo;<samp><span class="samp">unique</span></samp>&rsquo; and &lsquo;<samp><span class="samp">dead</span></samp>&rsquo;,
except that only references which will be encountered during
forward execution are counted &mdash; it is OK for &lsquo;<samp><span class="samp">mostly_unique</span></samp>&rsquo; or
&lsquo;<samp><span class="samp">mostly_dead</span></samp>&rsquo; values to be needed again on backtracking.

   <p>Mercury defines some standard modes for manipulating &ldquo;mostly unique&rdquo;
values, just as it does for unique values:

<pre class="example">     % mostly unique output
     :- mode muo == free &gt;&gt; mostly_unique.
     
     % mostly unique input
     :- mode mui == mostly_unique &gt;&gt; mostly_unique.
     
     % mostly destructive input
     :- mode mdi == mostly_unique &gt;&gt; mostly_dead.
</pre>
   <div class="node">
<a name="Limitations-of-the-current-implementation"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Backtrackable-destructive-update">Backtrackable destructive update</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Unique-modes">Unique modes</a>

</div>

<h3 class="section">5.3 Limitations of the current implementation</h3>

<p>The implementation of the mode analysis algorithm is not quite complete;
as a result, it is not possible to use nested unique modes, i.e. 
modes in which anything but the top level of a variable is unique. 
If you do, you will get unique mode errors when you try
to get a unique field of a unique data structure. 
It is also not possible to use unique-input modes;
only destructive-input and unique-output modes work.

   <p>The Mercury compiler does not (yet) reuse &lsquo;<samp><span class="samp">dead</span></samp>&rsquo;
values.  The only destructive update in the current implementation occurs
in library modules, e.g. for I/O and arrays.  We do however plan to
implement structure reuse and compile-time garbage collection
in the very near future.

<div class="node">
<a name="Determinism"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#User_002ddefined-equality-and-comparison">User-defined equality and comparison</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Unique-modes">Unique modes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Determinism</h2>

<ul class="menu">
<li><a accesskey="1" href="#Determinism-categories">Determinism categories</a>
<li><a accesskey="2" href="#Determinism-checking-and-inference">Determinism checking and inference</a>
<li><a accesskey="3" href="#Replacing-compile_002dtime-checking-with-run_002dtime-checking">Replacing compile-time checking with run-time checking</a>
<li><a accesskey="4" href="#Interfacing-nondeterministic-code-with-the-real-world">Interfacing nondeterministic code with the real world</a>
<li><a accesskey="5" href="#Committed-choice-nondeterminism">Committed choice nondeterminism</a>
</ul>

<div class="node">
<a name="Determinism-categories"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Determinism-checking-and-inference">Determinism checking and inference</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Determinism">Determinism</a>

</div>

<h3 class="section">6.1 Determinism categories</h3>

<p>For each mode of a predicate or function,
we categorise that mode according to how many times it can succeed,
and whether or not it can fail before producing its first solution.

   <p>If all possible calls to a particular mode of a predicate or function
which return to the caller (calls which terminate, do not throw
an exception and do not cause a fatal runtime error)

     <ul>
<li>have exactly one solution,
then that mode is <dfn>deterministic</dfn> (<code>det</code>);

     <li>either have no solutions or have one solution,
then that mode is <dfn>semideterministic</dfn> (<code>semidet</code>);

     <li>have at least one solution but may have more,
then that mode is <dfn>multisolution</dfn> (<code>multi</code>);

     <li>have zero or more solutions,
then that mode is <dfn>nondeterministic</dfn> (<code>nondet</code>);

     <li>fail without producing a solution,
then that mode has a determinism of <code>failure</code>. 
</ul>

   <p>If no possible calls to a particular mode of a predicate or
function can return to the caller, then that mode has a
determinism of <code>erroneous</code>.

   <p>The determinism annotation <code>erroneous</code> is used on the library
predicates &lsquo;<samp><span class="samp">require.error/1</span></samp>&rsquo; and &lsquo;<samp><span class="samp">exception.throw/1</span></samp>&rsquo;,
but apart from that determinism annotations <code>erroneous</code> and
<code>failure</code> are generally not needed.

   <p>To summarize:

<pre class="example">                     Maximum number of solutions
     Can fail?       0               1               &gt; 1
     no              erroneous       det             multi
     yes             failure         semidet         nondet
</pre>
   <p>(Note: the &ldquo;Can fail?&rdquo; column here indicates only whether the procedure
can fail before producing at least one solution; attempts to find a
<em>second</em> solution to a particular call, e.g. for a procedure
with determinism &lsquo;<samp><span class="samp">multi</span></samp>&rsquo;, are always allowed to fail.)

   <p>The determinism of each mode of a predicate or function
is indicated by an annotation on the mode declaration. 
For example:

<pre class="example">     :- pred append(list(T), list(T), list(T)).
     :- mode append(in, in, out) is det.
     :- mode append(out, out, in) is multi.
     :- mode append(in, in, in) is semidet.
     
     :- func length(list(T)) = int.
     :- mode length(in) = out is det.
     :- mode length(in(list_skel)) = out is det.
     :- mode length(in) = in is semidet.
</pre>
   <p>An annotation of &lsquo;<samp><span class="samp">det</span></samp>&rsquo; or &lsquo;<samp><span class="samp">multi</span></samp>&rsquo; is an assertion that
for every value each of the inputs, there exists at least one value
of the outputs for which the predicate is true, or (in the case
of functions) for which the function term is equal to the result term. 
Conversely, an annotation of &lsquo;<samp><span class="samp">det</span></samp>&rsquo; or &lsquo;<samp><span class="samp">semidet</span></samp>&rsquo; is an assertion
that for every value each of the inputs, there exists at most one value
of the outputs for which the predicate is true, or (in the case
of functions) for which the function term is equal to the result term. 
These assertions are called the <dfn>mode-determinism assertions</dfn>;
they can play a role in the semantics, because in certain
circumstances they may allow an implementation to perform optimizations
that would not otherwise be allowed, such as optimizing away a goal
with no outputs even though it might infinitely loop.

   <p>If the mode of the predicate is given in the <code>:- pred</code> declaration
rather than in a separate <code>:- mode</code> declaration,
then the determinism annotation goes on the <code>:- pred</code> declaration
(and similarly for functions). 
In particular, this is necessary
if a predicate does not have any argument variables. 
If the determinism declaration is given on a <code>:- func</code> declaration
without the mode, the function is assumed to have the default mode
(see <a href="#Modes">Modes</a> for more information on default modes of functions).

   <p>For example:

<pre class="example">     :- pred loop(int::in) is erroneous.
     loop(X) :- loop(X).
     
     :- pred p is det.
     p.
     
     :- pred q is failure.
     q :- fail.
</pre>
   <p>If there is no mode declaration for a function, then the default
mode for that function is considered to have been declared as &lsquo;<samp><span class="samp">det</span></samp>&rsquo;. 
If you want to write a partial function, i.e. one whose determinism
is &lsquo;<samp><span class="samp">semidet</span></samp>&rsquo;, then you must explicitly declare the mode and determinism.

   <p>In Mercury, a function is supposed to be a true mathematical function
of its arguments; that is, the value of the function's result should
be determined only by the values of its arguments.  Hence, for
any mode of a function that specifies that all the arguments are fully
input (i.e. for which the initial inst of all the arguments is a ground inst),
the determinism of that mode can only be
&lsquo;<samp><span class="samp">det</span></samp>&rsquo;, &lsquo;<samp><span class="samp">semidet</span></samp>&rsquo;, &lsquo;<samp><span class="samp">erroneous</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">failure</span></samp>&rsquo;.

   <p>The determinism categories form this lattice:

<pre class="example">                  erroneous
                   /     \
               failure   det
                  \     /   \
                  semidet  multi
                      \     /
                       nondet
</pre>
   <p>The higher up this lattice a determinism category is,
the more the compiler knows about the number of solutions
of procedures of that determinism.

<div class="node">
<a name="Determinism-checking-and-inference"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Replacing-compile_002dtime-checking-with-run_002dtime-checking">Replacing compile-time checking with run-time checking</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Determinism-categories">Determinism categories</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Determinism">Determinism</a>

</div>

<h3 class="section">6.2 Determinism checking and inference</h3>

<p>The determinism of goals
is inferred from the determinism of their component parts,
according to the rules below. 
The inferred determinism of a procedure is just the inferred
determinism of the procedure's body.

   <p>For procedures that are local to a module,
the determinism annotations may be omitted;
in that case, their determinism will be inferred. 
(To be precise, the determinism of procedures without a determinism annotation
is defined as the least fixpoint of the transformation which,
given an initial assignment
of the determinism <code>det</code> to all such procedures,
applies those rules to infer
a new determinism assignment for those procedures.)

   <p>It is an error to omit the determinism annotation
for procedures that are exported from their containing module.

   <p>If a determinism annotation is supplied for a procedure,
the declared determinism is compared against the inferred determinism. 
If the declared determinism is greater than or not comparable to the
inferred determinism (in the partial ordering above), it is an error. 
If the declared determinism is less than the inferred determinism,
it is not an error, but the implementation may issue a warning.

   <p>The determinism category of each goal
is inferred according to the following rules. 
These rules work with the two components of determinism category:
whether the goal can fail without producing a solution,
and the maximum number of solutions of the goal (0, 1, or more). 
If the inference process below reports that a goal can succeed more than once,
but the goal generates no outputs that are visible from outside the goal,
and the goal is not impure (see <a href="#Impurity">Impurity</a>),
then the final determinism of the goal
will be based on the goal succeeding at most once,
since the compiler will implicitly prune away any duplicate solutions.

     <dl>
<dt>Calls<dd>The determinism category of a call is the determinism
declared or inferred for the called mode of the called procedure.

     <br><dt>Unifications<dd>The determinism of a unification
is either <code>det</code>, <code>semidet</code>, or <code>failure</code>,
depending on its mode.

     <p>A unification that assigns the value of one variable to another
is deterministic. 
A unification that constructs a structure and assigns it to a variable
is also deterministic. 
A unification that tests whether a variable has a given top function symbol
is semideterministic,
unless the compiler knows the top function symbol of that variable,
in which case its determinism is either det or failure
depending on whether the two function symbols are the same or not. 
A unification that tests two variables for equality
is semideterministic,
unless the compiler knows that the two variables are aliases for one another,
in which case the unification is deterministic,
or unless the compiler knows that the two variables
have different function symbols in the same position,
in which case the unification has a determinism of failure.

     <p>The compiler knows the top function symbol of a variable
if the previous part of the procedure definition
contains a unification of the variable with a function symbol,
or if the variable's type has only one function symbol.

     <br><dt>Conjunctions<dd>The determinism of the empty conjunction (the goal &lsquo;<samp><span class="samp">true</span></samp>&rsquo;)
is <code>det</code>. 
The conjunction &lsquo;<samp><span class="samp">(</span><var>A</var><span class="samp">, </span><var>B</var><span class="samp">)</span></samp>&rsquo; can fail
if either <var>A</var> can fail, or if <var>A</var> can succeed at least once,
and <var>B</var> can fail. 
The conjunction can succeed at most zero times
if either <var>A</var> or <var>B</var> can succeed at most zero times. 
The conjunction can succeed more than once
if either <var>A</var> or <var>B</var> can succeed more than once
and both <var>A</var> and <var>B</var> can succeed at least once. 
(If e.g. <var>A</var> can succeed at most zero times,
then even if <var>B</var> can succeed many times
the maximum number of solutions of the conjunction is still zero.) 
Otherwise, i.e. if both <var>A</var> and <var>B</var> succeed at most once,
the conjunction can succeed at most once.

     <br><dt>Switches<dd>A disjunction is a <em>switch</em>
if each disjunct has near its start a unification that
tests the same bound variable against a different function symbol. 
For example, consider the common pattern

     <pre class="example">          (
                  L = [], empty(Out)
          ;
                  L = [H|T], nonempty(H, T, Out)
          )
</pre>
     <p>If L is input to the disjunction, then the disjunction is a switch on L.

     <p>If two variables are unified with each other,
then whatever function symbol one variable is unified with,
the other variable is considered to be unified with the same function symbol. 
In the following example, since K is unified with L,
the second disjunct unifies L as well as K with cons,
and thus the disjunction is recognized as a switch.

     <pre class="example">          (
                  L = [], empty(Out)
          ;
                  K = L, K = [H|T], nonempty(H, T, Out)
          )
</pre>
     <p>A switch can fail
if the various arms of the switch do not cover
all the function symbols in the type of the switched-on variable,
or if the code in some arms of the switch can fail,
bearing in mind that in each arm of the switch,
the unification that tests the switched-on variable
against the function symbol of that arm is considered to be deterministic. 
A switch can succeed several times
if some arms of the switch can succeed several times,
possibly because there are multiple disjuncts
that test the switched-on variable against the same function symbol. 
A switch can succeed at most zero times
only if all arms of the switch can succeed at most zero times.

     <p>Only unifications may occur before the test of the switched-on variable
in each disjunct. Tests of the switched-on variable may occur within
existential quantification goals.

     <p>The following example is a switch.

     <pre class="example">          (
                  Out = 1, L = []
          ;
                  some [H, T] (
                          L = [H|T],
                          nonempty(H, T, Out)
                  )
          )
</pre>
     <p>The following example is not a switch because the call in the first
disjunct occurs before the test of the switched-on variable.

     <pre class="example">          (
                  empty(Out), L = []
          ;
                  L = [H|T], nonempty(H, T, Out)
          )
</pre>
     <p>The unification of the switched-on variable with a function symbol
may occur inside a nested disjunction in a given disjunct,
provided that unification is preceded only by other unifications,
both inside the nested disjunction and before the nested disjunction. 
The following example is a switch on X, provided X is bound beforehand.

     <pre class="example">          (
                  X = f
          	p(Out)
          ;
          	Y = X,
                  (
          		Y = g,
          		Intermediate = 42
          	;
          		Z = Y,
          		Z = h(Arg),
          		q(Arg, Intermediate)
          	),
          	r(Intermediate, Out)
          )
</pre>
     <br><dt>Disjunctions<dd>The determinism of the empty disjunction (the goal &lsquo;<samp><span class="samp">fail</span></samp>&rsquo;)
is <code>failure</code>. 
A disjunction &lsquo;<samp><span class="samp">(</span><var>A</var><span class="samp"> ; </span><var>B</var><span class="samp">)</span></samp>&rsquo; that is not a switch
can fail if both <var>A</var> and <var>B</var> can fail. 
It can succeed at most zero times
if both <var>A</var> and <var>B</var> can succeed at most zero times. 
It can succeed at most once
if one of <var>A</var> and <var>B</var> can succeed at most once
and the other can succeed at most zero times. 
Otherwise, i.e. if either <var>A</var> or <var>B</var> can succeed more than once,
or if both <var>A</var> and <var>B</var> can succeed at least once,
it can succeed more than once.

     <!-- The local determinism of a disjunction is @code{nondet} unless the -->
     <!-- compiler can detect that the disjunction is actually a switch and -->
     <!-- hence @dfn{index} the disjunction. -->
     <!-- Precisely describing the rules for detecting switches is somewhat tricky, -->
     <!-- and I won't attempt to do so, but they are -->
     <!-- reasonable easy to understand in practice. -->
     <!-- The compiler can index on any input variable to a disjunction -->
     <!-- (not just the first head variable).  It can also index on more than -->
     <!-- one variable, since after indexing on the first one, switch detection is -->
     <!-- applied to all sub-disjunctions.  It can index on any functor, not -->
     <!-- just the top-most one. -->
     <br><dt>If-then-else<dd>
If the condition of an if-then-else cannot fail, the if-then-else
is equivalent to the conjunction of the condition and the &ldquo;then&rdquo; part,
and its determinism is computed accordingly. 
Otherwise,
an if-then-else can fail if either the &ldquo;then&rdquo; part or the &ldquo;else&rdquo; part
can fail. 
It can succeed at most zero times
if the &ldquo;else&rdquo; part can succeed at most zero times
and if at least one of the condition and the &ldquo;then&rdquo; part
can succeed at most zero times. 
It can succeed more than once
if any one of the condition, the &ldquo;then&rdquo; part and the &ldquo;else&rdquo; part
can succeed more than once.

     <br><dt>Negations<dd>
If the determinism of the negated goal is <code>erroneous</code>,
then the determinism of the negation is <code>erroneous</code>. 
If the determinism of the negated goal is <code>failure</code>,
the determinism of the negation is <code>det</code>. 
If the determinism of the negated goal is <code>det</code> or <code>multi</code>,
the determinism of the negation is <code>failure</code>. 
Otherwise, the determinism of the negation is <code>semidet</code>.

   </dl>

<div class="node">
<a name="Replacing-compile-time-checking-with-run-time-checking"></a>
<a name="Replacing-compile_002dtime-checking-with-run_002dtime-checking"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Interfacing-nondeterministic-code-with-the-real-world">Interfacing nondeterministic code with the real world</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Determinism-checking-and-inference">Determinism checking and inference</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Determinism">Determinism</a>

</div>

<h3 class="section">6.3 Replacing compile-time checking with run-time checking</h3>

<p>Note that &ldquo;perfect&rdquo; determinism inference is an undecidable problem,
because it requires solving the halting problem. 
(For instance, in the following example

<pre class="example">     :- pred p(T, T).
     :- mode p(in, out) is det.
     
     p(A, B) :-
             (
                     something_complicated(A, B)
             ;
                     B = A
             ).
</pre>
   <p class="noindent">&lsquo;<samp><span class="samp">p/2</span></samp>&rsquo; can have more than one solution
only if &lsquo;<samp><span class="samp">something_complicated</span></samp>&rsquo; can succeed.) 
Sometimes, the rules specified by the Mercury language
for determinism inference will infer a determinism
that is not as precise as you would like. 
However, it is generally easy to overcome such problems. 
The way to do this is to replace the compiler's static checking
with some manual run-time checking. 
For example, if you know that a particular goal should never fail,
but the compiler infers that goal to be <code>semidet</code>,
you can check at runtime that the goal does succeed,
and if it fails, call the library predicate &lsquo;<samp><span class="samp">error/1</span></samp>&rsquo;.

<pre class="example">     :- pred q(T, T).
     :- mode q(in, out) is det.
     
     q(A, B) :-
             ( goal_that_should_never_fail(A, B0) -&gt;
                     B = B0
             ;
                     error("goal_that_should_never_fail failed!")
             ).
</pre>
   <p class="noindent">The predicate <code>error/1</code> has determinism <code>erroneous</code>,
which means the compiler knows that it will never succeed or fail,
so the inferred determinism for the body of <code>q/2</code> is <code>det</code>. 
(Checking assumptions like this is good coding style anyway. 
The small amount of up-front work that Mercury requires
is paid back in reduced debugging time.) 
Mercury's mode analysis knows that
computations with determinism erroneous can never succeed,
which is why it does not require the &ldquo;else&rdquo; part to generate
a value for &lsquo;<samp><span class="samp">B</span></samp>&rsquo;. 
The introduction of the new variable &lsquo;<samp><span class="samp">B0</span></samp>&rsquo; is necessary
because the condition of an if-then-else is a negated context,
and can export the values it generates
only to the &ldquo;then&rdquo; part of the if-then-else,
not directly to the surrounding computation. 
(If the surrounding computations had direct access
to values generated in conditions,
they might access them even if the condition failed.)

<div class="node">
<a name="Interfacing-nondeterministic-code-with-the-real-world"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Committed-choice-nondeterminism">Committed choice nondeterminism</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Replacing-compile_002dtime-checking-with-run_002dtime-checking">Replacing compile-time checking with run-time checking</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Determinism">Determinism</a>

</div>

<h3 class="section">6.4 Interfacing nondeterministic code with the real world</h3>

<p>Normally, attempting to call
a <code>nondet</code> or <code>multi</code> mode of a predicate
from a predicate declared as <code>semidet</code> or <code>det</code>
will cause a determinism error. 
So how can we call nondeterministic code from deterministic code? 
There are several alternative possibilities.

   <p>If you just want to see if a nondeterministic goal is satisfiable or not,
without needing to know what variable bindings it produces,
then there is no problem -
determinism analysis considers <code>nondet</code> and <code>multi</code> goals
with no non-local output variables to be
<code>semidet</code> and <code>det</code> respectively.

   <p>If you want to use the values of output variables,
then you need to ask yourself
which one of possibly many solutions to a goal do you want? 
If you want all of them, you need to use the predicate
&lsquo;<samp><span class="samp">solutions/2</span></samp>&rsquo; in the standard library module &lsquo;<samp><span class="samp">solutions</span></samp>&rsquo;,
which collects all of the solutions to a goal into a list &mdash;
see <a href="#Higher_002dorder">Higher-order</a>.

   <p>If you just want one solution and don't care which,
the calling predicate should be declared <code>nondet</code> or <code>multi</code>. 
The nondeterminism should then be propagated up the call tree
to the point at which it can be pruned. 
In Mercury, pruning can be achieved in several ways.

   <p>The first way is the one mentioned above:
if a goal has no non-local output variables
then the implementation will only attempt to satisfy the goal once. 
Any potential duplicate solutions will be implicitly pruned away.

   <p>The second way is to rely on the fact that
the implementation will only seek a single solution to &lsquo;<samp><span class="samp">main/2</span></samp>&rsquo;,
so alternative solutions to &lsquo;<samp><span class="samp">main/2</span></samp>&rsquo;
(and hence also to <code>nondet</code> or <code>multi</code> predicates
called directly or indirectly from &lsquo;<samp><span class="samp">main/2</span></samp>&rsquo;)
are implicitly pruned away. 
This is one way to achieve &ldquo;don't care&rdquo; style nondeterminism in Mercury.

   <p>The other situation in which you may want pruning
and committed choice style nondeterminism
is when you know that all the solutions returned will be equivalent. 
For example, you might want to find the maximum element in a set
by iterating over the elements in the set. 
Iterating over the elements in a set in an unspecified order is a
nondeterministic operation,
but no matter which order you remove them,
the maximum value in the set should be the same.

   <p>If you know that there will only ever be at most one distinct
solution under the equality theory of the output variables, then you can use a
&lsquo;<samp><span class="samp">promise_equivalent_solutions</span></samp>&rsquo; determinism cast.

   <p>Note that specifying a user-defined equivalence relation
as the equality predicate for user-defined types
(see <a href="#User_002ddefined-equality-and-comparison">User-defined equality and comparison</a>)
means that &lsquo;<samp><span class="samp">promise_equivalent_solutions</span></samp>&rsquo;
can be used to express more general forms of equivalence. 
For example, if you define a set type which represents sets as unsorted lists,
you would want to define a user-defined equivalence relation for that type,
which could sort the lists before comparing them. 
The &lsquo;<samp><span class="samp">promise_equivalent_solutions</span></samp>&rsquo; determinism cast could then be used for
sets even though the lists used to represent the sets might not be in the same
order in every solution.

<div class="node">
<a name="Committed-choice-nondeterminism"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Interfacing-nondeterministic-code-with-the-real-world">Interfacing nondeterministic code with the real world</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Determinism">Determinism</a>

</div>

<h3 class="section">6.5 Committed choice nondeterminism</h3>

<p>In addition to the determinism annotations described earlier, there are
&ldquo;committed choice&rdquo; versions of <code>multi</code>
and <code>nondet</code>, called <code>cc_multi</code> and <code>cc_nondet</code>. 
These can be used instead of <code>multi</code> or <code>nondet</code> if all calls
to that mode of the predicate (or function) occur in a context in
which only one solution is needed.

   <p>Such single-solution contexts are determined as follows.

     <ul>
<li>The body of any procedure declared <code>cc_multi</code> or
<code>cc_nondet</code> is in a single-solution context. 
For example, the program entry point &lsquo;<samp><span class="samp">main/2</span></samp>&rsquo; may
be declared <code>cc_multi</code>, and in that case the clauses
for <code>main</code> are in a single-solution context.

     <li>Any goal with no output variables is in a single-solution context.

     <li>If a conjunction is in a single-solution context, then
the right-most conjunct is in a single-solution context,
and if the right-most conjunct cannot fail,
then rest of the conjunction is also in a single-solution
context. 
(&ldquo;Right-most&rdquo; here refers to the order <em>after</em> mode reordering.)

     <li>If an if-then-else is in a single-solution context, then the
&ldquo;then&rdquo; part and the &ldquo;else&rdquo; part are in single-solution contexts,
and if the &ldquo;then&rdquo; part cannot fail, then the condition of the
if-then-else is also in a single-solution context.

     <li>For other compound goals, i.e. disjunctions, negations, and
(explicitly) existentially quantified goals, if the compound goal
is in a single-solution context, then the immediate sub-goals of that
compound goal are also in single-solution contexts.

   </ul>

   <p>The compiler will check that all calls to a committed-choice
mode of a predicate (or function) do indeed occur in a single-solution context.

   <p>You can declare two different modes of a predicate (or function) which differ
only in &ldquo;cc-ness&rdquo; (i.e. one being &lsquo;<samp><span class="samp">multi</span></samp>&rsquo; and the other
&lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo;, or one being &lsquo;<samp><span class="samp">nondet</span></samp>&rsquo; and the other &lsquo;<samp><span class="samp">cc_nondet</span></samp>&rsquo;). 
In that case, the compiler will select the appropriate one for each
call depending on whether the call comes from a single-solution context
or not.  Calls from single-solution contexts will call the committed
choice version, while calls which are not from single-solution contexts
will call the backtracking version.

   <p>There are several reasons to use committed choice determinism annotations. 
One reason is for efficiency: committed choice annotations allow
the compiler to generate much more efficient code. 
Another reason is for doing I/O, which is allowed only in &lsquo;<samp><span class="samp">det</span></samp>&rsquo;
or &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo; predicates, not in &lsquo;<samp><span class="samp">multi</span></samp>&rsquo; predicates. 
Another is for dealing with types that use non-canonical representations
(see <a href="#User_002ddefined-equality-and-comparison">User-defined equality and comparison</a>). 
And there are a variety of other applications.

<!-- XXX fix semantics for I/O + committed choice + mode inference -->
<!-- @node Assertions -->
<!-- @chapter Assertions -->
<!-- Mercury supports the declaration of laws that hold for predicates and -->
<!-- functions. -->
<!-- These laws are only checked for type-correctness, -->
<!-- it is the responsibility of the programmer to ensure overall correctness. -->
<!-- The behaviour of programs with incorrect laws is undefined. -->
<!-- A new law is introduced with the @samp{:- assertion} declaration. -->
<!-- Here are some examples of @samp{:- assertion} declarations. -->
<!-- The following example declares the function @samp{+} to be commutative. -->
<!-- @example -->
<!-- :- assertion -->
<!-- all [A,B,R] ( -->
<!-- R = A + B -->
<!-- <=> -->
<!-- R = B + A -->
<!-- ). -->
<!-- @end example -->
<!-- Note that each variable in the declaration was explicitly quantified. -->
<!-- The current Mercury compiler requires that each assertion begins with -->
<!-- an @samp{all} quantification, and that every variable is explicitly -->
<!-- quantified. -->
<!-- Here is a more complicated declaration. It declares that @samp{append} is -->
<!-- associative. -->
<!-- @example -->
<!-- :- assertion -->
<!-- all [A,B,C,ABC] ( -->
<!-- (some [AB] (append(A, B, AB), append(AB, C, ABC))) -->
<!-- <=> -->
<!-- (some [BC] (append(B, C, BC), append(A, BC, ABC))) -->
<!-- ). -->
<!-- @end example -->
<div class="node">
<a name="User-defined-equality-and-comparison"></a>
<a name="User_002ddefined-equality-and-comparison"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Higher_002dorder">Higher-order</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Determinism">Determinism</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 User-defined equality and comparison</h2>

<p>When defining abstract data types,
often it is convenient to use a non-canonical representation &mdash;
that is, one for which a single abstract value may have more than
one different possible concrete representations. 
For example, you may wish to implement an abstract type &lsquo;<samp><span class="samp">set</span></samp>&rsquo;
by representing a set as an (unsorted) list.

<pre class="example">     :- module set_as_unsorted_list.
     :- interface.
     :- type set(T).
     
     :- implementation.
     :- import_module list.
     :- type set(T) ---&gt; set(list(T)).
</pre>
   <p class="noindent">In this example, the concrete representations &lsquo;<samp><span class="samp">set([1,2])</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">set([2,1])</span></samp>&rsquo; would both represent the same abstract value, namely
the set containing the elements 1 and 2.

   <p>For types such as this, which do not have a canonical representation,
the standard definition of equality is not the desired one; we want equality on
sets to mean equality of the abstract values, not equality of their
representations.  To support such types, Mercury allows programmers to
specify a user-defined equality predicate for user-defined types:

<pre class="example">     :- type set(T) ---&gt; set(list(T))
             where equality is set_equals.
</pre>
   <p class="noindent">Here &lsquo;<samp><span class="samp">set_equals</span></samp>&rsquo; is the name of a user-defined predicate that
is used for equality on the type &lsquo;<samp><span class="samp">set(T)</span></samp>&rsquo;.  It could for example
be defined in terms of a &lsquo;<samp><span class="samp">subset</span></samp>&rsquo; predicate.

<pre class="example">     :- pred set_equals(set(T)::in, set(T)::in) is semidet.
     set_equals(S1, S2) :-
             subset(S1, S2),
             subset(S2, S1).
</pre>
   <p>A comparison predicate can also be supplied.

<pre class="example">     :- type set(T) ---&gt; set(list(T))
             where equality is set_equals, comparison is set_compare.
     
     :- pred set_compare(builtin.comparison_result::uo,
                     set(T)::in, set(T)::in) is det.
     set_compare(Result, Set1, Set2) :-
     	promise_equivalent_solutions [Result] (
     		set_compare_2(Set1, Set2, Result)
     	).
     
     :- pred set_compare_2(set(T)::in, set(T)::in,
                     builtin.comparison_result::uo) is cc_multi.
     set_compare_2(set(List1), set(List2), Result) :-
             builtin.compare(Result, list.sort(List1), list.sort(List2)).
</pre>
   <p>If a comparison predicate is supplied and the unification predicate
is omitted, a unification predicate is generated by the compiler
in terms of the comparison predicate.  For the &lsquo;<samp><span class="samp">set</span></samp>&rsquo; example,
the generated predicate would be:

<pre class="example">     set_equals(S1, S2) :-
             set_compare((=), S1, S2).
</pre>
   <p>If a unification predicate is supplied without a comparison predicate,
the compiler will generate a comparison predicate which throws an
exception of type &lsquo;<samp><span class="samp">exception.software_error</span></samp>&rsquo; when called.

   <p>A type declaration for a type &lsquo;<samp><span class="samp">foo(T1, ..., TN)</span></samp>&rsquo; may contain a
&lsquo;<samp><span class="samp">where equality is </span><var>equalitypred</var></samp>&rsquo; specification only if it
declares a discriminated union type or a foreign type
(see <a href="#Using-foreign-types-from-Mercury">Using foreign types from Mercury</a>) and the
following conditions are satisfied:

     <ul>
<li><var>equalitypred</var> must be the name of a predicate with signature
     <pre class="example">          :- pred <var>equalitypred</var>(foo(T1, ..., TN)::in,
                          foo(T1, ..., TN)::in) is semidet.
</pre>
     <p>It is legal for the type, mode and determinism to be more permissive:
the type or the mode's initial insts may be more general
(e.g. the type of the equality predicate could be just the polymorphic
type &lsquo;<samp><span class="samp">pred(T, T)</span></samp>&rsquo;) and the mode's final insts or the determinism
may be more specific (e.g. the determinism of the equality predicate
could be any of &lsquo;<samp><span class="samp">det</span></samp>&rsquo;, &lsquo;<samp><span class="samp">failure</span></samp>&rsquo; or &lsquo;<samp><span class="samp">erroneous</span></samp>&rsquo;).

     <li>If the type is a discriminated union then its definition cannot be
a single zero-arity constructor.

     <li>The equality predicate must be &ldquo;pure&rdquo; (see <a href="#Impurity">Impurity</a>).

     <li>The equality predicate must be defined in the same module as the type.

     <li>If the type is exported the equality predicate must also be exported.

     <li><var>equalitypred</var> should be an equivalence relation; that is, it must be
symmetric, reflexive, and transitive.  However, the compiler is not required
to check this<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>.

   </ul>

   <p>Types with user-defined equality can only be used in limited ways. 
Because there multiple representations for the same abstract
value, any attempt to examine the representation of such a value
is a conceptually non-deterministic operation. 
In Mercury this is modelled using committed choice nondeterminism.

   <p>The semantics of specifying &lsquo;<samp><span class="samp">where equality is </span><var>equalitypred</var></samp>&rsquo;
on the type declaration for a type <var>T</var> are as follows:

     <ul>
<li>If the program contains any deconstruction unification or switch
on a variable of type <var>T</var> that could fail, other than unifications
with mode &lsquo;<samp><span class="samp">(in, in)</span></samp>&rsquo;, then it is a compile-time error.

     <li>If the program contains any deconstruction unification or switch
on a variable of type <var>T</var> that cannot fail, then that operation
has determinism &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo;.

     <li>Any attempts to examine the representation of a variable of type <var>T</var>
using facilities of the standard library (e.g. &lsquo;<samp><span class="samp">argument</span></samp>&rsquo;/3
and &lsquo;<samp><span class="samp">functor/3</span></samp>&rsquo; in &lsquo;<samp><span class="samp">deconstruct</span></samp>&rsquo;) that do not have determinism
&lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cc_nondet</span></samp>&rsquo; will result in a run-time error.

     <li>In addition to the usual equality axioms,
the declarative semantics of the program will contain the axiom
&lsquo;<samp><var>X</var><span class="samp"> = </span><var>Y</var><span class="samp"> &lt;=&gt; </span><var>equalitypred</var><span class="samp">(X, Y)</span></samp>&rsquo; for all
<var>X</var> and <var>Y</var> of type &lsquo;<samp><span class="samp">T</span></samp>&rsquo;.

     <li>Any &lsquo;<samp><span class="samp">(in, in)</span></samp>&rsquo; unifications for type <var>T</var> are computed using the
specified predicate <var>equalitypred</var>.

   </ul>

   <p>A type declaration for a type &lsquo;<samp><span class="samp">foo(T1, ..., TN)</span></samp>&rsquo; may contain a
&lsquo;<samp><span class="samp">where comparison is </span><var>comparepred</var></samp>&rsquo; specification only if it
declares a discriminated union type or a foreign type
(see <a href="#Using-foreign-types-from-Mercury">Using foreign types from Mercury</a>) and the
following conditions are satisfied:

     <ul>
<li><var>comparepred</var> must be the name of a predicate with signature
     <pre class="example">          :- pred <var>comparepred</var>(builtin.comparison_result::uo,
                          foo(T1, ..., TN)::in, foo(T1, ..., TN)::in) is det.
</pre>
     <p>As with equality predicates, it is legal for the type, mode and
determinism to be more permissive.

     <li>If the type is a discriminated union then its definition cannot be
a single zero-arity constructor.

     <li>The comparison predicate must also be &ldquo;pure&rdquo; (see <a href="#Impurity">Impurity</a>).

     <li>The comparison predicate must be defined in the same module as the type.

     <li>If the type is exported the comparison predicate must also be exported.

     <li>The relation
     <pre class="example">          compare_eq(X, Y) :- <var>comparepred</var>((=), X, Y).
</pre>
     <p>must be an equivalence relation; that is, it must be symmetric,
reflexive, and transitive.  The compiler is not required to check this.

     <li>The relations
     <pre class="example">          compare_leq(X, Y) :- <var>comparepred</var>(R, X, Y), (R = (=) ; R = (&lt;)).
          compare_geq(X, Y) :- <var>comparepred</var>(R, X, Y), (R = (=) ; R = (&gt;)).
</pre>
     <p>must be total order relations: that is they must be antisymmetric,
reflexive and transitive.  The compiler is not required to check this.

   </ul>

   <p>For each type for which the declaration has a
&lsquo;<samp><span class="samp">where comparison is </span><var>comparepred</var></samp>&rsquo; specification,
any calls to the standard library predicate &lsquo;<samp><span class="samp">builtin.compare/3</span></samp>&rsquo;
with arguments of that type are evaluated as if they were calls
to <var>comparepred</var>.

   <p>A type declaration may contain a
&lsquo;<samp><span class="samp">where equality is </span><var>equalitypred</var><span class="samp">, comparison is </span><var>comparepred</var></samp>&rsquo;
specification only if in addition to the conditions above,
&lsquo;<samp><span class="samp">all [X, Y] (</span><var>comparepred</var><span class="samp">((=), X, Y) &lt;=&gt; </span><var>equalitypred</var><span class="samp">(X, Y))</span></samp>&rsquo;. 
The compiler is not required to check this.

<div class="node">
<a name="Higher-order"></a>
<a name="Higher_002dorder"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Modules">Modules</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#User_002ddefined-equality-and-comparison">User-defined equality and comparison</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Higher-order programming</h2>

<p>Mercury supports higher-order functions and predicates with currying,
closures, and lambda expressions. 
(To be pedantic, it would be more accurate to
say that Mercury supports higher-order procedures: in Mercury, when you
construct a higher-order term, you only get one mode of
a predicate or function; if you want multiple modes, you must pass multiple
higher-order procedures.)

<ul class="menu">
<li><a accesskey="1" href="#Creating-higher_002dorder-terms">Creating higher-order terms</a>
<li><a accesskey="2" href="#Calling-higher_002dorder-terms">Calling higher-order terms</a>
<li><a accesskey="3" href="#Higher_002dorder-modes">Higher-order modes</a>
</ul>

<div class="node">
<a name="Creating-higher-order-terms"></a>
<a name="Creating-higher_002dorder-terms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Calling-higher_002dorder-terms">Calling higher-order terms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Higher_002dorder">Higher-order</a>

</div>

<h3 class="section">8.1 Creating higher-order terms</h3>

<!-- NB. This section is pointed to by an error message in compiler/typecheck.m, -->
<!-- so if you change the section name, you need to update that error message. -->
<p>To create a higher-order predicate or function term, you can use
a lambda expression, or, if the predicate or function has only one
mode and it is not a zero-arity function, you can just use its name. 
For example, if you have declared a predicate

<pre class="example">     :- pred sum(list(int), int).
     :- mode sum(in, out) is det.
</pre>
   <p class="noindent">the following unifications have the same effect:

<pre class="example">     X = (pred(List::in, Length::out) is det :- sum(List, Length))
     Y = sum
</pre>
   <p>In the above example, the type of &lsquo;<samp><span class="samp">X</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">Y</span></samp>&rsquo; is
&lsquo;<samp><span class="samp">pred(list(int), int)</span></samp>&rsquo;, which means a predicate of two
arguments of types &lsquo;<samp><span class="samp">list(int)</span></samp>&rsquo; and &lsquo;<samp><span class="samp">int</span></samp>&rsquo; respectively.

   <p>Similarly, given

<pre class="example">     :- func scalar_product(int, list(int)) = list(int).
     :- mode scalar_product(in, in) = out is det.
</pre>
   <p class="noindent">the following three unifications have the same effect:

<pre class="example">     X = (func(Num, List) = NewList :- NewList = scalar_product(Num, List))
     Y = (func(Num::in, List::in) = (NewList::out) is det
             :- NewList = scalar_product(Num, List))
     Z = scalar_product
</pre>
   <p>In the above example, the type of &lsquo;<samp><span class="samp">X</span></samp>&rsquo;, &lsquo;<samp><span class="samp">Y</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">Z</span></samp>&rsquo; is
&lsquo;<samp><span class="samp">func(int, list(int)) = list(int)</span></samp>&rsquo;, which means a function of two
arguments, whose types are &lsquo;<samp><span class="samp">int</span></samp>&rsquo; and &lsquo;<samp><span class="samp">list(int)</span></samp>&rsquo;,
with a return type of &lsquo;<samp><span class="samp">int</span></samp>&rsquo;. 
As with &lsquo;<samp><span class="samp">:- func</span></samp>&rsquo; declarations, if the modes and determinism
of the function are omitted in a higher-order function term, then
the modes default to &lsquo;<samp><span class="samp">in</span></samp>&rsquo; for the arguments, &lsquo;<samp><span class="samp">out</span></samp>&rsquo; for the
function result, and the determinism defaults to &lsquo;<samp><span class="samp">det</span></samp>&rsquo;.

   <p>The Melbourne Mercury implementation currently requires that you use an
explicit lambda expression to specify which mode you want, if the predicate
or function has more than one mode (but see below for an exception to this
rule).

   <p>You can also create higher-order function terms of non-zero arity
and higher-order predicate terms by &ldquo;currying&rdquo;,
i.e. specifying the first few arguments to a predicate or function, but
leaving the remaining arguments unspecified.  For example, the
unification

<pre class="example">     Sum123 = sum([1,2,3])
</pre>
   <p class="noindent">binds &lsquo;<samp><span class="samp">Sum123</span></samp>&rsquo; to a higher-order predicate term of type &lsquo;<samp><span class="samp">pred(int)</span></samp>&rsquo;. 
Similarly, the unification

<pre class="example">     Double = scalar_product(2)
</pre>
   <p class="noindent">binds &lsquo;<samp><span class="samp">Double</span></samp>&rsquo; to a higher-order function term of type
&lsquo;<samp><span class="samp">func(list(int)) = list(int)</span></samp>&rsquo;.

   <p>As a special case, currying of a multi-moded predicate or function is allowed
provided that the mode of the predicate or function can be determined from
the insts of the higher-order curried arguments.  For example,
&lsquo;<samp><span class="samp">P = list.foldl(io.write)</span></samp>&rsquo; is allowed because the inst of &lsquo;<samp><span class="samp">io.write</span></samp>&rsquo;
matches exactly one mode of &lsquo;<samp><span class="samp">list.foldl</span></samp>&rsquo;.

   <p>For higher-order predicate expressions that thread an accumulator
pair, we have syntax that allows you to use DCG notation in the
goal of the expression.  For example,

<pre class="example">     Pred = (pred(Strings::in, Num::out, di, uo) is det --&gt;
         io.write_string("The strings are: "),
         { list.length(Strings, Num) },
         io.write_strings(Strings),
         io.nl
     )
</pre>
   <p class="noindent">is equivalent to

<pre class="example">     Pred = (pred(Strings::in, Num::out, IO0::di, IO::uo) is det :-
         io.write_string("The strings are: ", IO0, IO1),
         list.length(Strings, Num),
         io.write_strings(Strings, IO1, IO2),
         io.nl(IO2, IO)
     )
</pre>
   <p>Higher-order function terms of zero arity can only be created using
an explicit lambda expression; you have to use e.g. &lsquo;<samp><span class="samp">(func) = foo</span></samp>&rsquo;
rather than plain &lsquo;<samp><span class="samp">foo</span></samp>&rsquo;, because the latter denotes the result
of evaluating the function, rather than the function itself.

   <p>Note that when constructing a higher-order term, you cannot just use
the name of a builtin language construct such as &lsquo;<samp><span class="samp">=</span></samp>&rsquo;, &lsquo;<samp><span class="samp">\=</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">call</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">apply</span></samp>&rsquo;, and nor can such constructs be curried. 
Instead, you must either use an explicit lambda expression,
or you must write a forwarding predicate or function. 
For example, instead of

<pre class="example">     list.filter(\=(2), [1, 2, 3], List)
</pre>
   <p class="noindent">you must write either

<pre class="example">     list.filter((pred(X::in) is semidet :- X \= 2), [1, 2, 3], List)
</pre>
   <p class="noindent">or

<pre class="example">     list.filter(not_equal(2), [1, 2, 3], List)
</pre>
   <p class="noindent">where you have defined &lsquo;<samp><span class="samp">not_equal</span></samp>&rsquo; using

<pre class="example">     :- pred not_equal(T::in, T::in) is semidet.
     not_equal(X, Y) :- X \= Y.
</pre>
   <p>Another case when this arises is when want to curry a higher-order
term.  Suppose, for example, that you have a higher-order predicate
term &lsquo;<samp><span class="samp">OldPred</span></samp>&rsquo; of type &lsquo;<samp><span class="samp">pred(int, char, float)</span></samp>&rsquo;, and you want
to construct a new higher-order predicate term &lsquo;<samp><span class="samp">NewPred</span></samp>&rsquo; of type
&lsquo;<samp><span class="samp">pred(char, float)</span></samp>&rsquo; from &lsquo;<samp><span class="samp">OldPred</span></samp>&rsquo; by supplying a value
for just the first argument.  The solution is the same: use
an explicit lambda expression or a forwarding predicate. 
In either case, the body of the lambda expression or the forwarding
predicate must contain a higher-order call with all the arguments
supplied.

<div class="node">
<a name="Calling-higher-order-terms"></a>
<a name="Calling-higher_002dorder-terms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Higher_002dorder-modes">Higher-order modes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Creating-higher_002dorder-terms">Creating higher-order terms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Higher_002dorder">Higher-order</a>

</div>

<h3 class="section">8.2 Calling higher-order terms</h3>

<p>Once you have created a higher-order predicate term (sometimes known
as a closure), the next thing you want to do is to call it. 
For predicates, you use the builtin goal call/N:

     <dl>
<dt><code>call(Closure)</code><dt><code>call(Closure1, Arg1)</code><dt><code>call(Closure2, Arg1, Arg2)</code><dt><small class="dots">...</small><dd>A higher-order predicate call.  &lsquo;<samp><span class="samp">call(Closure)</span></samp>&rsquo; just calls the
specified higher-order predicate term.  The other forms append the
specified arguments onto the argument list of the closure before
calling it. 
</dl>

   <p>For example, the goal

<pre class="example">     call(Sum123, Result)
</pre>
   <p class="noindent">would bind &lsquo;<samp><span class="samp">Result</span></samp>&rsquo; to the sum of &lsquo;<samp><span class="samp">[1, 2, 3]</span></samp>&rsquo;, i.e. to 6.

   <p>For functions, you use the builtin expression apply/N:

     <dl>
<dt><code>apply(Closure)</code><dt><code>apply(Closure1, Arg1)</code><dt><code>apply(Closure2, Arg1, Arg2)</code><dt><small class="dots">...</small><dd>A higher-order function application.  Such a term denotes the
result of invoking the specified higher-order function term with
the specified arguments. 
</dl>

   <p>For example, given the definition of &lsquo;<samp><span class="samp">Double</span></samp>&rsquo; above, the goal

<pre class="example">     List = apply(Double, [1, 2, 3])
</pre>
   <p class="noindent">would be equivalent to

<pre class="example">     List = scalar_product(2, [1, 2, 3])
</pre>
   <p class="noindent">and so for a suitable implementation of the function
&lsquo;<samp><span class="samp">scalar_product/2</span></samp>&rsquo; this would bind &lsquo;<samp><span class="samp">List</span></samp>&rsquo; to
&lsquo;<samp><span class="samp">[2, 4, 6]</span></samp>&rsquo;.

   <p>One extremely useful higher-order predicate in the Mercury standard
library is <code>solutions/2</code>, which has the following declaration:

<pre class="example">     :- pred solutions(pred(T), list(T)).
     :- mode solutions(pred(out) is nondet, out) is det.
</pre>
   <p>The term which you pass to &lsquo;<samp><span class="samp">solutions/2</span></samp>&rsquo; is a higher-order
predicate term.  You can pass the name of a one-argument predicate,
or you can pass a several-argument predicate with all but one
of the arguments supplied (a closure).  The declarative semantics of
&lsquo;<samp><span class="samp">solutions/2</span></samp>&rsquo; can be defined as follows:

<pre class="example">     solutions(Pred, List) is true iff
             all [X] (call(Pred, X) &lt;=&gt; list.member(X, List))
             and List is sorted.
</pre>
   <p class="noindent">where &lsquo;<samp><span class="samp">call(Pred, X)</span></samp>&rsquo; invokes the higher-order predicate term
&lsquo;<samp><span class="samp">Pred</span></samp>&rsquo; with argument &lsquo;<samp><span class="samp">X</span></samp>&rsquo;,
and where &lsquo;<samp><span class="samp">list.member/2</span></samp>&rsquo; is the standard
library predicate for list membership.  In other words,
&lsquo;<samp><span class="samp">solutions(Pred, List)</span></samp>&rsquo; finds all the values of &lsquo;<samp><span class="samp">X</span></samp>&rsquo;
for which &lsquo;<samp><span class="samp">call(Pred, X)</span></samp>&rsquo; is true, collects these solutions
in a list, sorts the list, and returns that list as its result. 
Here's an example: the standard library defines a predicate
&lsquo;<samp><span class="samp">list.perm(List0, List)</span></samp>&rsquo;

<pre class="example">     :- pred list.perm(list(T), list(T)).
     :- mode list.perm(in, out) is nondet.
</pre>
   <p class="noindent">which succeeds iff List is a permutation of List0. 
Hence the following call to solutions

<pre class="example">     solutions(list.perm([3,1,2]), L)
</pre>
   <p class="noindent">should return all the possible permutations of the list &lsquo;<samp><span class="samp">[3,1,2]</span></samp>&rsquo;
in sorted order:

<pre class="example">     L = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]].
</pre>
   <p>See also &lsquo;<samp><span class="samp">unsorted_solutions/2</span></samp>&rsquo; and &lsquo;<samp><span class="samp">solutions_set/2</span></samp>&rsquo;, which
are defined in the standard library module &lsquo;<samp><span class="samp">solutions</span></samp>&rsquo; and documented
in the Mercury Library Reference Manual.

<div class="node">
<a name="Higher-order-modes"></a>
<a name="Higher_002dorder-modes"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Calling-higher_002dorder-terms">Calling higher-order terms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Higher_002dorder">Higher-order</a>

</div>

<h3 class="section">8.3 Higher-order modes</h3>

<p>In Mercury, the mode and determinism of a higher-order predicate or function
term are part of that term's <em>inst</em>, not its <em>type</em>. 
This allows a single higher-order predicate to work on argument
predicates of different modes and determinism, which is particularly
useful for library predicates such as &lsquo;<samp><span class="samp">list.map</span></samp>&rsquo; and &lsquo;<samp><span class="samp">list.foldl</span></samp>&rsquo;.

   <p>The language contains builtin &lsquo;<samp><span class="samp">inst</span></samp>&rsquo; values

<pre class="example">     (pred) is <var>Determinism</var>
     pred(<var>Mode</var>) is <var>Determinism</var>
     pred(<var>Mode1</var>, <var>Mode2</var>) is <var>Determinism</var>
     ...
     (func) = <var>Mode</var> is <var>Determinism</var>
     func(<var>Mode1</var>) = <var>Mode</var> is <var>Determinism</var>
     func(<var>Mode1</var>, <var>Mode2</var>) = <var>Mode</var> is <var>Determinism</var>
     ...
</pre>
   <p>These insts represent the instantiation state of variables bound
to higher-order predicate and function terms with the appropriate mode
and determinism. 
For example, &lsquo;<samp><span class="samp">pred(out) is det</span></samp>&rsquo; represents the instantiation state
of being bound to a higher-order predicate term which is &lsquo;<samp><span class="samp">det</span></samp>&rsquo;
and accepts one output argument; the term &lsquo;<samp><span class="samp">sum([1,2,3])</span></samp>&rsquo; from the
example above is one such higher-order predicate term which matches
this instantiation state.

   <p>As a convenience, the language also contains builtin &lsquo;<samp><span class="samp">mode</span></samp>&rsquo; values
of the same name (and they are what we have been using in the examples
up to now).  These modes map from the corresponding &lsquo;<samp><span class="samp">inst</span></samp>&rsquo; to
itself.  It is as if they were defined by

<pre class="example">     :- mode (pred is <var>Determinism</var>) == in(pred is <var>Determinism</var>).
     :- mode (pred(<var>Inst</var>) is <var>Determinism</var>) ==
         in(pred(<var>Inst</var>) is <var>Determinism</var>).
     ...
</pre>
   <p class="noindent">using the parametric inst &lsquo;<samp><span class="samp">in/1</span></samp>&rsquo; mentioned in <a href="#Modes">Modes</a>
which maps an inst to itself.

   <p>If you want to define a predicate which returns a higher-order predicate
term, you would use a mode such as &lsquo;<samp><span class="samp">free &gt;&gt; pred(...) is ...</span></samp>&rsquo;,
or &lsquo;<samp><span class="samp">out(pred(...) is ... )</span></samp>&rsquo;.  For example:
<!-- XXX The space after the dots{} above works around a bug in texi2html -->

<pre class="example">     :- pred foo(pred(int)).
     :- mode foo(free &gt;&gt; pred(out) is det) is det.
     
     foo(sum([1,2,3])).
</pre>
   <p>Note that in Mercury it is an error to attempt to unify two
higher-order terms.  This is because equivalence of
higher-order terms is undecidable in the general case.

   <p>For example, given the definition of &lsquo;<samp><span class="samp">foo</span></samp>&rsquo; above, the goal

<pre class="example">             foo((pred(X::out) is det :- X = 6))
</pre>
   <p class="noindent">is illegal.  If you really want to compare higher-order predicates
for equivalence, you must program it yourself; for example,
the above goal could legally be written as

<pre class="example">             P = (pred(X::out) is det :- X = 6),
             foo(Q),
             all [X] (call(P, X) &lt;=&gt; call(Q, X)).
</pre>
   <p>Note that the compiler will only catch direct attempts at higher-order
unifications; indirect attempts (via polymorphic predicates, for
example &lsquo;<samp><span class="samp">(list.append([], [P], [Q])</span></samp>&rsquo; may result in an error at
run-time rather than at compile-time.

   <p>In order to call a higher-order term, the compiler must know its higher-order
inst.  This can cause problems when higher-order terms are placed into a
polymorphic collection type and then extracted, since the declared mode for the
extraction will typically be &lsquo;<samp><span class="samp">out</span></samp>&rsquo; and the higher-order inst information
will be lost. 
To partially alleviate this problem, and to make higher-order functional
programming easier, if the term to be called has a function
type, but no higher-order inst information, we assume that it has the default
higher-order function inst
&lsquo;<samp><span class="samp">func(in, ..., in) = out is </span><var>Determinism</var></samp>&rsquo;.

   <p>As a consequence of this, it is a mode error to pass a higher-order function
term that does not match this standard mode to somewhere where its higher-order
inst information may be lost, such as to a polymorphic predicate where the
argument mode is &lsquo;<samp><span class="samp">in</span></samp>&rsquo;.

   <p>Mercury also provides builtin &lsquo;<samp><span class="samp">inst</span></samp>&rsquo; values for use with solver types:

<pre class="example">     any_pred is <var>Determinism</var>
     any_pred(<var>Mode</var>) is <var>Determinism</var>
     any_pred(<var>Mode1</var>, <var>Mode2</var>) is <var>Determinism</var>
     ...
     any_func = <var>Mode</var> is <var>Determinism</var>
     any_func(<var>Mode1</var>) = <var>Mode</var> is <var>Determinism</var>
     any_func(<var>Mode1</var>, <var>Mode2</var>) = <var>Mode</var> is <var>Determinism</var>
     ...
</pre>
   <p>See <a href="#Solver-types">Solver types</a> for more details.

<div class="node">
<a name="Modules"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Type-classes">Type classes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Higher_002dorder">Higher-order</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Modules</h2>

<ul class="menu">
<li><a accesskey="1" href="#The-module-system">The module system</a>
<li><a accesskey="2" href="#An-example-module">An example module</a>
<li><a accesskey="3" href="#Sub_002dmodules">Sub-modules</a>
<li><a accesskey="4" href="#Module-initialisation">Module initialisation</a>
<li><a accesskey="5" href="#Module-finalisation">Module finalisation</a>
<li><a accesskey="6" href="#Module_002dlocal-mutable-variables">Module-local mutable variables</a>
</ul>

<div class="node">
<a name="The-module-system"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#An-example-module">An example module</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modules">Modules</a>

</div>

<h3 class="section">9.1 The module system</h3>

<p>The Mercury module system is relatively simple and straightforward.

   <p>Each module must start with a &lsquo;<samp><span class="samp">:- module </span><var>ModuleName</var></samp>&rsquo;
declaration, specifying the name of the module.

   <p>An &lsquo;<samp><span class="samp">:- interface.</span></samp>&rsquo; declaration indicates
the start of the module's interface section:
this section specifies the entities that are exported by this module. 
Mercury provides support for abstract data types, by allowing the
definition of a type to be kept hidden, with the interface
only exporting the type name. 
The interface section may contain definitions of types,
type classes, data constructors, instantiation states, and
modes, and declarations for abstract data types, abstract type class
instances, functions, predicates, and (sub-)modules. 
The interface section may not contain definitions for functions or
predicates (i.e. clauses), or definitions of (sub-)modules.

   <p>An &lsquo;<samp><span class="samp">:- implementation.</span></samp>&rsquo; declaration indicates
the start of the module's implementation section. 
Any entities declared in this section are local to the module
(and its sub-modules) and cannot be used by other modules. 
The implementation section must contain definitions
for all abstract data types, abstract instance declarations,
functions, predicates, and sub-modules exported by the module,
as well as for all local types, type class instances, functions,
predicates, and sub-modules. 
The implementation section can be omitted if it is empty.

   <p>The module may optionally end with a &lsquo;<samp><span class="samp">:- end_module </span><var>ModuleName</var></samp>&rsquo;
declaration; the name specified in the &lsquo;<samp><span class="samp">end_module</span></samp>&rsquo; must be the
same as that in the corresponding &lsquo;<samp><span class="samp">module</span></samp>&rsquo; declaration.

<!-- should we mention multipart interfaces and implementations? -->
<!-- ===> no -->
   <p>If a module wishes to make use of entities exported by other modules,
then it must explicitly import those modules using one or more
&lsquo;<samp><span class="samp">:- import_module </span><var>Modules</var></samp>&rsquo; or &lsquo;<samp><span class="samp">:- use_module </span><var>Modules</var></samp>&rsquo;
declarations, in order to make those declarations visible. 
In both cases, <var>Modules</var> is a comma-separated list of
fully-qualified module names. 
These declarations may occur either in the interface or the implementation
section.  If the imported entities are used in the interface section,
then the corresponding <code>import_module</code> or <code>use_module</code>
declaration must also be in the interface section.  If the imported
entities are only used in the implementation section, the
<code>import_module</code> or <code>use_module</code> declaration should be in
the implementation section.

   <p>The names of predicates, functions, constructors, constructor fields,
types, modes, insts, type classes,
and (sub-)modules can be explicitly module qualified using the &lsquo;<samp><span class="samp">.</span></samp>&rsquo;
operator, e.g. &lsquo;<samp><span class="samp">module.name</span></samp>&rsquo; or &lsquo;<samp><span class="samp">module.submodule.name</span></samp>&rsquo;. 
This is useful both for readability and for resolving name conflicts. 
Uses of entities imported using <code>use_module</code> declarations
<em>must</em> be explicitly module qualified.

   <p>Currently we also support &lsquo;<samp><span class="samp">__</span></samp>&rsquo; as an alternative module qualifier,
so you can write <code>module__name</code> instead of <code>module.name</code>.

   <p>Certain optimizations require information or source code for predicates
defined in other modules to be as effective as possible.  At the moment,
inlining and higher-order specialization are the only optimizations that
the Mercury compiler can perform across module boundaries.

   <p>One module must export a predicate &lsquo;<samp><span class="samp">main/2</span></samp>&rsquo;, which
must be declared as either

<pre class="example">     :- pred main(io.state::di, io.state::uo) is det.
</pre>
   <p class="noindent">or

<pre class="example">     :- pred main(io.state::di, io.state::uo) is cc_multi.
</pre>
   <p class="noindent">(or any declaration equivalent to one of the two above).

   <p>Mercury has a standard library which includes modules for
lists, stacks, queues, priority queues, sets, bags (multi-sets),
maps (dictionaries), random number generation, input/output
and filename and directory handling. 
See the Mercury Library Reference Manual for details.

<div class="node">
<a name="An-example-module"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Sub_002dmodules">Sub-modules</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-module-system">The module system</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modules">Modules</a>

</div>

<h3 class="section">9.2 An example module.</h3>

<p>For illustrative purposes, here is the definition of a
simple module for managing queues:

<pre class="example">     :- module queue.
     :- interface.
     
     % Declare an abstract data type.
     
     :- type queue(T).
     
     % Declare some predicates which operate on the abstract data type.
     
     :- pred empty_queue(queue(T)).
     :- mode empty_queue(out) is det.
     :- mode empty_queue(in) is semidet.
     
     :- pred put(queue(T), T, queue(T)).
     :- mode put(in, in, out) is det.
     
     :- pred get(queue(T), T, queue(T)).
     :- mode get(in, out, out) is semidet.
     
     :- implementation.
     
     % Queues are implemented as lists. We need the `list' module
     % for the declaration of the type list(T), with its constructors
     % '[]'/0 % and '.'/2, and for the declaration of the predicate
     % list.append/3.
     
     :- import_module list.
     
     % Define the queue ADT.
     
     :- type queue(T) == list(T).
     
     % Declare the exported predicates.
     
     empty_queue([]).
     
     put(Queue0, Elem, Queue) :-
              list.append(Queue0, [Elem], Queue).
     
     get([Elem | Queue], Elem, Queue).
     
     :- end_module queue.
     
</pre>
   <div class="node">
<a name="Sub-modules"></a>
<a name="Sub_002dmodules"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Module-initialisation">Module initialisation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#An-example-module">An example module</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modules">Modules</a>

</div>

<h3 class="section">9.3 Sub-modules</h3>

<p>As mentioned above, modules may contain sub-modules. 
There are two kinds of sub-modules, called nested sub-modules
and separate sub-modules; the difference is that nested sub-modules
are defined in the same source file as the containing module,
whereas separate sub-modules are defined in separate source files. 
Implementations should support separate compilation of separate sub-modules.

   <p>A module may not contain more than one sub-module with the same name.

<ul class="menu">
<li><a accesskey="1" href="#Nested-sub_002dmodules">Nested sub-modules</a>
<li><a accesskey="2" href="#Separate-sub_002dmodules">Separate sub-modules</a>
<li><a accesskey="3" href="#Visibility-rules">Visibility rules</a>
<li><a accesskey="4" href="#Implementation-bugs-and-limitations">Implementation bugs and limitations</a>
</ul>

<div class="node">
<a name="Nested-sub-modules"></a>
<a name="Nested-sub_002dmodules"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Separate-sub_002dmodules">Separate sub-modules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Sub_002dmodules">Sub-modules</a>

</div>

<h4 class="subsection">9.3.1 Nested sub-modules</h4>

<p>Nested sub-modules within a module are delimited by
matching &lsquo;<samp><span class="samp">:- module</span></samp>&rsquo; and &lsquo;<samp><span class="samp">:- end_module</span></samp>&rsquo; declarations. 
(Note that &lsquo;<samp><span class="samp">:- end_module</span></samp>&rsquo; for nested sub-modules
are mandatory, not optional, even if the nested sub-module
is the last thing in the source file. 
Also note that the module name in a &lsquo;<samp><span class="samp">:- module</span></samp>&rsquo; or &lsquo;<samp><span class="samp">:- end_module</span></samp>&rsquo;
declaration need not be fully-qualified.) 
The sequence of items thus delimited is known as a sub-module item sequence.

   <p>The interface and implementation parts of a nested sub-module
may be specified in two different sub-module declarations. 
If a sub-module item sequence includes an interface section,
then it is a declaration of that sub-module;
if it includes an implementation section,
then it is a definition of that sub-module;
and if includes both, then it is both declaration and definition.

   <p>It is an error to declare a sub-module twice, or to define it twice. 
It is an error to define a sub-module without declaring it. 
As mentioned earlier, it is an error to define a sub-module in the
interface section of its parent module.

   <p>If a sub-module is declared but not explicitly defined,
then there is an implicit definition with an empty implementation section
for that sub-module (this will result in an error, if the interface
section includes declarations but not definitions for any types,
predicates, modes, or (doubly) nested sub-modules).

<div class="node">
<a name="Separate-sub-modules"></a>
<a name="Separate-sub_002dmodules"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Visibility-rules">Visibility rules</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Nested-sub_002dmodules">Nested sub-modules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Sub_002dmodules">Sub-modules</a>

</div>

<h4 class="subsection">9.3.2 Separate sub-modules</h4>

<p>Separate sub-modules are declared using
&lsquo;<samp><span class="samp">:- include_module </span><var>Modules</var></samp>&rsquo; declarations. 
Each &lsquo;<samp><span class="samp">:- include_module</span></samp>&rsquo; declaration specifies a comma-separated list
of sub-modules.

<pre class="example">     :- include_module <var>Module1</var>, <var>Module2</var>, ..., <var>ModuleN</var>.
</pre>
   <p>Each of the named sub-modules in an &lsquo;<samp><span class="samp">:- include_module</span></samp>&rsquo; declaration
must be defined in a separate source file. 
The mapping between module names and source file names is
implementation-defined.  (For a module named &lsquo;<samp><span class="samp">foo.bar.baz</span></samp>&rsquo;,
The University of Melbourne Mercury implementation requires the source
to be located in a file named <samp><span class="file">foo.bar.baz.m</span></samp>, <samp><span class="file">bar.baz.m</span></samp>,
or <samp><span class="file">baz.m</span></samp>.) 
The separate source file must contain the declaration (interface)
and definition (implementation) of the sub-module. 
It must start with a &lsquo;<samp><span class="samp">:- module</span></samp>&rsquo; declaration
which matches that in the &lsquo;<samp><span class="samp">:- include_module</span></samp>&rsquo; declaration
in the parent, followed by the interface and (if necessary)
implementation sections, and it may optionally end with a &lsquo;<samp><span class="samp">:- end_module</span></samp>&rsquo;
declaration.  (Note: the module names in the &lsquo;<samp><span class="samp">:- module</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">:- end_module</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">:- include_module</span></samp>&rsquo; declarations
need not be fully-qualified.  However,
if the file name used for a particular module does
not include all the module qualifiers, then the University of Melbourne
Mercury implementation requires the module name in the &lsquo;<samp><span class="samp">:- module</span></samp>&rsquo;
declaration for that module to be fully qualified.)

   <p>The semantics of separate sub-modules are identical to those of nested
sub-modules.  The procedure to transform a separate sub-module into a
nested sub-module is as follows:

     <ol type=1 start=1>
<li>Replace the &lsquo;<samp><span class="samp">:- include_module </span><var>submodule</var></samp>&rsquo; declaration with
the interface section of the sub-module enclosed within
&lsquo;<samp><span class="samp">:- module </span><var>submodule</var></samp>&rsquo; and &lsquo;<samp><span class="samp">:- end_module </span><var>submodule</var></samp>&rsquo;
declarations. 
<li>Place the implementation section of the sub-module enclosed within
&lsquo;<samp><span class="samp">:- module </span><var>submodule</var></samp>&rsquo; and &lsquo;<samp><span class="samp">:- end_module </span><var>submodule</var></samp>&rsquo;
declarations in the implementation section of the parent module.
        </ol>

   <p>For example

<pre class="example">     :- module x.
     :- interface.
     :- include_module y.
     :- end_module x.
</pre>
   <p class="noindent">is equivalent to

<pre class="example">     :- module x.
     :- interface.
         :- module y.
         % interface section of module &lsquo;<samp><span class="samp">y</span></samp>&rsquo;
         :- end_module y.
     :- implementation.
         :- module y.
         % implementation section of module &lsquo;<samp><span class="samp">y</span></samp>&rsquo;
         :- end_module y.
     :- end_module x.
</pre>
   <div class="node">
<a name="Visibility-rules"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Implementation-bugs-and-limitations">Implementation bugs and limitations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Separate-sub_002dmodules">Separate sub-modules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Sub_002dmodules">Sub-modules</a>

</div>

<h4 class="subsection">9.3.3 Visibility rules</h4>

<p>Any declarations in the parent module, including those in the
parent module's implementation section, are visible in the parent's
sub-modules, including indirect sub-modules (i.e. sub-sub-modules, etc.). 
Similarly, declarations in the interfaces of any modules imported using an
&lsquo;<samp><span class="samp">:- import_module</span></samp>&rsquo; or a &lsquo;<samp><span class="samp">:- use_module</span></samp>&rsquo; in the parent module
are visible in the parent's sub-modules, including indirect sub-modules.

   <p>Declarations in a child module are not visible in the parent module,
or in &ldquo;sibling&rdquo; modules (other children of the same parent), or in
other unrelated modules unless the child is explicitly imported using
an &lsquo;<samp><span class="samp">:- import_module</span></samp>&rsquo; or &lsquo;<samp><span class="samp">:- use_module</span></samp>&rsquo; declaration.  It
is an error to import a module without importing all of its parent
modules.

   <p>Note that a sub-module for which the &lsquo;<samp><span class="samp">:- module</span></samp>&rsquo; or
&lsquo;<samp><span class="samp">:- include_module</span></samp>&rsquo; declaration occurs only in the implementation
section of the parent module may only be imported or used by its
parent module or by sub-modules of its parent module.

   <p>Note that as mentioned previously, all &lsquo;<samp><span class="samp">:- import_module</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">:- use_module</span></samp>&rsquo; declarations must use fully-qualified module
names.

<div class="node">
<a name="Implementation-bugs-and-limitations"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Visibility-rules">Visibility rules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Sub_002dmodules">Sub-modules</a>

</div>

<h4 class="subsection">9.3.4 Implementation bugs and limitations</h4>

<p>The current implementation of sub-modules has a couple of minor
limitations.

     <ul>
<li>The compiler sometimes reports spurious errors if you
define an equivalence type in a sub-module and export it
as abstract type. 
<li>Using &lsquo;<samp><span class="samp">mmake</span></samp>&rsquo; to do parallel makes (e.g. &lsquo;<samp><span class="samp">mmake --jobs 2</span></samp>&rsquo;)
doesn't always work correctly if you're using nested sub-modules. 
(The work-around is to use separate sub-modules instead of nested
sub-modules, i.e. to put the sub-modules in separate source files.) 
</ul>

<div class="node">
<a name="Module-initialisation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Module-finalisation">Module finalisation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Sub_002dmodules">Sub-modules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modules">Modules</a>

</div>

<h3 class="section">9.4 Module initialisation</h3>

<p>Modules that interact with foreign libraries or services
may require special initialisation before use. 
Such modules may include any number of &lsquo;<samp><span class="samp">initialise</span></samp>&rsquo; directives
in their implementation sections. 
An &lsquo;<samp><span class="samp">initialise</span></samp>&rsquo; directive has the following form:

<pre class="example">     :- initialise initpredname/arity.
</pre>
   <p>where the predicate &lsquo;<samp><span class="samp">initpredname</span></samp>&rsquo; must be declared with one of the
following signatures:

<pre class="example">     :- pred initpredname(io::di, io::uo) is <var>Det</var>.
     :- impure pred initpredname is <var>Det</var>.
</pre>
   <p><var>Det</var> must be either &lsquo;<samp><span class="samp">det</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo;.

   <p>The effect of the &lsquo;<samp><span class="samp">initialise</span></samp>&rsquo; declaration is to ensure that
&lsquo;<samp><span class="samp">initpredname/arity</span></samp>&rsquo; is invoked before the program's &lsquo;<samp><span class="samp">main/2</span></samp>&rsquo;
predicate.  Initialisation predicates within a module are executed in the
order in which they are specified, although no order may be assumed between
different modules or sub-modules.  Initialisation predicates are only invoked
after any initialisation required by the Mercury standard library.

   <p>If &lsquo;<samp><span class="samp">initpredname/arity</span></samp>&rsquo; terminates with an uncaught exception then
the program will immediately abort execution. 
In this circumstance those predicates specified by other &lsquo;<samp><span class="samp">initialise</span></samp>&rsquo;
directives that have not yet been executed will not be executed,
&lsquo;<samp><span class="samp">main/2</span></samp>&rsquo; will not be executed and no predicate specified in a
&lsquo;<samp><span class="samp">finalise</span></samp>&rsquo; directive will be executed.

   <p>&lsquo;<samp><span class="samp">initialize</span></samp>&rsquo; is also allowed as a synonym for &lsquo;<samp><span class="samp">initialise</span></samp>&rsquo;.

<div class="node">
<a name="Module-finalisation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Module_002dlocal-mutable-variables">Module-local mutable variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Module-initialisation">Module initialisation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modules">Modules</a>

</div>

<h3 class="section">9.5 Module finalisation</h3>

<p>Modules that require special finalisation at program termination
may include any number of &lsquo;<samp><span class="samp">finalise</span></samp>&rsquo; directives in their
implementation sections.

   <p>A &lsquo;<samp><span class="samp">finalise</span></samp>&rsquo; directive has the following form:

<pre class="example">     :- finalise finalpredname/arity.
</pre>
   <p>where the predicate &lsquo;<samp><span class="samp">finalpredname/arity</span></samp>&rsquo; must be declared with
one of the following signature:

<pre class="example">     :- pred finalpredname(io::di, io::uo) is <var>Det</var>.
     :- impure pred finalpredname is <var>Det</var>
</pre>
   <p><var>Det</var> must be either &lsquo;<samp><span class="samp">det</span></samp>&rsquo; or &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo;.

   <p>The effect of the &lsquo;<samp><span class="samp">finalise</span></samp>&rsquo; declaration is to ensure that
&lsquo;<samp><span class="samp">finalpredname/arity</span></samp>&rsquo; is invoked after the program's &lsquo;<samp><span class="samp">main</span></samp>&rsquo;
predicate.  Finalisation predicates within a module are executed in
the order in which they are specified, although no order may be assumed between
different modules or sub-modules.  Any finalisation required by the Mercury
standard library will always occur after any finalisation predicates have been
invoked.

   <p>If &lsquo;<samp><span class="samp">finalpredname/arity</span></samp>&rsquo; terminates with an uncaught exception then
the program will immediately abort execution.  No predicates specified
by other &lsquo;<samp><span class="samp">finalise</span></samp>&rsquo; directives that have not yet been executed will
be executed.

   <p>&lsquo;<samp><span class="samp">finalize</span></samp>&rsquo; is also allowed as a synonym for &lsquo;<samp><span class="samp">finalise</span></samp>&rsquo;.

<div class="node">
<a name="Module-local-mutable-variables"></a>
<a name="Module_002dlocal-mutable-variables"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Module-finalisation">Module finalisation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Modules">Modules</a>

</div>

<h3 class="section">9.6 Module-local mutable variables</h3>

<p>Certain special cases require a module to have one or more mutable (i.e. 
destructively updatable) variables, for example to hold the constraint
store for a solver type.

   <p>A mutable variable is declared using the &lsquo;<samp><span class="samp">mutable</span></samp>&rsquo; directive:

<pre class="example">     :- mutable(varname, vartype, initial_value, varinst, [attribute, ...]).
</pre>
   <p>This constructs a new mutable variable with access predicates that have the
following signatures:

<pre class="example">     :- semipure pred get_varname(vartype::out(varinst)) is det.
     :- impure   pred set_varname(vartype::in(varinst)) is det.
</pre>
   <p>The initial value of &lsquo;<samp><span class="samp">varname</span></samp>&rsquo; is &lsquo;<samp><span class="samp">initial_value</span></samp>&rsquo;, which is set
before the program's &lsquo;<samp><span class="samp">main/2</span></samp>&rsquo; predicate is executed.

   <p>The type &lsquo;<samp><span class="samp">vartype</span></samp>&rsquo; is not allowed to contain any type variables or
have any type class constraints.

   <p>The inst &lsquo;<samp><span class="samp">varinst</span></samp>&rsquo; is not allowed to contain any inst variables. 
It is also not allowed to be equivalent to, or contain components that
are equivalent to, the builtin insts &lsquo;<samp><span class="samp">free</span></samp>&rsquo;, &lsquo;<samp><span class="samp">unique</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">mostly_unique</span></samp>&rsquo;, &lsquo;<samp><span class="samp">dead</span></samp>&rsquo; or &lsquo;<samp><span class="samp">mostly_dead</span></samp>&rsquo;.

   <p>The initial value of a mutable, &lsquo;<samp><span class="samp">initial_value</span></samp>&rsquo;, may be any Mercury
expression with type &lsquo;<samp><span class="samp">vartype</span></samp>&rsquo; and inst &lsquo;<samp><span class="samp">varinst</span></samp>&rsquo; subject to
the above restrictions. It may be impure or semipure.

   <p>The following &lsquo;<samp><span class="samp">attributes</span></samp>&rsquo; must be supported:

     <dl>
<dt>&lsquo;<samp><span class="samp">trailed</span></samp>&rsquo;/&lsquo;<samp><span class="samp">untrailed</span></samp>&rsquo;<dd>This attribute declares if the implementation should generate code so that
the effects of &lsquo;<samp><span class="samp">set_varname/1</span></samp>&rsquo; can be undone on backtracking. 
The default, in case none is specified, is &lsquo;<samp><span class="samp">trailed</span></samp>&rsquo;.

     <br><dt>&lsquo;<samp><span class="samp">attach_to_io_state</span></samp>&rsquo;<dd>This attribute causes the compiler to also construct access predicates
that have the following signatures:

     <pre class="example">          :- pred get_varname(vartype::out(varinst), io::di, io::uo) is det.
          :- pred set_varname(vartype::in(varinst),  io::di, io::uo) is det.
</pre>
     <br><dt>&lsquo;<samp><span class="samp">constant</span></samp>&rsquo;<dd>This attribute causes the compiler to construct
only a &lsquo;<samp><span class="samp">get</span></samp>&rsquo; access predicate, but not a &lsquo;<samp><span class="samp">set</span></samp>&rsquo; access predicate. 
Since &lsquo;<samp><span class="samp">varname</span></samp>&rsquo; will always have the initial value given to it,
the &lsquo;<samp><span class="samp">get</span></samp>&rsquo; access predicate is pure; its signature will be:

     <pre class="example">          :- pred get_varname(vartype::out(varinst)) is det.
</pre>
     <p>The &lsquo;<samp><span class="samp">constant</span></samp>&rsquo; attribute cannot be specified together with
the &lsquo;<samp><span class="samp">attach_to_io_state</span></samp>&rsquo; attribute
(since they disagree on this signature). 
It also cannot be specified together with an explicit &lsquo;<samp><span class="samp">trailed</span></samp>&rsquo;
attribute.

   </dl>

   <p>The Melbourne Mercury compiler also supports the following attributes:

     <dl>
<dt>&lsquo;<samp><span class="samp">foreign_name(Lang, Name)</span></samp>&rsquo;<dd>Allow foreign code to access the mutable variable in some implementation
dependent manner.  &lsquo;<samp><span class="samp">Lang</span></samp>&rsquo; must be a valid target language for
this Mercury implementation.  &lsquo;<samp><span class="samp">Name</span></samp>&rsquo; must be a valid identifier in
that language.  It is an error to specify more than one foreign name
attribute for each language.

     <p>For the C backends this attribute allows foreign code to access
the mutable variable as an external variable called &lsquo;<samp><span class="samp">Name</span></samp>&rsquo;. 
For the low-level C backend, e.g. the asm_fast grades, the type of this
variable will be <code>MR_Word</code>. 
For the high-level C backend, e.g. the hlc grades, the type of this variable
depends upon the Mercury type of the mutable.  For mutables of the Mercury
types <code>int</code>, <code>float</code>, <code>char</code> and <code>string</code>, the
corresponding C types will be <code>MR_Integer</code>, <code>MR_Float</code>,
<code>MR_Char</code> and <code>MR_String</code> respectively.  For mutables of any other
type the corresponding C type will be <code>MR_Word</code>.

     <p>This attribute is not currently implemented for the non-C backends.

     <br><dt>&lsquo;<samp><span class="samp">thread_local</span></samp>&rsquo;<dd>This attribute allows a mutable to take on different values in each
thread.  When a child thread is spawned, it inherits all the values of
thread-local mutables of the parent thread.  Changing the value of a
thread-local mutable does not affect its value in any other threads.

     <p>The &lsquo;<samp><span class="samp">thread_local</span></samp>&rsquo; attribute cannot be specified together with
either of the &lsquo;<samp><span class="samp">trailed</span></samp>&rsquo; or &lsquo;<samp><span class="samp">constant</span></samp>&rsquo; attributes.

   </dl>

   <p>It is an error for a &lsquo;<samp><span class="samp">mutable</span></samp>&rsquo; directive to appear in the
interface section of a module.  The usual visibility rules for sub-modules
apply to the mutable variable access predicates.

   <p>For the purposes of determining when mutables are assigned their initial
values, the expression &lsquo;<samp><span class="samp">initial_value</span></samp>&rsquo; behaves as though it were
a predicate specified in an &lsquo;<samp><span class="samp">initialise</span></samp>&rsquo; directive.

<pre class="example">             :- initialise foo/2.
             :- mutable(bar, int, 561, ground, [untrailed]).
             :- initialise baz/2.
</pre>
   <p>In the above example &lsquo;<samp><span class="samp">foo/2</span></samp>&rsquo; is invoked first, then &lsquo;<samp><span class="samp">bar</span></samp>&rsquo;
is set with an initial value of 561 and the &lsquo;<samp><span class="samp">baz/2</span></samp>&rsquo; is invoked.

   <p>The effect of a mutable initial value expression terminating with
an uncaught exception is also the same as though it were a predicate
specified in a &lsquo;<samp><span class="samp">initialise</span></samp>&rsquo; directive.

<div class="node">
<a name="Type-classes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Existential-types">Existential types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Modules">Modules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Type classes</h2>

<p>Mercury supports constrained polymorphism in the form of type classes. 
Type classes allow the programmer to write predicates and functions which
operate on variables of any type (or sequence of types) for which a certain
set of operations is defined.

<ul class="menu">
<li><a accesskey="1" href="#Typeclass-declarations">Typeclass declarations</a>
<li><a accesskey="2" href="#Instance-declarations">Instance declarations</a>
<li><a accesskey="3" href="#Abstract-typeclass-declarations">Abstract typeclass declarations</a>
<li><a accesskey="4" href="#Abstract-instance-declarations">Abstract instance declarations</a>
<li><a accesskey="5" href="#Type-class-constraints-on-predicates-and-functions">Type class constraints on predicates and functions</a>
<li><a accesskey="6" href="#Type-class-constraints-on-type-class-declarations">Type class constraints on type class declarations</a>
<li><a accesskey="7" href="#Type-class-constraints-on-instance-declarations">Type class constraints on instance declarations</a>
<li><a accesskey="8" href="#Functional-dependencies">Functional dependencies</a>
</ul>

<div class="node">
<a name="Typeclass-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Instance-declarations">Instance declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-classes">Type classes</a>

</div>

<h3 class="section">10.1 Typeclass declarations</h3>

<p>A <dfn>type class</dfn> is a name for a set of types (or a set of sequences of
types) for which certain predicates and/or functions, called the <dfn>methods</dfn>
of that type class, are defined. 
A &lsquo;<samp><span class="samp">typeclass</span></samp>&rsquo; declaration defines a new type class, and
specifies the set of predicates and/or functions
that must be defined on a type (or sequence of types) for it (them) to be
considered to be an instance of that type class.

   <p>The <code>typeclass</code> declaration gives the name of the type class that
it is defining, the
names of the type variables which are parameters to the type class, and the
operations (i.e. methods) which form the interface of the type class. 
For each method, all parameters of the typeclass must be determined by
the type variables appearing in the type signature of the method. 
A variable is determined by a type signature if it appears in the
type signature, but if functional dependencies are present
then it may also be determined from the other variables
(see <a href="#Functional-dependencies">Functional dependencies</a>).

   <p>For example,

<pre class="example">     :- typeclass point(T) where [
             % coords(Point, X, Y):
             %       X and Y are the cartesian coordinates of Point
             pred coords(T, float, float),
             mode coords(in, out, out) is det,
     
             % translate(Point, X_Offset, Y_Offset) = NewPoint:
             %       NewPoint is Point translated X_Offset units in the X direction
             %       and Y_Offset units in the Y direction
             func translate(T, float, float) = T
     ].
</pre>
   <p class="noindent">declares the type class <code>point</code>, which
represents points in two dimensional space.

   <p><code>pred</code>, <code>func</code> and <code>mode</code> declarations are the only
legal declarations inside a <code>typeclass</code> declaration.  The mode and
determinism of type class methods must be explicitly declared or
(for functions) defaulted, not inferred.  In other words, for each
predicate declared in a type class, there must be at least one mode
declaration, and each mode declaration in a type class must include
an explicit determinism annotation.  Functions with no explicit mode
declaration get the usual default mode (see <a href="#Modes">Modes</a>): all arguments
have mode &lsquo;<samp><span class="samp">in</span></samp>&rsquo;, the result has mode &lsquo;<samp><span class="samp">out</span></samp>&rsquo;, and the determinism
is &lsquo;<samp><span class="samp">det</span></samp>&rsquo;.

   <p>The number of parameters to the type class (e.g. <code>T</code>) is not limited. 
For example, the following is allowed:

<pre class="example">     :- typeclass a(T1, T2) where [...].
</pre>
   <p>The parameters must be distinct variables. 
Each <code>typeclass</code> declaration must have at least one parameter.

   <p>It is OK for a <code>typeclass</code> declaration to declare no methods,
e.g.

<pre class="example">     :- typeclass foo(T) where [].
</pre>
   <p>There must not be more than one type class declaration with the
same name and arity in the same module.

<div class="node">
<a name="Instance-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Abstract-typeclass-declarations">Abstract typeclass declarations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Typeclass-declarations">Typeclass declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-classes">Type classes</a>

</div>

<h3 class="section">10.2 Instance declarations</h3>

<p>Once the interface of the type class has been defined in the <code>typeclass</code>
declaration, we can use an <code>instance</code> declaration to define how a
particular type (or sequence of types) satisfies the interface declared
in the <code>typeclass</code> declaration.

   <p>An instance declaration has the form

<pre class="example">     :- instance <var>classname</var>(<var>typename</var>(<var>typevar</var>, ...), ...)
             where [<var>methoddefinition</var>, <var>methoddefinition</var>, ...].
</pre>
   <p>An &lsquo;<samp><span class="samp">instance</span></samp>&rsquo; declaration gives a type for each parameter of the
type class.  Each of these types must be either a type with no arguments, or
a polymorphic type whose arguments are all distinct type variables. 
<!-- If this restriction is ever lifted, the algorithms for encoding the names of -->
<!-- the data structures describing the instance, in base_typeclass_info.m -->
<!-- and/or rtti.m, would need to be updated as well. -->
For example <code>int</code>, <code>list(T)</code> and <code>bintree(K,V)</code> are allowed,
but <code>T</code>, <code>list(int)</code> and <code>bintree(T,T)</code> are not. 
The types in an instance declaration must not be abstract types which
are elsewhere defined as equivalence types. 
A program may not contain more than one instance
declaration for a particular type (or sequence of types, in
the case of a multi-parameter type class) and typeclass. 
These restrictions ensure that there are no overlapping
instance declarations, i.e. for each typeclass there is at
most one instance declaration that may be applied to any
type (or sequence of types).

   <p>Each <var>methoddefinition</var> entry in the &lsquo;<samp><span class="samp">where [...]</span></samp>&rsquo; part
of an <code>instance</code> declaration defines the implementation of one of
the class methods for this instance.  There are two ways of defining
methods.  The first way is to define a method by giving the name of
the predicate or function which implements that method.  In this
case, the <var>methoddefinition</var> must have one of the following forms:

<pre class="example">     pred(<var>methodname</var>/<var>arity</var>) is <var>predname</var>
     func(<var>methodname</var>/<var>arity</var>) is <var>funcname</var>
</pre>
   <p class="noindent">The <var>predname</var> or <var>funcname</var> must name a function or
predicate of the specified arity whose type, modes, determinism, and
purity are at least as permissive as the declared type, modes,
determinism, and purity of the class method with the specified
<var>methodname</var> and <var>arity</var>, after the types of the arguments
in the instance declaration have been substituted in place of the
parameters in the type class declaration.

   <p>The second way of defining methods is by listing the clauses for the
definition inside the instance declaration.  A <var>methoddefinition</var>
can be a clause.  These clauses are just like the clauses used to
define ordinary predicates or functions (see <a href="#Items">Items</a>), and so they
can be facts, rules, or DCG rules.  The only difference is that in instance
declarations, clauses are separated by commas rather than being terminated
by periods, and so rules and DCG rules in instance declarations must
normally be enclosed in parentheses.  As with ordinary predicates,
you can have more than one clause for each method.  The clauses must
satisfy the declared type, modes, determinism and purity for the
method, after the types of the arguments in the instance declaration
have been substituted in place of the parameters in the type class
declaration.

   <p>These two ways are mutually exclusive: each method must be defined
either by a single naming definition (using the &lsquo;<samp><span class="samp">pred(...) is
</span><var>predname</var></samp>&rsquo; or &lsquo;<samp><span class="samp">func(...) is </span><var>funcname</var></samp>&rsquo; form),
or by a set of one or more clauses, but not both.

   <p>Here's an example of an instance declaration and the different kinds
of method definitions that it can contain:

<pre class="example">     :- typeclass foo(T) where [
     	func method1(T, T) = int,
     	func method2(T) = int,
     	pred method3(T::in, int::out) is det,
     	pred method4(T::in, io.state::di, io.state::uo) is det,
     	func method5(bool, T) = T
     ].
     
     :- instance foo(int) where [
     	% method defined by naming the implementation
     	func(method1/2) is (+),
     
     	% method defined by a fact
     	method2(X) = X + 1,
     
     	% method defined by a rule
     	(method3(X, Y) :- Y = X + 2),
     
     	% method defined by a DCG rule
     	(method4(X) --&gt; io.print(X), io.nl),
     
     	% method defined by multiple clauses
     	method5(no, _) = 0,
     	(method5(yes, X) = Y :- X + Y = 0)
     ].
</pre>
   <p>Each &lsquo;<samp><span class="samp">instance</span></samp>&rsquo; declaration must define an implementation for
every method declared in the corresponding &lsquo;<samp><span class="samp">typeclass</span></samp>&rsquo; declaration. 
It is an error to define more than one implementation for the same
method within a single &lsquo;<samp><span class="samp">instance</span></samp>&rsquo; declaration.

   <p>Any call to a method must have argument types (and in the case of functions,
return type) which are constrained to be a member of that method's
type class, or which match one of the instance declarations visible at
the point of the call.  A method call will invoke the
predicate or function specified for that method in the
instance declaration that matches the types of the arguments
to the call.

   <p>Note that even if a type class has no methods, an explicit instance
declaration is required for a type to be considered an instance
of that type class.

   <p>Here's an example of some code using an instance declaration:

<pre class="example">     :- type coordinate
             ---&gt; coordinate(
                     float,           % X coordinate
                     float            % Y coordinate
             ).
     
     :- instance point(coordinate) where [
             pred(coords/3) is coordinate_coords,
             func(translate/3) is coordinate_translate
     ].
     
     
     :- pred coordinate_coords(coordinate, float, float).
     :- mode coordinate_coords(in, out, out) is det.
     
     coordinate_coords(coordinate(X, Y), X, Y).
     
     :- func coordinate_translate(coordinate, float, float) = coordinate.
     
     coordinate_translate(coordinate(X, Y), Dx, Dy) = coordinate(X + Dx, Y + Dy).
</pre>
   <p>We have now made the <code>coordinate</code> type an instance of the <code>point</code>
type class.  If we introduce a new type, <code>coloured_coordinate</code> which
represents a point in two dimensional space with a colour associated with it,
it can also become an instance of the type class:

<pre class="example">     :- type rgb
             ---&gt; rgb(
                     int,
                     int,
                     int
             ).
     
     :- type coloured_coordinate
             ---&gt; coloured_coordinate(
                     float,
                     float,
                     rgb
             ).
     
     :- instance point(coloured_coordinate) where [
             pred(coords/3) is coloured_coordinate_coords,
             func(translate/3) is coloured_coordinate_translate
     ].
     
     
     :- pred coloured_coordinate_coords(coloured_coordinate, float, float).
     :- mode coloured_coordinate_coords(in, out, out) is det.
     
     coloured_coordinate_coords(coloured_coordinate(X, Y, _), X, Y).
     
     :- func coloured_coordinate_translate(coloured_coordinate, float, float)
             = coloured_coordinate.
     
     coloured_coordinate_translate(coloured_coordinate(X, Y, Colour), Dx, Dy)
             = coloured_coordinate(X + Dx, Y + Dy, Colour).
</pre>
   <p>If we call &lsquo;<samp><span class="samp">translate/3</span></samp>&rsquo; with the first argument having type
&lsquo;<samp><span class="samp">coloured_coordinate</span></samp>&rsquo;, this will invoke
&lsquo;<samp><span class="samp">coloured_coordinate_translate</span></samp>&rsquo;. 
Likewise, if we call &lsquo;<samp><span class="samp">translate/3</span></samp>&rsquo; with the first argument having type
&lsquo;<samp><span class="samp">coordinate</span></samp>&rsquo;, this will invoke &lsquo;<samp><span class="samp">coordinate_translate</span></samp>&rsquo;.

   <p>Further instances of the type class could be made, e.g. a type that represents
the point using polar coordinates.

<div class="node">
<a name="Abstract-typeclass-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Abstract-instance-declarations">Abstract instance declarations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Instance-declarations">Instance declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-classes">Type classes</a>

</div>

<h3 class="section">10.3 Abstract typeclass declarations</h3>

<p>Abstract typeclass declarations are typeclass declarations whose
definitions are hidden.  An abstract typeclass declaration has the
same form as a typeclass declaration, but without the
&lsquo;<samp><span class="samp">where[...]</span></samp>&rsquo; part.  An abstract typeclass declaration
defines a name for a set of (sequences of) types, but does not define
what methods must be implemented for instances of the type class.

   <p>Like abstract type declarations, abstract typeclass declarations are
only useful in the interface section of a module.  Each abstract
typeclass declaration must be accompanied by a corresponding
non-abstract typeclass declaration that defines the methods for
that type class.

   <p>Non-abstract instance declarations can only be made in scopes where
the non-abstract typeclass declaration is visible.

<div class="node">
<a name="Abstract-instance-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Type-class-constraints-on-predicates-and-functions">Type class constraints on predicates and functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Abstract-typeclass-declarations">Abstract typeclass declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-classes">Type classes</a>

</div>

<h3 class="section">10.4 Abstract instance declarations</h3>

<p>Abstract instance declarations are instance declarations whose
implementations are hidden.  An abstract instance declaration has the
same form as an instance declaration, but without the &lsquo;<samp><span class="samp">where
[...]</span></samp>&rsquo; part.  An abstract instance declaration declares that
a sequence of types is an instance of a particular type class without
defining how the type class methods are implemented for those types. 
Like abstract type declarations,
abstract instance declarations are only useful in the interface
section of a module.  Each abstract instance declaration must
be accompanied by a corresponding non-abstract instance declaration
that defines how the type class methods are implemented.

   <p>Here's an example:

<pre class="example">     :- module hashable.
     :- interface.
     :- import_module int, string.
     
     :- typeclass hashable(T) where [func hash(T) = int].
     :- instance hashable(int).
     :- instance hashable(string).
     
     :- implementation.
     
     :- instance hashable(int) where [func(hash/1) is hash_int].
     :- instance hashable(string) where [func(hash/1) is hash_string].
     
     :- func hash_int(int) = int.
     hash_int(X) = X.
     
     :- func hash_string(string) = int.
     hash_string(S) = H :-
             % use the standard library predicate string.hash/2
             string.hash(S, H).
     
     :- end_module hashable.
</pre>
   <div class="node">
<a name="Type-class-constraints-on-predicates-and-functions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Type-class-constraints-on-type-class-declarations">Type class constraints on type class declarations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Abstract-instance-declarations">Abstract instance declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-classes">Type classes</a>

</div>

<h3 class="section">10.5 Type class constraints on predicates and functions</h3>

<p>Mercury allows a type class constraint to appear as part of a predicate or
function's type signature.  This constrains the values that can be taken
by type variables in the signature to belong to particular type classes.

   <p>A type class constraint has the form:

<pre class="example">             &lt;= <var>Typeclass</var>(<var>Type</var>, ...), ...
</pre>
   <p class="noindent">where <var>Typeclass</var> is the name of a type class and <var>Type</var> is
a type. 
Any variable that appears in <var>Type</var> must be determined by
the predicate's or function's type signature. 
A variable is determined by a type signature if it appears in the
type signature, but if functional dependencies are present
then it may also be determined from other variables
(see <a href="#Functional-dependencies">Functional dependencies</a>). 
Each type class constraint in a predicate or function declaration must contain
at least one variable.

   <p>For example

<pre class="example">     :- pred distance(P1, P2, float) &lt;= (point(P1), point(P2)).
     :- mode distance(in, in, out) is det.
     
     distance(A, B, Distance) :-
             coords(A, Xa, Ya),
             coords(B, Xb, Yb),
             XDist = Xa - Xb,
             YDist = Ya - Yb,
             Distance = sqrt(XDist*XDist + YDist*YDist).
</pre>
   <p>In the above example, the <code>distance</code> predicate is able to calculate the
distance between any two points, regardless of their representation, as long
as the <code>coords</code> operation has been defined.  These
constraints are checked at compile time.

<div class="node">
<a name="Type-class-constraints-on-type-class-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Type-class-constraints-on-instance-declarations">Type class constraints on instance declarations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Type-class-constraints-on-predicates-and-functions">Type class constraints on predicates and functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-classes">Type classes</a>

</div>

<h3 class="section">10.6 Type class constraints on type class declarations</h3>

<p>Type class constraints may also appear in <code>typeclass</code> declarations,
meaning that one type class is a &ldquo;superclass&rdquo; of another.

   <p>The arguments of a constraint on a type class declaration must be either type
variables or ground types. 
Each constraint must contain at least one variable argument and
all variables that appear in the arguments
must also be arguments to the type class in question.

   <p>For example, the following declares the &lsquo;<samp><span class="samp">ring</span></samp>&rsquo; type class, which describes
types with a particular set of numerical operations defined:

<pre class="example">     :- typeclass ring(T) where [
             func zero = (T::out) is det,               % '+' identity
             func one = (T::out) is det,                % '*' identity
             func plus(T::in, T::in) = (T::out) is det, % '+'/2 (forward mode)
             func mult(T::in, T::in) = (T::out) is det, % '*'/2 (forward mode)
             func negative(T::in) = (T::out) is det     % '-'/1 (forward mode)
     ].
</pre>
   <p>We can now add the following declaration:

<pre class="example">     :- typeclass euclidean(T) &lt;= ring(T) where [
             func div(T::in, T::in) = (T::out) is det,
             func mod(T::in, T::in) = (T::out) is det
     ].
</pre>
   <p>This introduces a new type class, <code>euclidean</code>, of which <code>ring</code> is a
superclass.  The operations defined by the <code>euclidean</code> type class are
<code>div</code>, <code>mod</code>, as well as all those defined by the <code>ring</code>
type class.  Any type declared to be an instance of <code>euclidean</code> must also
be declared to be an instance of <code>ring</code>.

   <p>Typeclass constraints on type class declarations gives rise to a superclass
relation.  This relation must be acyclic.  That is, it is an error if a type
class is its own (direct or indirect) superclass.

<div class="node">
<a name="Type-class-constraints-on-instance-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Functional-dependencies">Functional dependencies</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Type-class-constraints-on-type-class-declarations">Type class constraints on type class declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-classes">Type classes</a>

</div>

<h3 class="section">10.7 Type class constraints on instance declarations</h3>

<p>Typeclass constraints may also be placed upon instance declarations. 
The arguments of such constraints must be either type variables or ground
types. 
Each constraint must contain at least one variable argument and all
variables that appear in the arguments
must be type variables that appear in the types in the instance declaration.

   <p>For example, consider the following declaration of a type class of types that
may be printed:

<pre class="example">     :- typeclass portrayable(T) where [
             pred portray(T::in, io.state::di, io.state::uo) is det
     ].
</pre>
   <p>The programmer could declare instances such as

<pre class="example">     :- instance portrayable(int) where [
             pred(portray/3) is io.write_int
     ].
     
     :- instance portrayable(char) where [
             pred(portray/3) is io.write_char
     ].
</pre>
   <p>However, when it comes to writing the instance declaration for a type such as
<code>list(T)</code>, we want to be able print out the list elements using the
<code>portray/3</code> for the particular type of the list elements.  This can be
achieved by placing a type class constraint on the <code>instance</code> declaration,
as in the following example:

<pre class="example">     :- instance portrayable(list(T)) &lt;= portrayable(T) where [
             pred(portray/3) is portray_list
     ].
     
     :- pred portray_list(list(T), io.state, io.state) &lt;= portrayable(T).
     :- mode portray_list(in, di, uo) is det.
     
     portray_list([], !IO).
     portray_list([X | Xs], !IO) :-
     	portray(X, !IO),
     	io.write_char(' ', !IO),
     	portray_list(Xs, !IO).
</pre>
   <p>For abstract instance declarations, the type class constraints on an
abstract instance declaration must exactly match the type class
constraints on the corresponding non-abstract instance declaration that
defines that instance. 
<!-- XXX The current implementation does not enforce that rule. -->

<div class="node">
<a name="Functional-dependencies"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Type-class-constraints-on-instance-declarations">Type class constraints on instance declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-classes">Type classes</a>

</div>

<h3 class="section">10.8 Functional dependencies</h3>

<p>Type class constraints may include any number of functional dependencies. 
A functional dependency constraint takes the form
<code>(</code><var>Domain</var><code> -&gt; </code><var>Range</var><code>)</code>. 
The <var>Domain</var> and <var>Range</var> arguments are either single type variables,
or conjunctions of type variables separated by commas.

<pre class="example">     	:- typeclass <var>Typeclass</var>(<var>Var</var>, ...) &lt;= ((<var>D</var> -&gt; <var>R</var>), ...) ...
     
     	:- typeclass <var>Typeclass</var>(<var>Var</var>, ...) &lt;= (<var>D1</var>, <var>D2</var>, ... -&gt; <var>R1</var>, <var>R2</var>, ...), ...
</pre>
   <p>Each type variable must appear in the parameter list of the typeclass. 
Abstract typeclass declarations must have exactly the same functional
dependencies as in the implementation.

   <p>Mutually recursive functional dependencies are allowed,
so the following examples are legal:

<pre class="example">     	:- typeclass foo(A, B) &lt;= ((A -&gt; B), (B -&gt; A)).
     	:- typeclass bar(A, B, C, D) &lt;= ((A, B -&gt; C), (B, C -&gt; D), (D -&gt; A, C)).
</pre>
   <p>A functional dependency on a typeclass places an additional requirement
on the set of instances which are allowed for that type class. 
The requirement is that all types bound to variables in the range of the
functional dependency must be able to be uniquely determined by the types
bound to variables in the domain of the functional dependency. 
If more than one functional dependency is present,
then the requirement for each one must be satisfied.

   <p>For example, given the typeclass declaration

<pre class="example">     	:- typeclass baz(A, B) &lt;= (A -&gt; B) where ...
</pre>
   <p class="noindent">it would be illegal to have both of the instances

<pre class="example">     	:- instance baz(int, int) where ...
     	:- instance baz(int, string) where ...
</pre>
   <p class="noindent">although either one would be acceptable on its own.

   <p>The following instance would also be illegal

<pre class="example">     	:- instance baz(string, list(T)) where ...
</pre>
   <p class="noindent">since the variable &lsquo;<samp><span class="samp">T</span></samp>&rsquo; may not always be bound to the same type. 
However, the instance

<pre class="example">     	:- instance baz(list(S), list(T)) &lt;= baz(S, T) where ...
</pre>
   <p>is legal because the &lsquo;<samp><span class="samp">baz(S, T)</span></samp>&rsquo; constraint ensures that whatever
&lsquo;<samp><span class="samp">T</span></samp>&rsquo; is bound to, it is always uniquely determined from the binding
of &lsquo;<samp><span class="samp">S</span></samp>&rsquo;.

   <p>The extra requirements that result from the use of functional dependencies
allow the bindings of some variables to be determined from the bindings
of others.  This in turn relaxes some of the requirements of typeclass
constraints on predicate and function signatures,
and on existentially typed data constructors.

   <p>Without any functional dependencies, all variables in constraints must
appear in the signature of the predicate or function being declared. 
However, variables which are in the range of a functional dependency need
not appear in the signature, since it is known that their bindings will
be determined from the bindings of the variables in the domain.

   <p>More formally, the constraints on a predicate or function signature
<em>induce</em> a set of functional dependencies on the variables appearing
in those constraints.  A functional dependency
&lsquo;<samp><span class="samp">(A1, ... -&gt; B1, ...)</span></samp>&rsquo; is induced from a constraint
&lsquo;<samp><var>Typeclass</var><span class="samp">(</span><var>Type1</var><span class="samp">, ...)</span></samp>&rsquo; if and only if the typeclass
&lsquo;<samp><var>Typeclass</var></samp>&rsquo; has a functional dependency
&lsquo;<samp><span class="samp">(D1, ... -&gt; R1, ...)</span></samp>&rsquo;,
and for each typeclass parameter &lsquo;<samp><span class="samp">Di</span></samp>&rsquo; there exists an &lsquo;<samp><span class="samp">Aj</span></samp>&rsquo;
every type variable appearing in the &lsquo;<samp><var>Typek</var></samp>&rsquo;
corresponding to &lsquo;<samp><span class="samp">Di</span></samp>&rsquo;,
and each &lsquo;<samp><span class="samp">Bi</span></samp>&rsquo; appears in the &lsquo;<samp><var>Typej</var></samp>&rsquo; bound to the typeclass
parameter &lsquo;<samp><span class="samp">Rk</span></samp>&rsquo; for some <var>k</var>.

   <p>For example, with the definition of <code>baz</code> above, the constraint
<code>baz(map(X, Y), list(Z))</code> induces the constraint <code>(X, Y -&gt; Z)</code>,
since <var>X</var> and <var>Y</var> appear in the domain argument, and <var>Z</var> appears
in the range argument.

   <p>The set of type variables determined from a signature is
the <em>closure</em> of the set appearing in the signature
under the functional dependencies induced from the constraints. 
The closure is defined as the smallest set of variables which includes
all of the variables appearing in the signature,
and is such that, for each induced functional dependency
&lsquo;<samp><var>Domain</var><span class="samp"> -&gt; </span><var>Range</var></samp>&rsquo;,
if the closure includes all of the variables in <var>Domain</var> then it
includes all of the variables in <var>Range</var>.

   <p>For example, the declaration

<pre class="example">     	:- pred p(X, Y) &lt;= baz(map(X, Y), list(Z)).
</pre>
   <p class="noindent">is acceptable since the closure of {<var>X</var>, <var>Y</var>} under the
induced functional dependency must include <var>Z</var>. 
Moreover, the typeclass <code>baz/2</code> would be allowed to have a method
that only uses the first parameter, <var>A</var>, since the second parameter,
<var>B</var>, would always be determined from the first.

   <p>Note that, since all instances must satisfy the superclass constraints,
the restrictions on instances obviously transfer from superclass to
subclass.  Again, this allows the requirements of typeclass constraints
to be relaxed.  Thus, the functional dependencies on the ancestors
of constraints also induce functional dependencies on the variables,
and the closure that we calculate takes these into account.

   <p>For example, in this code

<pre class="example">     	:- typeclass quux(P, Q, R) &lt;= baz(R, P) where ...
     
     	:- pred q(Q, R) &lt;= quux(P, Q, R).
</pre>
   <p>the signature of <code>q/2</code> is acceptable since the superclass constraint
on <code>quux/2</code> induces the dependency &lsquo;<samp><span class="samp">R -&gt; P</span></samp>&rsquo; on the type variables,
hence <var>P</var> is in the closure of {<var>Q</var>, <var>R</var>}.

   <p>The presence of functional dependencies also allows &ldquo;improvement&rdquo; to
occur during type inference.  This can occur in two ways. 
First, if two constraints of a given class match on all of the domain
arguments of a functional dependency on that class,
then it can be inferred that they also match on the range arguments. 
For example, given the constraints <code>baz(A, B1)</code> and <code>baz(A, B2)</code>,
it will be inferred that <code>B1 = B2</code>.

   <p>Similarly, if a constraint of a given class is subsumed by a known instance
of that class in the domain arguments, then its range arguments can be
unified with the corresponding instance range arguments. 
For example, given the instance:

<pre class="example">     	:- instance baz(list(T), string) where ...
</pre>
   <p class="noindent">then the constraint <code>baz(list(int), X)</code> can be improved with the
inference that <code>X = string</code>.

<div class="node">
<a name="Existential-types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Exception-handling">Exception handling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Type-classes">Type classes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">11 Existential types</h2>

<p>Existentially quantified type variables (or simply &ldquo;existential types&rdquo;
for short) are useful tools for data abstraction.  In combination with
type classes, they allow you to write code in an &ldquo;object oriented&rdquo;
style that is similar to the use of interfaces in Java or abstract
base classes in C++.

   <p>Mercury supports existential type quantifiers on predicate and function
declarations, and in data type definitions.  You can put type class
constraints on existentially quantified type variables.

<ul class="menu">
<li><a accesskey="1" href="#Existentially-typed-predicates-and-functions">Existentially typed predicates and functions</a>
<li><a accesskey="2" href="#Existential-class-constraints">Existential class constraints</a>
<li><a accesskey="3" href="#Existentially-typed-data-types">Existentially typed data types</a>
<li><a accesskey="4" href="#Some-idioms-using-existentially-quantified-types">Some idioms using existentially quantified types</a>
</ul>

<div class="node">
<a name="Existentially-typed-predicates-and-functions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Existential-class-constraints">Existential class constraints</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Existential-types">Existential types</a>

</div>

<h3 class="section">11.1 Existentially typed predicates and functions</h3>

<ul class="menu">
<li><a accesskey="1" href="#Syntax-for-explicit-type-quantifiers">Syntax for explicit type quantifiers</a>
<li><a accesskey="2" href="#Semantics-of-type-quantifiers">Semantics of type quantifiers</a>
<li><a accesskey="3" href="#Examples-of-correct-code-using-type-quantifiers">Examples of correct code using type quantifiers</a>
<li><a accesskey="4" href="#Examples-of-incorrect-code-using-type-quantifiers">Examples of incorrect code using type quantifiers</a>
</ul>

<div class="node">
<a name="Syntax-for-explicit-type-quantifiers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Semantics-of-type-quantifiers">Semantics of type quantifiers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Existentially-typed-predicates-and-functions">Existentially typed predicates and functions</a>

</div>

<h4 class="subsection">11.1.1 Syntax for explicit type quantifiers</h4>

<p>Type variables in type declarations for polymorphic predicates or functions
are normally universally quantified. 
However, it is also possible to existentially quantify such
type variables, by using an explicit existential quantifier of
the form &lsquo;<samp><span class="samp">some </span><var>Vars</var></samp>&rsquo; before the &lsquo;<samp><span class="samp">pred</span></samp>&rsquo; or &lsquo;<samp><span class="samp">func</span></samp>&rsquo;
declaration, where <var>Vars</var> is a list of variables.

   <p>For example:

<pre class="example">     % Here the type variables `T' is existentially quantified
     :- some [T] pred foo(T).
     
     % Here the type variables `T1' and `T2' are existentially quantified.
     :- some [T1, T2] func bar(int, list(T1), set(T2)) = pair(T1, T2).
     
     % Here the type variable `T2' is existentially quantified,
     % but the type variables `T1' and `T3' are universally quantified.
     :- some [T2] pred foo(T1, T2, T3).
</pre>
   <p>Explicit universal quantifiers, of the form &lsquo;<samp><span class="samp">all </span><var>Vars</var></samp>&rsquo;,
are also permitted on &lsquo;<samp><span class="samp">pred</span></samp>&rsquo; and &lsquo;<samp><span class="samp">func</span></samp>&rsquo; declarations,
although they are not necessary, since universal quantification is
the default.  (If both universal and existential quantifiers
are present, the universal quantifiers must precede the existential
quantifiers.)  For example:

<pre class="example">     % Here the type variable `T2' is existentially quantified,
     % but the type variables `T1' and `T3' are universally quantified.
     :- all [T3] some [T2] pred foo(T1, T2, T3).
</pre>
   <div class="node">
<a name="Semantics-of-type-quantifiers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Examples-of-correct-code-using-type-quantifiers">Examples of correct code using type quantifiers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Syntax-for-explicit-type-quantifiers">Syntax for explicit type quantifiers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Existentially-typed-predicates-and-functions">Existentially typed predicates and functions</a>

</div>

<h4 class="subsection">11.1.2 Semantics of type quantifiers</h4>

<p>If a type variable in the type declaration for a polymorphic predicate
or function is universally quantified, this means the caller will
determine the value of the type variable, and the callee must be defined
so that it will work for <em>all</em> types which are an instance of its
declared type.

   <p>For an existentially quantified type variable, the situation is the
converse: the <em>callee</em> must determine the value of the type variable,
and all <em>callers</em> must be defined so as to work for all types
which are an instance of the called procedure's declared type.

   <p>When type checking a predicate or function, if a variable has a type
that occurs as a universally quantified type variable in the predicate
or function declaration, or a type that occurs as an existentially
quantified type variable in the declaration of one of the predicates
or functions that it calls, then its type is treated as an opaque type. 
This means that there are very few things which it is legal to do with
such a variable &mdash; basically you can only pass it to another procedure
expecting the same type, unify it with another value of the same
type, put it in a polymorphic data structure, or pass it to a
polymorphic procedure whose argument type is universally quantified. 
(Note, however, that the standard library includes some quite powerful
procedures such as &lsquo;<samp><span class="samp">io.write</span></samp>&rsquo; which can be useful in this context.)

   <p>A non-variable type (i.e. a type that is not a type variable)
is considered <em>more general</em> than an
existentially quantified type variable.  Type inference will therefore
never infer an existentially quantified type for a predicate or
function unless that predicate or function calls (directly or indirectly)
a predicate or function which was explicitly declared to have an
existentially quantified type.

   <p>Note that an existentially typed procedure is not allowed to have
different types for its existentially typed arguments in different clauses
(even mode-specific clauses) or in different subgoals of a single clause;
however, the same effect can be achieved in other ways
(see <a href="#Some-idioms-using-existentially-quantified-types">Some idioms using existentially quantified types</a>).

   <p>For procedures involving calls to existentially-typed predicates or functions,
the compiler's mode analysis must take account of the modes for type
variables in all polymorphic calls. 
Universally quantified type variables have mode &lsquo;<samp><span class="samp">in</span></samp>&rsquo;,
whereas existentially quantified type variables have mode &lsquo;<samp><span class="samp">out</span></samp>&rsquo;. 
As usual, the compiler's mode analysis will attempt to reorder the
elements of conjunctions in order to satisfy the modes.

<div class="node">
<a name="Examples-of-correct-code-using-type-quantifiers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Examples-of-incorrect-code-using-type-quantifiers">Examples of incorrect code using type quantifiers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Semantics-of-type-quantifiers">Semantics of type quantifiers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Existentially-typed-predicates-and-functions">Existentially typed predicates and functions</a>

</div>

<h4 class="subsection">11.1.3 Examples of correct code using type quantifiers</h4>

<p>Here are some examples of type-correct code using universal and
existential types.

<pre class="example">     /* simple examples */
     
     :- pred foo(T).
     foo(_).
     	% ok
     
     :- pred call_foo.
     call_foo :- foo(42).
     	% ok (T = int)
     
     :- some [T] pred e_foo(T).
     e_foo(X) :- X = 42.
     	% ok (T = int)
     
     :- pred call_e_foo.
     call_e_foo :- e_foo(_).
     	% ok
     
     /* examples using higher-order functions */
     
     :- func bar(T, T, func(T) = int) = int.
     bar(X, Y, F) = F(X) + F(Y).
     	% ok
     
     :- func call_bar = int.
     call_bar = bar(2, 3, (func(X) = X*X)).
     	% ok (T = int)
     	% returns 13 (= 2*2 + 3*3)
     
     :- some [T] pred e_bar(T, T, func(T) = int).
     :-          mode e_bar(out, out, out(func(in) = out is det)).
     e_bar(2, 3, (func(X) = X * X)).
     	% ok (T = int)
     
     :- func call_e_bar = int.
     call_e_bar = F(X) + F(Y) :- e_bar(X, Y, F).
     	% ok
     	% returns 13 (= 2*2 + 3*3)
     
</pre>
   <div class="node">
<a name="Examples-of-incorrect-code-using-type-quantifiers"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Examples-of-correct-code-using-type-quantifiers">Examples of correct code using type quantifiers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Existentially-typed-predicates-and-functions">Existentially typed predicates and functions</a>

</div>

<h4 class="subsection">11.1.4 Examples of incorrect code using type quantifiers</h4>

<p>Here are some examples of code using universal and
existential types that contains type errors.

<pre class="example">     /* simple examples */
     
     :- pred bad_foo(T).
     bad_foo(42).
     	% type error
     
     :- some [T] pred e_foo(T).
     e_foo(42).
     	% ok
     
     :- pred bad_call_e_foo.
     bad_call_e_foo :- e_foo(42).
     	% type error
     
     :- some [T] pred e_bar1(T).
     e_bar1(42).
     e_bar1(42).
     e_bar1(43).
     	% ok (T = int)
     
     :- some [T] pred bad_e_bar2(T).
     bad_e_bar2(42).
     bad_e_bar2("blah").
     	% type error (cannot unify types `int' and `string')
     
     :- some [T] pred bad_e_bar3(T).
     bad_e_bar3(X) :- e_foo(X).
     bad_e_bar3(X) :- e_foo(X).
     	% type error (attempt to bind type variable `T' twice)
     
</pre>
   <div class="node">
<a name="Existential-class-constraints"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Existentially-typed-data-types">Existentially typed data types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Existentially-typed-predicates-and-functions">Existentially typed predicates and functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Existential-types">Existential types</a>

</div>

<h3 class="section">11.2 Existential class constraints</h3>

<p>Existentially quantified type variables are especially useful in
combination with type class constraints.

   <p>Type class constraints can be either universal or existential. 
Universal type class constraints are written using &lsquo;<samp><span class="samp">&lt;=</span></samp>&rsquo;,
as described in <a href="#Type-class-constraints-on-predicates-and-functions">Type class constraints on predicates and functions</a>;
they signify a constraint that the <em>caller</em> must satisfy. 
Existential type class constraints are written in the same syntax
as universal constraints, but using &lsquo;<samp><span class="samp">=&gt;</span></samp>&rsquo; instead of &lsquo;<samp><span class="samp">&lt;=</span></samp>&rsquo;;
they signify a constraint that the <em>callee</em> must satisfy. 
(If a declaration has both universal and existential constraints,
then the existential constraints must precede the universal constraints.)

   <p>For example:

<pre class="example">     % Here `c1(T2)' and `c2(T2)' are existential constraints,
     % and `c3(T1)' is a universal constraint,
     :- all [T1] some [T2] ((pred p(T1, T2) =&gt; (c1(T2), c2(T2))) &lt;= c3(T1)).
</pre>
   <p>Existential constraints must only constrain type variables
that are explicitly existentially quantified. 
Likewise, universal constraints must only constrain type variables
that are universally quantified,
although in this case the quantification does not have to be explicit
because universal quantification is the default
(see <a href="#Syntax-for-explicit-type-quantifiers">Syntax for explicit type quantifiers</a>).

<div class="node">
<a name="Existentially-typed-data-types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Some-idioms-using-existentially-quantified-types">Some idioms using existentially quantified types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Existential-class-constraints">Existential class constraints</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Existential-types">Existential types</a>

</div>

<h3 class="section">11.3 Existentially typed data types</h3>

<p>Type variables occurring in the body of a discriminated union type
definition may be existentially quantified.  Constructor definitions
within discriminated union type definitions may be preceded by
an existential type quantifier and followed by one or more existential
type class constraints.

   <p>For example:

<pre class="example">     % A simple heterogeneous list type
     :- type list_of_any
     	---&gt; nil_any
     	;    some [T] cons_any(T, list_of_any).
     
     % A heterogeneous list type with a type class constraint
     :- typeclass showable(T) where [ func show(T) = string ].
     :- type showable_list
     	---&gt; nil
     	;    some [T] (cons(T, showable_list) =&gt; showable(T)).
     
     % A different way of doing the same kind of thing, this
     % time using the standard type list(T).
     :- type showable ---&gt; some [T] (s(T) =&gt; showable(T)).
     :- type list_of_showable == list(showable).
     
     % Here's an arbitrary example involving multiple
     % type variables and multiple constraints
     :- typeclass foo(T1, T2) where [ /* ... */ ].
     :- type bar(T)
     	---&gt; f1
     	;    f2(T)
     	;    some [T]
     	     f4(T)
     	;    some [T1, T2]
     	     (f4(T1, T2, T) =&gt; showable(T1), showable(T2))
     	;    some [T1, T2]
     	     (f5(list(T1), T2) =&gt; fooable(T1, list(T2)))
     	.
</pre>
   <p>Construction and deconstruction of existentially quantified data types
are inverses: when constructing a value of an existentially quantified
data type, the &ldquo;existentially quantified&rdquo; functor acts for purposes
of type checking like a universally quantified function: the caller
will determine the values of the type variables. 
Conversely, for deconstruction the functor acts like an
existentially quantified function: the caller must be defined so
as to work for all possible values of the existentially quantified
type variables which satisfy the declared type class constraints.

   <p>In order to make this distinction clear to the compiler,
whenever you want to construct a value using an existentially
quantified functor, you must prepend &lsquo;<samp><span class="samp">new </span></samp>&rsquo; onto the functor name. 
This tells the compiler to treat it as though it were universally
quantified: the caller can bind that functor's existentially quantified
type variables to any type which satisfies the declared type class
constraints.  Conversely, any occurrence without the &lsquo;<samp><span class="samp">new </span></samp>&rsquo; prefix
must be a deconstruction, and is therefore existentially quantified:
the caller must not bind the existentially quantified type variables,
but the caller is allowed to depend on those type variables satisfying
the declared type class constraints, if any.

   <p>For example, the function &lsquo;<samp><span class="samp">make_list</span></samp>&rsquo; constructs a value of type
&lsquo;<samp><span class="samp">list_of_showable</span></samp>&rsquo; containing a sequence of values of different types,
all of which are instances of the &lsquo;<samp><span class="samp">showable</span></samp>&rsquo; class

<pre class="example">     :- instance showable(int).
     :- instance showable(float).
     :- instance showable(string).
     
     :- func make_list = showable_list.
     make_list = List :-
     	Int = 42,
     	Float = 1.0,
     	String = "blah",
     	List =  'new cons'(Int,
     		'new cons'(Float,
     		'new cons'(String, nil))).
</pre>
   <p class="noindent">while the function &lsquo;<samp><span class="samp">process_list</span></samp>&rsquo; below applies the &lsquo;<samp><span class="samp">show</span></samp>&rsquo;
method of the &lsquo;<samp><span class="samp">showable</span></samp>&rsquo; class to the values in such a list.

<pre class="example">     :- func process_list(list_of_showable) = list(string).
     process_list(nil) = "".
     process_list(cons(Head, Tail)) = [show(Head) | process_list(Tail)].
</pre>
   <div class="node">
<a name="Some-idioms-using-existentially-quantified-types"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Existentially-typed-data-types">Existentially typed data types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Existential-types">Existential types</a>

</div>

<h3 class="section">11.4 Some idioms using existentially quantified types</h3>

<p>The standard library module &lsquo;<samp><span class="samp">univ</span></samp>&rsquo; provides an abstract
type named &lsquo;<samp><span class="samp">univ</span></samp>&rsquo; which can hold values of any type. 
You can form heterogeneous containers (containers that can hold values of
different types at the same time) by using data structures
that contain <code>univ</code>s, e.g. &lsquo;<samp><span class="samp">list(univ)</span></samp>&rsquo;.

   <p>The interface to &lsquo;<samp><span class="samp">univ</span></samp>&rsquo; includes the following:

<pre class="example">     % `univ' is a type which can hold any value.
     :- type univ.
     
     % The function univ/1 takes a value of any type and constructs
     % a `univ' containing that value (the type will be stored along
     % with the value)
     :- func univ(T) = univ.
     
     % The function univ_value/1 takes a `univ' argument and extracts
     % the value contained in the `univ' (together with its type).
     % This is the inverse of the function univ/1.
     :- some [T] func univ_value(univ) = T.
</pre>
   <p>The &lsquo;<samp><span class="samp">univ</span></samp>&rsquo; type in the standard library is in fact a simple
example of an existentially typed data type.  It could be implemented
as follows:

<pre class="example">     :- implementation.
     :- type univ ---&gt; some [T] mkuniv(T).
     univ(X) = 'new mkuniv'(X).
     univ_value(mkuniv(X)) = X.
</pre>
   <p>An existentially typed procedure is not allowed to have different
types for its existentially typed arguments in different clauses
or in different subgoals of a single clause.  For instance, both
of the following examples are illegal:

<pre class="example">     :- some [T] pred bad_example(string, T).
     bad_example("foo", 42).
     bad_example("bar", "blah").
     	% type error (cannot unify `int' and `string')
     
     :- some [T] pred bad_example2(string, T).
     bad_example2(Name, Value) :-
     	( Name = "foo", Value = 42
     	; Name = "bar", Value = "blah"
     	).
     	% type error (cannot unify `int' and `string')
</pre>
   <p>However, using &lsquo;<samp><span class="samp">univ</span></samp>&rsquo;,
it is possible for an existentially typed function to return
values of different types at each invocation.

<pre class="example">     :- some [T] pred good_example(string, T).
     good_example(Name, univ_value(Univ)) :-
     	( Name = "foo", Univ = univ(42)
     	; Name = "bar", Univ = univ("blah")
     	).
</pre>
   <p>Using &lsquo;<samp><span class="samp">univ</span></samp>&rsquo; doesn't work if you also want to use type class constraints. 
If you want to use type class constraints, then you must define your own
existentially typed data type, analogous to &lsquo;<samp><span class="samp">univ</span></samp>&rsquo;, and use that:

<pre class="example">     :- type univ_showable ---&gt; some [T] (mkshowable(T) =&gt; showable(T)).
     
     :- some [T] pred harder_example(string, T) =&gt; showable(T).
     harder_example(Name, Showable) :-
     	( Name = "bar", Univ = 'new mkshowable'(42)
     	; Name = "bar", Univ = 'new mkshowable'("blah")
     	),
     	Univ = mkshowable(Showable).
</pre>
   <p>The issue can also arise for mode-specific clauses
(see <a href="#Different-clauses-for-different-modes">Different clauses for different modes</a>). 
For instance, the following example is illegal:

<pre class="example">     :- some [T] pred bad_example3(string, T).
     :-          mode bad_example3(in(bound("foo")), out) is det.
     :-          mode bad_example3(in(bound("bar")), out) is det.
     :- pragma promise_pure(bad_example3/2).
     bad_example3("foo"::in(bound("foo")), 42::out).
     bad_example3("bar"::in(bound("bar")), "blah"::out).
     	% type error (cannot unify `int' and `string')
</pre>
   <p>The solution is similar, although in this case an intermediate
predicate is required:

<pre class="example">     :- some [T] pred good_example3(string, T).
     :-          mode good_example3(in(bound("foo")), out) is det.
     :-          mode good_example3(in(bound("bar")), out) is det.
     good_example3(Name, univ_value(Univ)) :-
     	good_example3_univ(Name, Univ).
     
     :- pred good_example3_univ(string, univ).
     :- mode good_example3_univ(in(bound("foo")), out) is det.
     :- mode good_example3_univ(in(bound("bar")), out) is det.
     :- pragma promise_pure(good_example3_univ/2).
     good_example3_univ("foo"::in(bound("foo")), univ(42)::out).
     good_example3_univ("bar"::in(bound("bar")), univ("blah")::out).
</pre>
   <div class="node">
<a name="Exception-handling"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Semantics">Semantics</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Existential-types">Existential types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">12 Exception handling</h2>

<p>Mercury procedures may throw exceptions.  Exceptions may be caught using
the predicates defined in the &lsquo;<samp><span class="samp">exception</span></samp>&rsquo; library module,
or using try goals.

<p class="noindent">A &lsquo;<samp><span class="samp">try</span></samp>&rsquo; goal has the following form:

<pre class="example">             try <var>Params</var> <var>Goal</var>
             then <var>ThenGoal</var>
             else <var>ElseGoal</var>
             catch <var>Term</var> -&gt; <var>CatchGoal</var>
             ...
             catch_any <var>CatchAnyVar</var> -&gt; <var>CatchAnyGoal</var>
</pre>
   <p><var>Goal</var>, <var>ThenGoal</var>, <var>ElseGoal</var>, <var>CatchGoal</var>,
<var>CatchAnyGoal</var> must be valid goals.

   <p><var>Goal</var> must have one of the following determinisms: &lsquo;<samp><span class="samp">det</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">semidet</span></samp>&rsquo;, &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">cc_nondet</span></samp>&rsquo;.

   <p>The non-local variables of <var>Goal</var> must not have an inst equivalent to
&lsquo;<samp><span class="samp">unique</span></samp>&rsquo; or &lsquo;<samp><span class="samp">mostly_unique</span></samp>&rsquo; or &lsquo;<samp><span class="samp">any</span></samp>&rsquo;, unless they have the
type &lsquo;<samp><span class="samp">io.state</span></samp>&rsquo;. 
<!-- or (later) the store/1.) -->

   <p><var>Params</var> must be a valid list of zero or more try parameters.

   <p>The &ldquo;then&rdquo; part is mandatory. 
The &ldquo;else&rdquo; part is mandatory if <var>Goal</var> may fail; otherwise it
must be omitted. 
There may be zero or more &ldquo;catch&rdquo; branches. 
The &ldquo;catch_any&rdquo; part is optional.  <var>CatchAnyVar</var> must be a single
variable.

   <p>The try parameter &lsquo;<samp><span class="samp">io</span></samp>&rsquo; takes a single argument, which must be the name
of a state variable prefixed by &lsquo;<samp><span class="samp">!</span></samp>&rsquo;; for example, &lsquo;<samp><span class="samp">io(!IO)</span></samp>&rsquo;. 
The state variable must have the type &lsquo;<samp><span class="samp">io.state</span></samp>&rsquo;, and be in scope
of the try goal.  The state variable is threaded through &lsquo;<samp><span class="samp">Goal</span></samp>&rsquo;,
so it may perform I/O but cannot fail. 
If no &lsquo;<samp><span class="samp">io</span></samp>&rsquo; parameter exists, &lsquo;<samp><span class="samp">Goal</span></samp>&rsquo; may not perform I/O and may
fail.

   <p>A try goal has determinism &lsquo;<samp><span class="samp">cc_multi</span></samp>&rsquo;. 
<!-- Exception: if all of the then/else/catch/catch_any parts only succeed -->
<!-- without binding non-local variables then the determinism is det. -->
<!-- In the implementation we may still infer cc_multi though. -->

   <p>On entering a try goal, <var>Goal</var> is executed.  If it succeeds
without throwing an exception, <var>ThenGoal</var> is executed. 
Any variables bound by <var>Goal</var> are visible in <var>ThenGoal</var> only. 
If <var>Goal</var> fails, then <var>ElseGoal</var> is executed.

   <p>If <var>Goal</var> throws an exception, the exception value is unified
with each of the <var>Term</var>s in the &ldquo;catch&rdquo; branches in turn. 
On the first successful unification, the corresponding <var>CatchGoal</var> is
executed (and other &ldquo;catch&rdquo; and &ldquo;catch_any&rdquo; branches ignored). 
Variables bound during the unification of the <var>Term</var> are in scope
of the corresponding <var>CatchGoal</var>.

   <p>If the exception value does not unify with any of the terms in &ldquo;catch&rdquo;
branches, and a &ldquo;catch_any&rdquo; branch is present, the exception is bound
to <var>CatchAnyVar</var> and the <var>CatchAnyGoal</var> executed. 
<var>CatchAnyVar</var> is visible in the <var>CatchAnyGoal</var> only, and
is existentially typed, i.e. it has type &lsquo;<samp><span class="samp">some [T] T</span></samp>&rsquo;.

   <p>Finally, if the thrown value did not unify with any &ldquo;catch&rdquo; term,
and there is no &ldquo;catch_any&rdquo; branch, the exception is rethrown.

<p class="noindent">The declarative semantics of a try goal is:

<pre class="example">             (try [] Goal
              then Then
              else Else
              catch CP1 -&gt; CG1
              catch CG2 -&gt; CG2
              ...
              catch_any CAV -&gt; CAG
             )  &lt;=&gt;
                     (
                             Goal, Then
                     ;
                             not Goal, Else
                     ;
                             some [Excp]
                             ( Excp = CP1 -&gt; CG1
                             ; Excp = CP2 -&gt; CG2
                             ; ...
                             ; Excp = CAV, CAG
                             )
                     ).
</pre>
   <p>If no &lsquo;<samp><span class="samp">else</span></samp>&rsquo; branch is present, let &lsquo;<samp><span class="samp">Else = fail</span></samp>&rsquo;. 
If no &lsquo;<samp><span class="samp">catch_any</span></samp>&rsquo; branch is present, let &lsquo;<samp><span class="samp">CAG = fail</span></samp>&rsquo;.

<p class="noindent">An example of a try goal that performs I/O is:

<pre class="example">     :- pred p_carefully(io::di, io::uo) is cc_multi.
     
     p_carefully(!IO) :-
             (try [io(!IO)] (
                     io.write_string("Calling p\n", !IO),
                     p(Output, !IO)
             )
             then
                     io.write_string("p returned: ", !IO),
                     io.write(Output, !IO),
                     io.nl(!IO)
             catch S -&gt;
                     io.write_string("p threw a string: ", !IO),
                     io.write_string(S, !IO),
                     io.nl(!IO)
             catch 42 -&gt;
                     io.write_string("p threw 42\n", !IO)
             catch_any Other -&gt;
                     io.write_string("p threw something: ", !IO),
                     io.write(Other, !IO),
                     % Rethrow the value.
                     throw(Other)
             ).
</pre>
   <div class="node">
<a name="Semantics"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Foreign-language-interface">Foreign language interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Exception-handling">Exception handling</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">13 Semantics</h2>

<p>A legal Mercury program is one that complies with the syntax,
type, mode, determinism, and module system rules specified in earlier chapters. 
If a program does not comply with those rules,
the compiler must report an error.

   <p>For each legal Mercury program,
there is an associated predicate calculus theory
whose language is specified by the type declarations in the program
and whose axioms are the completion of the clauses for all predicates
in the program,
plus the usual equality axioms extended with the completion of the
equations for all functions in the program,
plus axioms corresponding to the mode-determinism assertions
(see <a href="#Determinism">Determinism</a>),
plus axioms specifying the semantics of library predicates and functions. 
The declarative semantics of a legal Mercury program
is specified by this theory.

   <p>Mercury implementations must be sound:
the answers they compute must be true in every model of the theory. 
Mercury implementations are not required to be complete:
they may fail to compute an answer in finite time,
or they may exhaust the resource limitations of the execution
environment, even though an answer is provable in the theory. 
However, there are certain minimum requirements that they
must satisfy with respect to completeness.

   <p>There is an operational semantics of Mercury programs called the
<dfn>strict sequential</dfn> operational semantics.  In this semantics,
the program is executed top-down, starting from &lsquo;<samp><span class="samp">main/2</span></samp>&rsquo;
preceded by any module initialisation goals
(as per <a href="#Module-initialisation">Module initialisation</a>), followed by any module finalisation
goals (as per <a href="#Module-finalisation">Module finalisation</a>),
and function calls within a goal, conjunctions and disjunctions are all
executed in depth-first left-to-right order. 
Conjunctions and function calls are &ldquo;minimally&rdquo; reordered as required
by the modes:
the order is determined by selecting the first mode-correct sub-goal
(conjunct or function call),
executing that, then selecting the first of the remaining sub-goals
which is now mode-correct, executing that, and so on. 
(There is no interleaving of different individual conjuncts or function calls,
however; the sub-goals are reordered, not split and interleaved.) 
Function application is strict, not lazy. 
<!-- XXX should document the operational semantics of switches and if-then-elses -->

   <p>Mercury implementations are required to provide a method of processing
Mercury programs which is equivalent to the strict sequential
operational semantics.

   <p>There is another operational semantics of Mercury programs called
the <dfn>strict commutative</dfn> operational semantics.  This semantics
is equivalent to the strict sequential operational semantics except
that there is no requirement that function calls, conjunctions and disjunctions
be executed left-to-right; they may be executed in any order, and may
even be interleaved.  Furthermore, the order may even be different each
time a particular goal is entered.

   <p>As well as providing the strict sequential operational semantics,
Mercury implementations may optionally provide additional
implementation-defined operational semantics, provided that
any such implementation-defined operational semantics are
at least as complete as the strict commutative operational
semantics.  An implementation-defined semantics
is &ldquo;at least as complete&rdquo; as the strict commutative
semantics if and only if the implementation-defined
semantics guarantees to compute an answer in finite time for
any program for which an answer would be computed in finite time for all
possible executions under the strict commutative semantics
(i.e. for all possible orderings of conjunctions and disjunctions).

   <p>Thus, to summarize, there are in fact a variety of different operational
semantics for Mercury.  In one of them, the strict sequential semantics, there
is no nondeterminism &mdash; the behaviour is always specified exactly. 
Programs are executed top-down using SLDNF (or something equivalent),
mode analysis does &ldquo;minimal&rdquo; reordering (in a precisely defined sense),
function calls, conjunctions and disjunctions are executed depth-first
left-to-right, and function evaluation is strict.  All implementations
are required to support the strict sequential semantics, so that a
program which works on one implementation using this semantics will be
guaranteed to work on any other implementation.  However,
implementations are also allowed to support other operational
semantics, which may have non-determinism, so long as they are sound
with respect to the declarative semantics, and so long as they meet a
minimum level of completeness (they must be at least as complete as the
strict commutative semantics, in the sense that every program which
terminates for all possible orderings must also terminate in any
implementation-defined operational semantics).

   <p>This compromise allows Mercury to be used in several different ways. 
Programmers who care more about ease of programming and portability
than about efficiency can use the strict sequential semantics, and
can then be guaranteed that if their program works on one correct
implementation, it will work on all correct implementations.  Compiler
implementors who want to write optimizing implementations that do lots
of clever code reorderings and other high-level transformations or that
want to offer parallelizing implementations which take maximum
advantage of parallelism can define different semantic models. 
Programmers who care about efficiency more than portability can write
code for these implementation-defined semantic models.  Programmers who
care about efficiency <em>and</em> portability can achieve this by writing
code for the strict commutative semantics. 
Of course, this is not
quite as easy as using the strict sequential semantics, since it is
in general not sufficient to test your programs on just one
implementation if you are to be sure that it will be able to use the
maximally efficient operational semantics on any implementation. 
However, if you do write code which works for all possible executions
under the strict commutative semantics (i.e. for all possible orderings of
conjunctions and disjunctions), then you can be guaranteed that it
will work correctly on every implementation, under every possible
implementation-defined semantics.

   <p>The University of Melbourne Mercury implementation offers eight
different semantics, which can be selected with different
combinations of the &lsquo;<samp><span class="samp">--no-reorder-conj</span></samp>&rsquo;, &lsquo;<samp><span class="samp">--no-reorder-disj</span></samp>&rsquo;,
and &lsquo;<samp><span class="samp">--no-fully-strict</span></samp>&rsquo; options. 
(The &lsquo;<samp><span class="samp">--no-fully-strict</span></samp>&rsquo; option allows the compiler to improve
completeness by optimizing away infinite loops and goals with determinism
<code>erroneous</code>.) 
The default semantics are the strict commutative semantics. 
Enabling &lsquo;<samp><span class="samp">--no-reorder-conj</span></samp>&rsquo; and &lsquo;<samp><span class="samp">--no-reorder-disj</span></samp>&rsquo; gives the
strict sequential semantics.

   <p>Future implementations of Mercury may wish to offer other operational semantics. 
For example, they may wish to provide semantics in which function
evaluation is lazy, rather than strict; semantics with a guaranteed
fair search rule; and so forth.

<div class="node">
<a name="Foreign-language-interface"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Impurity">Impurity</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Semantics">Semantics</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">14 Foreign language interface</h2>

<ul class="menu">
<li><a accesskey="1" href="#Calling-foreign-code-from-Mercury">Calling foreign code from Mercury</a>:   How to implement a Mercury predicate
				       or function as a call to code
				       written in a different
				       programming language. 
<li><a accesskey="2" href="#Calling-Mercury-from-foreign-code">Calling Mercury from foreign code</a>:   How to call a Mercury predicate
                                       or function from a different
                                       programming language. 
<li><a accesskey="3" href="#Using-foreign-types-from-Mercury">Using foreign types from Mercury</a>:    How to use a type defined in
				       a different programming language
				       in Mercury code. 
<li><a accesskey="4" href="#Using-Mercury-enumerations-in-foreign-code">Using Mercury enumerations in foreign code</a>:  How to use an enumeration type
                                               defined in Mercury in a
                                               different programming language. 
<li><a accesskey="5" href="#Using-foreign-enumerations-in-Mercury-code">Using foreign enumerations in Mercury code</a>:  How to use an enumeration type
                                                defined in a foreign language
                                                in Mercury code. 
<li><a accesskey="6" href="#Data-passing-conventions">Data passing conventions</a>: 	       How Mercury types are passed to
				       different languages. 
<li><a accesskey="7" href="#Adding-foreign-declarations">Adding foreign declarations</a>:         How to add declarations of
  				       entities in other programming
				       languages. 
<li><a accesskey="8" href="#Adding-foreign-definitions">Adding foreign definitions</a>:          How to add definitions of
  				       entities in other programming
				       languages. 
<li><a accesskey="9" href="#Language-specific-bindings">Language specific bindings</a>:          Information specific to each
  				       foreign language.

</ul>

   <p>This chapter documents the foreign language interface.

<div class="node">
<a name="Calling-foreign-code-from-Mercury"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Calling-Mercury-from-foreign-code">Calling Mercury from foreign code</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-language-interface">Foreign language interface</a>

</div>

<h3 class="section">14.1 Calling foreign code from Mercury</h3>

<p>Mercury procedures can be implemented using fragments of foreign language
code using &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo;.

<ul class="menu">
<li><a accesskey="1" href="#pragma-foreign_005fproc">pragma foreign_proc</a>:          Defining Mercury procedures using foreign code. 
<li><a accesskey="2" href="#Foreign-code-attributes">Foreign code attributes</a>:    	Describing properties of foreign
				functions or code. 
</ul>

<div class="node">
<a name="pragma-foreign_proc"></a>
<a name="pragma-foreign_005fproc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Foreign-code-attributes">Foreign code attributes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Calling-foreign-code-from-Mercury">Calling foreign code from Mercury</a>

</div>

<h4 class="subsection">14.1.1 pragma foreign_proc</h4>

<p>A declaration of the form

<pre class="example">     :- pragma foreign_proc("<var>Lang</var>", <var>Pred</var>(<var>Var1</var>::<var>Mode1</var>, <var>Var2</var>::<var>Mode2</var>, ...),
             <var>Attributes</var>, <var>Foreign_Code</var>).
</pre>
   <p class="noindent">or

<pre class="example">     :- pragma foreign_proc("<var>Lang</var>", <var>Func</var>(<var>Var1</var>::<var>Mode1</var>, <var>Var2</var>::<var>Mode2</var>, ...) = (<var>Var</var>::<var>Mode</var>),
             <var>Attributes</var>, <var>Foreign_Code</var>).
</pre>
   <p class="noindent">means that any calls to the specified mode of <var>Pred</var> or <var>Func</var>
will result in execution of the foreign code given in <var>Foreign_Code</var>
written in language <var>Lang</var>, if <var>Lang</var> is selected as the foreign
language code by this implementation. 
See the &ldquo;Foreign Language Interface&rdquo; chapter of the
Mercury User's Guide, for more information about how the implementation
selects the appropriate &lsquo;<samp><span class="samp">foreign_proc</span></samp>&rsquo; to use.

   <p>The foreign code fragment may refer to the specified variables
(<var>Var1</var>, <var>Var2</var>, <small class="dots">...</small>, and <var>Var</var>)
directly by name. 
It is an error for a variable to occur more than once in the argument list. 
These variables will have foreign language types
corresponding to their Mercury types, as determined by language and
implementation specific rules.

   <p>All &lsquo;<samp><span class="samp">foreign_proc</span></samp>&rsquo; implementations are assumed to be impure. 
If they are actually pure or semipure, they must be explicitly
promised as such by the user (either by using foreign language
attributes specified below, or a promise_pure or promise_semipure pragma
as specified in <a href="#Impurity">Impurity</a>).

   <p>Additional restrictions on the foreign language interface code
depend on the foreign language and compilation options. 
For more information, including the list of supported foreign languages and
the strings used to identify them, see the language specific information
in the &ldquo;Foreign Language Interface&rdquo; chapter of the
Mercury User's Guide.

   <p>If there is a <code>pragma foreign_proc</code> declaration for any
mode of a predicate or function, then there must be either a
clause or a <code>pragma foreign_proc</code>
declaration for every mode of that predicate or function.

   <p>Here's an example of code using &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo;:
The following code defines a Mercury function
&lsquo;<samp><span class="samp">sin/1</span></samp>&rsquo; which calls the C function &lsquo;<samp><span class="samp">sin()</span></samp>&rsquo; of the same name.

<pre class="example">     :- func sin(float) = float.
     :- pragma foreign_proc("C", sin(X::in) = (Sin::out),
             [may_call_mercury],
             "Sin = sin(X);").
</pre>
   <p>If the foreign language code does not recursively invoke Mercury code,
as in the above example, then you can use &lsquo;<samp><span class="samp">will_not_call_mercury</span></samp>&rsquo;
in place of &lsquo;<samp><span class="samp">may_call_mercury</span></samp>&rsquo; in the declarations above. 
This allows the compiler to use a slightly more efficient calling convention. 
(If you use this form, and the foreign code <em>does</em> invoke Mercury code,
then the behaviour is undefined &mdash; your program may misbehave or crash.)

   <p>If there are both Mercury definitions and foreign_proc definitions for
a procedure and/or foreign_proc definitions for different languages,
it is implementation defined which definition is used.

   <p>For pure and semipure procedures, the declarative semantics of the foreign_proc
definitions must be the same as that of the Mercury code. 
The only thing that is allowed to differ is the efficiency (including the
possibility of non-termination) and the order of solutions.

   <p>It is an error for a procedure with a &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; declaration to
have a determinism of &lsquo;<samp><span class="samp">multi</span></samp>&rsquo; or &lsquo;<samp><span class="samp">nondet</span></samp>&rsquo;.

   <p>Since foreign_procs with the determinism &lsquo;<samp><span class="samp">multi</span></samp>&rsquo; or &lsquo;<samp><span class="samp">nondet</span></samp>&rsquo; cannot
be defined directly, procedures with those determinisms that require foreign
code in their implementation must be defined using a combination of Mercury
clauses and (semi)deterministic foreign_procs. 
The following implementation for the standard library predicate
&lsquo;<samp><span class="samp">string.append/3</span></samp>&rsquo; in the mode &lsquo;<samp><span class="samp">append(out, out, in) is multi</span></samp>&rsquo;
illustrates this technique:

<pre class="example">     :- pred append(string, string, string).
     :- mode append(out, out, in) is multi.
     
     append(S1, S2, S3) :-
         S3Len = string.length(S3),
         append_2(0, S3Len, S1, S2, S3).
     
     :- pred append_2(int::in, int::in, string::out, string::out, string::in) is multi.
     
     append_2(NextS1Len, S3Len, S1, S2, S3) :-
         ( NextS1Len = S3Len -&gt;
             append_3(NextS1Len, S3Len, S1, S2, S3)
         ;
             (
                 append_3(NextS1Len, S3Len, S1, S2, S3)
             ;
                 append_2(NextS1Len + 1, S3Len, S1, S2, S3)
             )
         ).
     
     :- pred append_3(int::inb, int::in, string::out, string::out, string::in) is det.
     
     :- pragma foreign_proc("C",
         append_3(S1Len::in, S3Len::in, S1::out, S2::out, S3::in),
         [will_not_call_mercury, promise_pure],
     "
         S1 = allocate_string(S1Len);   /* Allocate a new string of length S1Len */
         memcpy(S1, S3, S1Len);
         S1[S1Len] = '\\0';
         S2 = allocate_string(S2, S3Len - S1Len);
         strcpy(S2, S3Len + S1Len);
     ").
     
</pre>
   <div class="node">
<a name="Foreign-code-attributes"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#pragma-foreign_005fproc">pragma foreign_proc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Calling-foreign-code-from-Mercury">Calling foreign code from Mercury</a>

</div>

<h4 class="subsection">14.1.2 Foreign code attributes</h4>

<p>As described above,
&lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo;
declarations may include a list of attributes describing properties
of the given foreign function or code. 
All Mercury implementations must support the attributes listed below. 
They may also support additional attributes.

   <p>The attributes which must be supported by all implementations
are as follows:

     <dl>
<dt>&lsquo;<samp><span class="samp">may_call_mercury</span></samp>&rsquo;/&lsquo;<samp><span class="samp">will_not_call_mercury</span></samp>&rsquo;<dd>This attribute declares whether or not execution inside this foreign
language code may call back into Mercury or not.  The default, in case
neither is specified, is &lsquo;<samp><span class="samp">may_call_mercury</span></samp>&rsquo;. 
Specifying &lsquo;<samp><span class="samp">will_not_call_mercury</span></samp>&rsquo; may allow the compiler to
generate more efficient code. 
If you specify &lsquo;<samp><span class="samp">will_not_call_mercury</span></samp>&rsquo;,
but the foreign language code <em>does</em> invoke Mercury code, then the
behaviour is undefined.

     <br><dt>&lsquo;<samp><span class="samp">promise_pure</span></samp>&rsquo;/&lsquo;<samp><span class="samp">promise_semipure</span></samp>&rsquo;<dd>This attribute promises that the purity of the given predicate or
function definition is pure or semipure. 
It is equivalent to a corresponding &lsquo;<samp><span class="samp">pragma promise_pure</span></samp>&rsquo;
or &lsquo;<samp><span class="samp">pragma promise_semipure</span></samp>&rsquo; declaration (see <a href="#Impurity">Impurity</a>). 
If omitted, the clause specified by the &lsquo;<samp><span class="samp">foreign_proc</span></samp>&rsquo; is
assumed to be impure.

     <br><dt>&lsquo;<samp><span class="samp">thread_safe</span></samp>&rsquo;/&lsquo;<samp><span class="samp">not_thread_safe</span></samp>&rsquo;/&lsquo;<samp><span class="samp">maybe_thread_safe</span></samp>&rsquo;<dd>This attribute declares whether or not it is safe for multiple threads
to execute this foreign language code concurrently. 
The default, in case none is specified, is &lsquo;<samp><span class="samp">not_thread_safe</span></samp>&rsquo;. 
If the foreign language code is declared &lsquo;<samp><span class="samp">thread_safe</span></samp>&rsquo;, then the
Mercury implementation is permitted to execute the code concurrently
from multiple threads without taking any special precautions. 
If the foreign language code is declared &lsquo;<samp><span class="samp">not_thread_safe</span></samp>&rsquo;,
then the Mercury implementation must not invoke the code concurrently from
multiple threads.  If the Mercury implementation does use multithreading,
then it must take appropriate steps to prevent this. 
(The experimental multithreaded version of the current
University of Melbourne Mercury implementation protects
&lsquo;<samp><span class="samp">not_thread_safe</span></samp>&rsquo; code using a mutex:
C code that is not thread-safe has code inserted around it to obtain
and release a mutex.  All non-thread-safe foreign language code shares a
single mutex.) 
<!-- XXX this can cause deadlocks if not_thread_safe foreign language code calls -->
<!-- Mercury which calls foreign language code -->
If the foreign language code is declared &lsquo;<samp><span class="samp">maybe_thread_safe</span></samp>&rsquo; then
whether the code is considered &lsquo;<samp><span class="samp">thread_safe</span></samp>&rsquo; or &lsquo;<samp><span class="samp">not_thread_safe</span></samp>&rsquo;
depends upon a compiler flag.  This attribute is useful when the
thread safety of the foreign code itself is conditional. 
The Melbourne Mercury compiler uses the &lsquo;<samp><span class="samp">--maybe-thread-safe</span></samp>&rsquo;
option to set the value of the &lsquo;<samp><span class="samp">maybe_thread_safe</span></samp>&rsquo; attribute. 
</dl>

   <p>Additional attributes which are supported by the Melbourne Mercury
compiler are as follows:

     <dl>
<dt>&lsquo;<samp><span class="samp">tabled_for_io</span></samp>&rsquo;<dd>This attribute should be attached to foreign procedures that do I/O.  It
tells the debugger to make calls to the foreign procedure idempotent. 
This allows the debugger to safely retry across such calls and also
allows safe declarative debugging of code containing such calls. 
For more information see the I/O tabling section of the Mercury user guide. 
If the foreign procedure contains gotos or static variables then the
&lsquo;<samp><span class="samp">pragma no_inline</span></samp>&rsquo; directive should also be given. 
Note that currently I/O tabling will only be done for foreign procedures
that take a pair of I/O state arguments.  Impure foreign procedures that
perform I/O will not be made idempotent, even if the tabled_for_io
attribute is present. 
Note also that the tabled_for_io attribute will likely be replaced in
a future release with a more general solution.

     <br><dt>&lsquo;<samp><span class="samp">terminates</span></samp>&rsquo;/&lsquo;<samp><span class="samp">does_not_terminate</span></samp>&rsquo;<dd>This attribute specifies the termination properties of the given predicate
or function definition.  It is equivalent to the corresponding
&lsquo;<samp><span class="samp">pragma terminates</span></samp>&rsquo; or &lsquo;<samp><span class="samp">pragma does_not_terminate</span></samp>&rsquo; declaration. 
If omitted, the termination property of the procedure is determined by the
value of the &lsquo;<samp><span class="samp">may_call_mercury</span></samp>&rsquo;/&lsquo;<samp><span class="samp">will_not_call_mercury</span></samp>&rsquo; attribute. 
See <a href="#Termination-analysis">Termination analysis</a> for more details.

     <br><dt>&lsquo;<samp><span class="samp">max_stack_size(Size)</span></samp>&rsquo;<dd>This attribute declares the maximum stack usage of a particular piece of
code.  The unit that &lsquo;<samp><span class="samp">Size</span></samp>&rsquo; is measured in depends upon foreign language
being used. 
Currently this attribute is only used (and is in fact required) by the
&lsquo;<samp><span class="samp">IL</span></samp>&rsquo; foreign language interface, and is measured in units of stack
items.

     <br><dt>&lsquo;<samp><span class="samp">will_not_throw_exception</span></samp>&rsquo;<dd>This attribute promises that the given predicate or function will not
make calls back to Mercury that may result in an exception being thrown. 
It is an error to apply this attribute to procedures that have determinism
erroneous.  This attribute is ignored for code that is declared as not
making calls back to Mercury via the &lsquo;<samp><span class="samp">will_not_call_mercury</span></samp>&rsquo; attribute. 
Note: predicates or functions that have polymorphic arguments but
do not explicitly throw an exception, via a call to exception.throw/1
or require.error/1, may still throw exceptions because they may be
called with arguments whose types have user-defined equality or
comparison predicates.  If these user-defined equality or comparison
predicates throw exceptions then unifications or comparisons involving
these types may also throw exceptions.  As such, we recommend that
only implementors of the Mercury system use this annotation for
polymorphic predicates and functions.

     <!-- @item @samp{high_level_backend} -->
     <!-- The foreign_proc will apply only on the high level backend. -->
     <!-- @item @samp{low_level_backend} -->
     <!-- The foreign_proc will apply only on the low level backend. -->
     <br><dt>&lsquo;<samp><span class="samp">will_not_modify_trail/may_modify_trail</span></samp>&rsquo;<dd>This attribute declares whether or not a foreign procedure modifies
the trail (see <a href="#Trailing">Trailing</a>).  Specifying that a foreign procedure
will not modify the trail may allow the compiler to generate more
efficient code for that procedure.  In compilation grades that do not
support trailing this attribute is ignored.  The default, in case
none is specified, is &lsquo;<samp><span class="samp">may_modify_trail</span></samp>&rsquo;.

     <br><dt>&lsquo;<samp><span class="samp">will_not_call_mm_tabled/may_call_mm_tabled</span></samp>&rsquo;<dd>This attribute declares whether or not a foreign procedure makes calls back to
Mercury procedures that are evaluated using minimal model tabling
(see <a href="#Tabled-evaluation">Tabled evaluation</a>).  Specifying that a foreign procedure will not call
procedures evaluated using minimal model tabling may allow the compiler to
generate more efficient code.  In compilation grades that do not support
minimal model tabling this attribute is ignored.  These attributes may not be
used with procedures that do not make calls back to Mercury, i.e. that have
the &lsquo;<samp><span class="samp">will_not_call_mercury</span></samp>&rsquo; attribute.  The default for foreign
procedures that &lsquo;<samp><span class="samp">may_call_mercury</span></samp>&rsquo;, in case none is specified, is
&lsquo;<samp><span class="samp">may_call_mm_tabled</span></samp>&rsquo;.

     <br><dt>&lsquo;<samp><span class="samp">affects_liveness/does_not_affect_liveness</span></samp>&rsquo;<dd>This attribute declares whether or not a foreign procedure
uses and/or modifies any part of the Mercury virtual machine
(registers, stack slots)
through means other than its arguments. 
The &lsquo;<samp><span class="samp">affects_liveness</span></samp>&rsquo; attribute says that it does;
The &lsquo;<samp><span class="samp">does_not_affect_liveness</span></samp>&rsquo; attribute says that it does not. 
In the absence of either attribute,
the compiler assumes &lsquo;<samp><span class="samp">affects_liveness</span></samp>&rsquo;,
unless the code of the foreign_proc in question is empty.

     <br><dt>&lsquo;<samp><span class="samp">may_duplicate/may_not_duplicate</span></samp>&rsquo;<dd>This attribute tells the compiler
whether it is allowed to duplicate the foreign code fragment
through optimizations such as inlining. 
The &lsquo;<samp><span class="samp">may_duplicate</span></samp>&rsquo; attribute says that it may;
The &lsquo;<samp><span class="samp">may_not_duplicate</span></samp>&rsquo; attribute says that it may not. 
In the absence of either attribute,
the compiler is allowed make its own judgement in the matter,
based on factors such as the size of the code fragment.

     <!-- @item -->
     <!-- @samp{does_not_allocate_memory/allocates_bounded_memory/allocates_unbounded_memory} -->
     <!-- This attribute declares whether a foreign procedure -->
     <!-- allocates any memory on the Mercury heap, -->
     <!-- and if it does, whether the amount allocated -->
     <!-- is guaranteed to be smaller than the bound given -->
     <!-- by the reserve space of the native garbage collector. -->
     <!-- @item -->
     <!-- @samp{registers_roots/does_not_register_roots/does_not_have_roots} -->
     <!-- This attribute declares whether a foreign procedure -->
     <!-- registers with the native garbage collector -->
     <!-- all the root pointers it accesses. -->
     <!-- This must always include -->
     <!-- all global variables maintained by the foreign procedure. -->
     <!-- If the foreign procedure may call Mercury, -->
     <!-- it must also include any storage location in which -->
     <!-- the foreign procedure stores roots before any call to Mercury -->
     <!-- (since a gc may take place during such a call). -->
     <!-- @item @samp{no_sharing/unknown_sharing/sharing(MaybeTypes, SharingList)} -->
     <!-- This attribute declares whether or not a foreign procedure creates any -->
     <!-- structure sharing @ref{Structure sharing analysis} between its input -->
     <!-- and output arguments. -->
     <!-- Specifying that a foreign -->
     <!-- procedure generates no sharing (attribute @samp{no_sharing}) is a promise -->
     <!-- to the compiler that the procedure does not create any sharing -->
     <!-- between its arguments. The attribute @samp{unknown_sharing} specifies -->
     <!-- that the -->
     <!-- procedure may create any possible sharing between the arguments. -->
     <!-- Finally, using -->
     <!-- @samp{sharing(MaybeTypes, SharingList)} it is possible to specify a list of -->
     <!-- sharing arguments, declaring that the foreign procedure creates at most -->
     <!-- the specified sharing between the arguments. @samp{MaybeTypes} takes -->
     <!-- the values -->
     <!-- @samp{no/yes(Types)}, where @samp{Types} corresponds to the types used in -->
     <!-- the predicate or function declaration for this foreign procedure. -->
     <!-- @samp{SharingList} consists of a list -->
     <!-- @samp{[SharingPairA, SharingPairB, ...]}, where each sharing pair -->
     <!-- is represented by a pair @samp{cel(Vari, Seli) - cel(Varj, Selj)}. -->
     <!-- @samp{Vari, Varj} must be variables that are part of the mode declaration -->
     <!-- of the @samp{foreign_proc} definition. @samp{Seli, Selj} select -->
     <!-- the subterms of the given arguments that actually share. Each selector -->
     <!-- @samp{Seli} is written as a list of types @samp{[Type1, Type2, ...]} -->
     <!-- representing a path in the term structure of the given argument. An -->
     <!-- empty list designates the complete term to which the argument corresponds. -->
     <!-- The types can make use of type variables as long as @samp{MaybeTypes} is -->
     <!-- set to @samp{yes(Types)}, and the type variables occur in any of the types -->
     <!-- used in @samp{Types}. -->
     <!-- @example -->
     <!-- :- pred array.init_2(int::in, T::in, array(T)::array_uo) is det. -->
     <!-- :- pragma foreign_proc("C", -->
     <!-- array.init_2(Size::in, Item::in, Array::array_uo), -->
     <!-- [will_not_call_mercury, promise_pure, thread_safe, will_not_modify_trail, -->
     <!-- sharing(yes(int, T, array(T)), [cel(Item,[]) - cel(Array,[T])])], -->
     <!-- " -->
     <!-- ML_alloc_array(Array, Size + 1, MR_ALLOC_ID); -->
     <!-- ML_init_array(Array, Size, Item); -->
     <!-- "). -->
     <!-- @end example -->
     <!-- This sharing declaration promises that a call -->
     <!-- @code{init_2(Size, Item, Array)}, with types @code{int, T, array(T)} -->
     <!-- may create sharing between any -->
     <!-- subterms of type @code{T} of the resulting array @code{Array} and the -->
     <!-- term @code{Item}. Reformulated: the elements of @code{Array} may refer -->
     <!-- to the same memory locations as @code{Item}. -->
   </dl>

<!--  -->
<div class="node">
<a name="Calling-Mercury-from-foreign-code"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-foreign-types-from-Mercury">Using foreign types from Mercury</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Calling-foreign-code-from-Mercury">Calling foreign code from Mercury</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-language-interface">Foreign language interface</a>

</div>

<h3 class="section">14.2 Calling Mercury from foreign code</h3>

<p>Mercury procedures may be exported so that they can be called by code written
in a foreign language.

   <p>A declaration of the form:

<pre class="example">     :- pragma foreign_export("<var>Lang</var>",
             <var>Pred</var>(<var>Mode1</var>, <var>Mode2</var>, ...), "<var>ForeignName</var>").
</pre>
   <p class="noindent">or

<pre class="example">     :- pragma foreign_export("<var>Lang</var>",
             <var>Func</var>(<var>Mode1</var>, <var>Mode2</var>, ...) = <var>Mode</var>,
             "<var>ForeignName</var>").
</pre>
   <p class="noindent">exports a procedure for use by foreign language <var>Lang</var>. 
For each exported procedure the Mercury implementation will create an
interface to the named Mercury procedure in the foreign language using
the name <var>ForeignName</var>.  The form of this interface is dependent
upon the specified foreign language.  For further details see the language
specific information below.

   <p>It is an error to export a Mercury procedure that has a determinism of
multi or nondet.

<!--  -->
<div class="node">
<a name="Data-passing-conventions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Adding-foreign-declarations">Adding foreign declarations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-foreign-enumerations-in-Mercury-code">Using foreign enumerations in Mercury code</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-language-interface">Foreign language interface</a>

</div>

<h3 class="section">14.3 Data passing conventions</h3>

<p>For each supported foreign language,
we explain how to map a Mercury type to a type in that foreign language. 
We also map the Mercury parameter passing convention
to the foreign language's parameter passing convention.

<ul class="menu">
<li><a accesskey="1" href="#C-data-passing-conventions">C data passing conventions </a>
<li><a accesskey="2" href="#C_0023-data-passing-conventions">C# data passing conventions </a>
<li><a accesskey="3" href="#Java-data-passing-conventions">Java data passing conventions </a>
<li><a accesskey="4" href="#Erlang-data-passing-conventions">Erlang data passing conventions </a>
</ul>

<div class="node">
<a name="C-data-passing-conventions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#C_0023-data-passing-conventions">C# data passing conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-passing-conventions">Data passing conventions</a>

</div>

<h4 class="subsection">14.3.1 C data passing conventions</h4>

<p>For each of the Mercury types <code>int</code>, <code>float</code>, <code>char</code>,
and <code>string</code>, there is a C typedef for the corresponding type in C:
<code>MR_Integer</code>, <code>MR_Float</code>, <code>MR_Char</code>,
and <code>MR_String</code> respectively.

   <p>In the current implementation, &lsquo;<samp><span class="samp">MR_Integer</span></samp>&rsquo; is a typedef for a signed
integral type whose size is the same size as a pointer of type &lsquo;<samp><span class="samp">void *</span></samp>&rsquo;;
&lsquo;<samp><span class="samp">MR_Float</span></samp>&rsquo; is a typedef for &lsquo;<samp><span class="samp">double</span></samp>&rsquo; (unless the program and the
Mercury library was compiled with &lsquo;<samp><span class="samp">--single-prec-float</span></samp>&rsquo;, in which case it
is a typedef for &lsquo;<samp><span class="samp">float</span></samp>&rsquo;); &lsquo;<samp><span class="samp">MR_Char</span></samp>&rsquo; is a typedef for a signed
32-bit integral type and &lsquo;<samp><span class="samp">MR_String</span></samp>&rsquo; is a typedef for &lsquo;<samp><span class="samp">char *</span></samp>&rsquo;.

   <p>Mercury variables of type <code>int</code>, <code>float</code>, <code>char</code>, or
<code>string</code> are passed to and from C as C variables whose type is
given by the corresponding typedef.

   <p>For the Mercury standard library type &lsquo;<samp><span class="samp">bool.bool</span></samp>&rsquo;, there is a
corresponding C type, <code>MR_Bool</code>.  C code can refer to the boolean
data constructors &lsquo;<samp><span class="samp">yes</span></samp>&rsquo; and &lsquo;<samp><span class="samp">no</span></samp>&rsquo;, as <code>MR_YES</code> and
<code>MR_NO</code> respectively.

   <p>For the Mercury standard library type &lsquo;<samp><span class="samp">builtin.comparison_result</span></samp>&rsquo;, there
is a corresponding C type, <code>MR_Comparison_Result</code>.  C code can refer
to the data constructors of this type, &lsquo;<samp><span class="samp">(&lt;)</span></samp>&rsquo;, &lsquo;<samp><span class="samp">(=)</span></samp>&rsquo; and &lsquo;<samp><span class="samp">(&gt;)</span></samp>&rsquo;,
as <code>MR_COMPARE_LESS</code>, <code>MR_COMPARE_EQUAL</code> and
<code>MR_COMPARE_GREATER</code> respectively.

   <p>Mercury variables of a type for which there is a C &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo;
declaration (see <a href="#Using-foreign-types-from-Mercury">Using foreign types from Mercury</a>) will be passed as
the corresponding C type.

   <p>Mercury tuple types are passed as &lsquo;<samp><span class="samp">MR_Tuple</span></samp>&rsquo;, which in the current
implementation is a typedef for a pointer of type &lsquo;<samp><span class="samp">void *</span></samp>&rsquo; if
&lsquo;<samp><span class="samp">--high-level-code</span></samp>&rsquo; is enabled, and a typedef for &lsquo;<samp><span class="samp">MR_Word</span></samp>&rsquo;
otherwise.

   <p>Mercury variables of any other type
are passed as a &lsquo;<samp><span class="samp">MR_Word</span></samp>&rsquo;, which in the current implementation
is a typedef for an unsigned type whose size is the same size as a pointer. 
(Note: it would in fact be better for each Mercury type to map to a distinct
abstract type in C, since that would be more type-safe, and thus we may
change this in a future release.  We advise programmers who are manipulating
Mercury types in C code to use typedefs for each user-defined Mercury type,
and to treat each such type as an abstract data type.  This is good style
and it will also minimize any compatibility problems if and when we do change
this.)

   <p>Mercury lists can be manipulated by C code using the following macros,
which are defined by the Mercury implementation.

<pre class="example">     MR_list_is_empty(list)     /* test if a list is empty */
     MR_list_head(list)         /* get the head of a list */
     MR_list_tail(list)         /* get the tail of a list */
     MR_list_empty()            /* create an empty list */
     MR_list_cons(head,tail)    /* construct a list with the given head and tail */
</pre>
   <p>Note that the use of these macros is subject to some caveats
(see <a href="#Memory-management-for-C">Memory management for C</a>).

   <p>The implementation provides the macro &lsquo;<samp><span class="samp">MR_word_to_float</span></samp>&rsquo; for converting a
value of type &lsquo;<samp><span class="samp">MR_Word</span></samp>&rsquo; to one of type &lsquo;<samp><span class="samp">MR_Float</span></samp>&rsquo;, and the macro
&lsquo;<samp><span class="samp">MR_float_to_word</span></samp>&rsquo; for converting a value of type &lsquo;<samp><span class="samp">MR_Float</span></samp>&rsquo; to one
of type &lsquo;<samp><span class="samp">MR_Word</span></samp>&rsquo;. 
These macros must be used to perform these conversions since for some Mercury
implementations &lsquo;<samp><span class="samp">sizeof(MR_Float)</span></samp>&rsquo; is greater than &lsquo;<samp><span class="samp">sizeof(MR_Word)</span></samp>&rsquo;.

   <p>The following fragment of C code illustrates the correct way to extract the
head of a Mercury list of floats.

<pre class="example">     MR_Float f;
     f = MR_word_to_float(MR_list_head(list));
</pre>
   <p>Omitting the call to &lsquo;<samp><span class="samp">MR_word_to_float</span></samp>&rsquo; in the above example would yield
incorrect results for implementations where &lsquo;<samp><span class="samp">sizeof(MR_Float)</span></samp>&rsquo; is greater
than &lsquo;<samp><span class="samp">sizeof(MR_Word)</span></samp>&rsquo;.

<div class="node">
<a name="C%23-data-passing-conventions"></a>
<a name="C_0023-data-passing-conventions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Java-data-passing-conventions">Java data passing conventions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C-data-passing-conventions">C data passing conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-passing-conventions">Data passing conventions</a>

</div>

<h4 class="subsection">14.3.2 C# data passing conventions</h4>

<p>The Mercury types <code>int</code>, <code>float</code>,
and <code>string</code> are mapped to the Common Language Infrastructure (CLI) types
<code>System.Int32</code>, <code>System.Double</code>, and
<code>System.String</code> respectively, which correspond to the C# types
<code>int</code>, <code>double</code>, and <code>string</code>. 
The Mercury type <code>char</code> is mapped like <code>int</code>; <em>not</em> to the CLI
type <code>System.Char</code> because that only holds 16-bit numeric values.

   <p>For the Mercury standard library type &lsquo;<samp><span class="samp">bool.bool</span></samp>&rsquo;, there is a
corresponding C# type, <code>mr_bool.Bool_0</code>.  C# code can refer to the
boolean data constructors &lsquo;<samp><span class="samp">yes</span></samp>&rsquo; and &lsquo;<samp><span class="samp">no</span></samp>&rsquo;, as <code>mr_bool.YES</code>
and <code>mr_bool.NO</code> respectively.

   <p>For the Mercury standard library type &lsquo;<samp><span class="samp">builtin.comparison_result</span></samp>&rsquo;, there
is a corresponding C# type, <code>builtin.Comparison_result_0</code>.  C# code
can refer to the data constructors of this type, &lsquo;<samp><span class="samp">(&lt;)</span></samp>&rsquo;, &lsquo;<samp><span class="samp">(=)</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">(&gt;)</span></samp>&rsquo;, as <code>builtin.COMPARE_LESS</code>, <code>builtin.COMPARE_EQUAL</code>
and <code>builtin.COMPARE_GREATER</code> respectively.

   <p>Mercury variables of a type for which there is a C# &lsquo;<samp><span class="samp">pragma
foreign_type</span></samp>&rsquo; declaration (see <a href="#Using-foreign-types-from-Mercury">Using foreign types from Mercury</a>) will be
passed as the corresponding C# type. 
Both reference and value types are supported.

   <p>Mercury tuple types are passed as &lsquo;<samp><span class="samp">object[]</span></samp>&rsquo; where
the length of the array is the number of elements in the tuple.

   <p>Mercury variables whose type is a type variable will be passed as
<code>System.Object</code>.

   <p>Mercury variables whose type is a Mercury discriminated union type
will be passed as a CLI type whose type name is determined from
the Mercury type name (ignoring any type parameters) followed by
an underscore and then the type arity,
expressed as a decimal integer. 
The first character of the type name will have its case inverted,
and the name may be mangled to satisfy C# lexical rules.

<p class="noindent">For example, the following Mercury type corresponds to the C# class
that follows (some implementation details elided):

<pre class="example">     :- type maybe(T)
         ---&gt;    yes(yes_field :: T)
         ;       no.
     
     public static class Maybe_1 {
         public static class Yes_1 : Maybe_1 {
             public object yes_field;
             public Yes_1(object x) { ... }
         }
         public static class No_0 : Maybe_1 {
             public No_0() { ... }
         }
     }
</pre>
   <p>C# code generated by the Mercury compiler is placed in the &lsquo;<samp><span class="samp">mercury</span></samp>&rsquo;
namespace.  Mercury module qualifiers are converted into a C# class name by
concatenating the components with double underscore separators (&lsquo;<samp><span class="samp">__</span></samp>&rsquo;). 
For example the Mercury type &lsquo;<samp><span class="samp">foo.bar.baz/1</span></samp>&rsquo; will be passed as the C#
type &lsquo;<samp><span class="samp">mercury.foo__bar.Baz_1</span></samp>&rsquo;.

   <p>Mercury array types are mapped to &lsquo;<samp><span class="samp">System.Array</span></samp>&rsquo;.

   <p>Mercury variables whose type is a Mercury equivalence type
will be passed as the representation of the right hand side of the
equivalence type.

   <p>This mapping is subject to change and you should try to avoid writing
code that relies heavily upon a particular representation of Mercury
terms.

   <p>Mercury arguments declared with input modes are passed by value to the
C# function.

   <p>Arguments of type &lsquo;<samp><span class="samp">io.state</span></samp>&rsquo; or &lsquo;<samp><span class="samp">store.store(_)</span></samp>&rsquo; are not
passed or returned at all. 
(The reason for this is that these types represent mutable state,
and in C# modifications to mutable state are done via side effects,
rather than argument passing.)

   <p>The handling of multiple output arguments is as follows.

   <p>If the Mercury procedure is deterministic and has no output arguments,
then the return type of the C# function is &lsquo;<samp><span class="samp">void</span></samp>&rsquo;; if it has
one output argument, then the return value of the function is that
output argument.

   <p>If the Mercury procedure is deterministic and has two or more output
arguments, then the return type of the C# function is &lsquo;<samp><span class="samp">void</span></samp>&rsquo;. 
At the position of each output argument, the C# function has an
&lsquo;<samp><span class="samp">out</span></samp>&rsquo; parameter.

   <p>If the Mercury procedure is semi-deterministic then the C# function
returns a &lsquo;<samp><span class="samp">bool</span></samp>&rsquo;.  A &lsquo;<samp><span class="samp">true</span></samp>&rsquo; return value denotes success
and &lsquo;<samp><span class="samp">false</span></samp>&rsquo; denotes failure.  Output arguments are handled in the
same way as multiple outputs for deterministic procedures, using &lsquo;<samp><span class="samp">out</span></samp>&rsquo;
parameters.  On failure the values of the &lsquo;<samp><span class="samp">val</span></samp>&rsquo; fields are
undefined.

   <p>Mercury lists can be manipulated by C# code using the following methods,
which are defined by the Mercury implementation.

<pre class="example">     bool      list.is_empty(List_1 list)     // test if a list is empty
     object    list.det_head(List_1 list)     // get the head of a list
     List_1    list.det_tail(List_1 list)     // get the tail of a list
     List_1    list.empty_list()              // create an empty list
     List_1    list.cons(object head, List_1 tail)
                                              // construct a list with
                                              //  the given head and tail
</pre>
   <div class="node">
<a name="Java-data-passing-conventions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Erlang-data-passing-conventions">Erlang data passing conventions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C_0023-data-passing-conventions">C# data passing conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-passing-conventions">Data passing conventions</a>

</div>

<h4 class="subsection">14.3.3 Java data passing conventions</h4>

<p>The Mercury types <code>int</code>, <code>float</code>,
and <code>string</code> are mapped to the Java types
<code>int</code>, <code>double</code>, and
<code>java.lang.String</code> respectively. 
The Mercury type <code>char</code> is mapped like <code>int</code>; <em>not</em> to the Java
type <code>char</code> because that only holds 16-bit numeric values.

   <p>For the Mercury standard library type &lsquo;<samp><span class="samp">bool.bool</span></samp>&rsquo;, there is a
corresponding Java type, <code>bool.Bool_0</code>.  Java code can refer to the
boolean data constructors &lsquo;<samp><span class="samp">yes</span></samp>&rsquo; and &lsquo;<samp><span class="samp">no</span></samp>&rsquo;, as <code>bool.YES</code>
and <code>bool.NO</code> respectively.

   <p>For the Mercury standard library type &lsquo;<samp><span class="samp">builtin.comparison_result</span></samp>&rsquo;, there
is a corresponding Java type, <code>builtin.Comparison_result_0</code>.  Java code
can refer to the data constructors of this type, &lsquo;<samp><span class="samp">(&lt;)</span></samp>&rsquo;, &lsquo;<samp><span class="samp">(=)</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">(&gt;)</span></samp>&rsquo;, as <code>builtin.COMPARE_LESS</code>, <code>builtin.COMPARE_EQUAL</code>
and <code>builtin.COMPARE_GREATER</code> respectively.

   <p>Mercury variables of a type for which there is a Java &lsquo;<samp><span class="samp">pragma
foreign_type</span></samp>&rsquo; declaration (see <a href="#Using-foreign-types-from-Mercury">Using foreign types from Mercury</a>) will be
passed as the corresponding Java type.

   <p>Mercury tuple types are passed as &lsquo;<samp><span class="samp">java.lang.Object[]</span></samp>&rsquo; where
the length of the array is the number of elements in the tuple.

   <p>Mercury variables whose types are universally quantified type variables
will have generic types. 
Mercury variables whose types are existentially quantified type variables
will be passed as <code>java.lang.Object</code>.

   <p>Mercury variables whose type is a Mercury discriminated union type
will be passed as a Java type whose type name is determined from
the Mercury type name (ignoring any type parameters) followed by
an underscore and then the type arity,
expressed as a decimal integer. 
The first character of the type name will have its case inverted,
and the name may be mangled to satisfy Java lexical rules. 
Generics are used in the Java type for any type parameters.

<p class="noindent">For example, the following Mercury type corresponds to the Java class
that follows (some implementation details elided):

<pre class="example">     :- type maybe(T)
         ---&gt;    yes(yes_field :: T)
         ;       no.
     
     public static class Maybe_1&lt;T&gt; {
         public static class Yes_1&lt;T&gt; extends Maybe_1 {
             public T yes_field;
             public Yes_1(T x) { ... }
         }
         public static class No_0&lt;T&gt; extends Maybe_1 {
             public No_0() { ... }
         }
     }
</pre>
   <p>Java code generated by the Mercury compiler is placed in the &lsquo;<samp><span class="samp">jmercury</span></samp>&rsquo;
package.  Mercury module qualifiers are converted into a Java class name by
concatenating the components with double underscore separators (&lsquo;<samp><span class="samp">__</span></samp>&rsquo;). 
For example the Mercury type &lsquo;<samp><span class="samp">foo.bar.baz/1</span></samp>&rsquo; will be passed as the Java
type &lsquo;<samp><span class="samp">jmercury.foo__bar.Baz_1</span></samp>&rsquo;.

   <p>Mercury array types are mapped to Java array types.

   <p>Mercury variables whose type is a Mercury equivalence type
will be passed as the representation of the right hand side of the
equivalence type.

   <p>This mapping is subject to change and you should try to avoid writing
code that relies heavily upon a particular representation of Mercury
terms.

   <p>Mercury arguments declared with input modes are passed by value to the
corresponding Java function.  If the Mercury procedure is a function
whose result has an input mode, then the Mercury function result is
appended to the list of input parameters, so that the Mercury function
result becomes the last parameter to the corresponding Java function.

   <p>Arguments of type &lsquo;<samp><span class="samp">io.state</span></samp>&rsquo; or &lsquo;<samp><span class="samp">store.store(_)</span></samp>&rsquo; are not
passed or returned at all. 
(The reason for this is that these types represent mutable state,
and in Java modifications to mutable state are done via side effects,
rather than argument passing.)

   <p>The handling of multiple output arguments is as follows.

   <p>If the Mercury procedure is deterministic and has no output arguments,
then the return type of the Java function is &lsquo;<samp><span class="samp">void</span></samp>&rsquo;; if it has
one output argument, then the return value of the function is that
output argument.

   <p>If the Mercury procedure is deterministic and has two or more output
arguments, then the return type of the Java function is &lsquo;<samp><span class="samp">void</span></samp>&rsquo;. 
At the position of each output argument, the Java function takes a
value of the type &lsquo;<samp><span class="samp">jmercury.runtime.Ref&lt;T&gt;</span></samp>&rsquo; where &lsquo;<samp><span class="samp">T</span></samp>&rsquo; is the
Java type corresponding to the type of the output argument. 
&lsquo;<samp><span class="samp">Ref</span></samp>&rsquo; is a class with a single field &lsquo;<samp><span class="samp">val</span></samp>&rsquo;, which is
assigned the output value when the function returns.

   <p>If the Mercury procedure is semi-deterministic then the Java function
returns a &lsquo;<samp><span class="samp">boolean</span></samp>&rsquo;.  A &lsquo;<samp><span class="samp">true</span></samp>&rsquo; return value denotes success
and &lsquo;<samp><span class="samp">false</span></samp>&rsquo; denotes failure.  Output arguments are handled in the
same way as multiple outputs for deterministic procedures, using the
&lsquo;<samp><span class="samp">Ref</span></samp>&rsquo; class.  On failure the values of the &lsquo;<samp><span class="samp">val</span></samp>&rsquo; fields are
undefined.

   <p>Mercury lists can be manipulated by Java code using the following methods,
which are defined by the Mercury implementation.

<pre class="example">     boolean   list.is_empty(List_1&lt;E&gt; list)     // test if a list is empty
     E         list.det_head(List_1&lt;E&gt; list)     // get the head of a list
     List_1&lt;E&gt; list.det_tail(List_1&lt;E&gt; list)     // get the tail of a list
     List_1&lt;E&gt; list.empty_list()                 // create an empty list
     &lt;E, F extends E&gt; List_1&lt;E&gt; list.cons(F head, List_1&lt;E&gt; tail)
                                                 // construct a list with
                                                 //  the given head and tail
</pre>
   <div class="node">
<a name="Erlang-data-passing-conventions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Java-data-passing-conventions">Java data passing conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-passing-conventions">Data passing conventions</a>

</div>

<h4 class="subsection">14.3.4 Erlang data passing conventions</h4>

<p>The Mercury types <code>int</code>, <code>float</code> and <code>char</code>
are mapped to Erlang integers, floats and integers respectively. 
A Mercury <code>string</code> is represented by an Erlang binary,
not by a list of integers.

   <p>Mercury variables whose type is a Mercury discriminated union type
will be passed as an Erlang tuple with the first element of the tuple
being an Erlang atom named after the Mercury data constructor. 
For example, values of the type:

<pre class="example">         :- type maybe_int
             ---&gt;    yes(int)
             ;       no.
</pre>
   <p class="noindent">would be represented in Erlang as &lsquo;<samp><span class="samp">{yes, </span><var>integer</var><span class="samp">}</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">{no}</span></samp>&rsquo;.

   <p>Mercury variables whose type is a Mercury equivalence type
will be passed as the representation of the right hand side of the
equivalence type.

   <p>This mapping is subject to change and you should try to avoid writing
code that relies heavily upon a particular representation of Mercury
terms.

   <p>Arguments of dummy types, e.g. &lsquo;<samp><span class="samp">io.state</span></samp>&rsquo;, are represented by the
atom &lsquo;<samp><span class="samp">false</span></samp>&rsquo; when necessary.  They are not passed to and from
calls to monomorphic procedures.

   <p>Mercury arguments declared with input modes are passed by value to the
corresponding Erlang function.

   <p>The result of an Erlang function depends on the determinism of the
Mercury procedure that it was derived from.  Procedures which succeed
exactly once and have a single output variable return the single value
directly.  Procedures which succeed exactly once and have zero or two
or more output variables return a tuple of those output variables in
order.

   <p>Procedures which are semideterministic return, on success, a tuple of
the variables with output modes (including when the number of output
variables is one).  On failure they return the Erlang atom
&lsquo;<samp><span class="samp">fail</span></samp>&rsquo;.

   <p>Procedures which are nondeterministic take as a final argument a
success continuation.  This is an function which has an input variable
for each variable of the Mercury procedure with an output mode.  For
each solution, the success continuation is called with the values of those
output variables.  When there are no more solutions the Erlang
function returns with an undefined value.

<!--  -->
<div class="node">
<a name="Using-foreign-types-from-Mercury"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-Mercury-enumerations-in-foreign-code">Using Mercury enumerations in foreign code</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Calling-Mercury-from-foreign-code">Calling Mercury from foreign code</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-language-interface">Foreign language interface</a>

</div>

<h3 class="section">14.4 Using foreign types from Mercury</h3>

<p>Types defined in a foreign language can be accessed in Mercury using
a declaration of the form

<pre class="example">     :- pragma foreign_type(<var>Lang</var>, <var>MercuryTypeName</var>, <var>ForeignTypeDescriptor</var>).
</pre>
   <p>This defines <var>MercuryTypeName</var> as a synonym for type
<var>ForeignTypeDescriptor</var> defined in the foreign language <var>Lang</var>. 
You must declare <var>MercuryTypeName</var> using a (possibly abstract)
&lsquo;<samp><span class="samp">:- type</span></samp>&rsquo; declaration as usual. The &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; must
not have wider visibility than the type declaration (if the
&lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; declaration is in the interface,
the &lsquo;<samp><span class="samp">:- type</span></samp>&rsquo; declaration must be also).

   <p><var>ForeignTypeDescriptor</var> defines how the Mercury type is mapped for a
particular foreign language.  Specific syntax is given in the language
specific information below.

   <p><var>MercuryTypeName</var> is treated as an abstract type at all times in
Mercury code. 
However, if <var>MercuryTypeName</var> is one of the parameters of a
foreign_proc for <var>Lang</var>, and the &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; declaration
is visible to the foreign_proc, it will be passed to that foreign_proc as
specified by <var>ForeignTypeDescriptor</var>.

   <p>Multiple foreign language definitions may be given for the same type &mdash;
the appropriate definition will be used for the appropriate language (see the
language specific information below for details).  All definitions
must have the same visibility.  A Mercury definition, which must define
a discriminated union type, may also be given.  The constructors for the
type will only be visible in Mercury clauses for predicates or functions with
&lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; clauses for all of the languages for which there
are &lsquo;<samp><span class="samp">foreign_type</span></samp>&rsquo; declarations for the type.

   <p>You can also associate assertions about the properties
of the foreign type with the &lsquo;<samp><span class="samp">foreign_type</span></samp>&rsquo; declaration,
using the following syntax:

<pre class="example">     :- pragma foreign_type(<var>Lang</var>, <var>MercuryTypeName</var>, <var>ForeignTypeDescriptor</var>, [<var>ForeignTypeAssertion</var>, ...]).
</pre>
   <p>Currently, two kinds of assertions are supported. 
The &lsquo;<samp><span class="samp">can_pass_as_mercury_type</span></samp>&rsquo; assertion
states that on the C backends, values of the given type
can be passed to and from Mercury code without boxing,
via simple casts, which is faster. 
This requires the type to be either an integer type or a pointer type,
and requires its size to be the same as or less than the size of Mercury word. 
Since deciding whether a C type satisfies this condition
requires knowledge of the Mercury implementation,
and violations are very likely to result in
the generated executable silently doing the wrong thing,
we do not recommend the use of assertions
unless you are an implementor of the Mercury system. 
The &lsquo;<samp><span class="samp">stable</span></samp>&rsquo; assertion is meaningful
only in the presence of the &lsquo;<samp><span class="samp">can_pass_as_mercury_type</span></samp>&rsquo; assertion. 
It states that either the C type is an integer type,
or it is a pointer type pointing to memory that will never change. 
Together, these assertions are sufficient to allow tabling
(see <a href="#Tabled-evaluation">Tabled evaluation</a>) and the &lsquo;<samp><span class="samp">compare_representation</span></samp>&rsquo;
primitive to work on values of such types.

   <p>As with discriminated union types, programmers can specify the unification
and/or<!-- /@w --> comparison predicates to use for values of the type using the
following syntax (see <a href="#User_002ddefined-equality-and-comparison">User-defined equality and comparison</a>):

<pre class="example">     :- pragma foreign_type(<var>Lang</var>, <var>MercuryTypeName</var>, <var>ForeignTypeDescriptor</var>)
             where equality is <var>EqualityPred</var>, comparison is <var>ComparePred</var>.
</pre>
   <p>You can use Mercury foreign language interfacing declarations
which specify language <var>X</var> to interface to types that are actually
written in a different language <var>Y</var> provided that <var>X</var> and <var>Y</var>
have compatible interface conventions.  Support for this kind of
compatibility is described in the language specific information below.

<!--  -->
<div class="node">
<a name="Using-Mercury-enumerations-in-foreign-code"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-foreign-enumerations-in-Mercury-code">Using foreign enumerations in Mercury code</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-foreign-types-from-Mercury">Using foreign types from Mercury</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-language-interface">Foreign language interface</a>

</div>

<h3 class="section">14.5 Using Mercury enumerations in foreign code</h3>

<p>Values of Mercury enumeration types can be made available to code in the
bodies of &lsquo;<samp><span class="samp">foreign_proc</span></samp>&rsquo; and &lsquo;<samp><span class="samp">foreign_code</span></samp>&rsquo; pragmas via
a declaration of the form:

<pre class="example">     :- pragma foreign_export_enum("<var>Lang</var>", <var>MercuryType</var>,
             <var>Attributes</var>, <var>Overrides</var>).
</pre>
   <p>This causes the compiler to create a symbolic name in language
<var>Lang</var> for each of the constructors of <var>MercuryType</var>. 
The symbolic name allows the foreign code to create a value
corresponding to that of the constructor it represents. 
(The exact mechanism used depends upon the foreign language;
see the language specific information below for further details.)

   <p>For each foreign language there is a default mapping between the name
of a Mercury constructor and its symbolic name in the language <var>Lang</var>. 
This default mapping is not required to map every valid constructor name
to a valid name in language <var>Lang</var>; where it does not the programmer
must specify a valid symbolic name. 
The programmer may also choose to map a constructor to a symbolic name
that differs from the one supplied by the default mapping for language
<var>Lang</var>. 
<var>Overrides</var> is a list whose elements are pairs of constructor names
and strings. 
The latter specify the name that the implementation should use as the
symbolic name in the foreign language. 
<var>Overrides</var> has the following form:

<pre class="example">     [cons_I - "symbol_I", ..., cons_J - "symbol_J"]
</pre>
   <p>This can be used to provide either a valid symbolic name where the
default mapping does not, or to override a valid symbolic name
generated by the default mapping. 
This argument may be omitted if <var>Overrides</var> is empty.

   <p>The argument <var>Attributes</var> is a list of optional attributes. 
If empty, it may be omitted from the &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo;
declaration. 
The following attributes must be supported by all Mercury implementations.

     <dl>

     <dt>&lsquo;<samp><span class="samp">prefix(Prefix)</span></samp>&rsquo;<dd>Prefix each symbolic name, regardless of how it was generated, with
the string <var>Prefix</var>. 
At most one &lsquo;<samp><span class="samp">prefix</span></samp>&rsquo; attribute may be specified for a
&lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo; declaration.

     <br><dt>&lsquo;<samp><span class="samp">uppercase</span></samp>&rsquo;<dd>Convert any alphabetic characters in a Mercury constructor name
to uppercase when generating the symbolic name using the default
mapping. 
Symbolic names specified by the programmer using <var>Overrides</var>
are not affected by this attribute. 
If the &lsquo;<samp><span class="samp">prefix</span></samp>&rsquo; attribute is also specified, then the prefix
is added to the symbolic name <em>after</em> the conversion to
uppercase has been performed, i.e. the characters in the prefix
are not affected by the &lsquo;<samp><span class="samp">uppercase</span></samp>&rsquo; attribute.

   </dl>

   <p>The implementation does not check the validity of a symbolic name
in the foreign language until after the effects of any attributes
have been applied. 
This means that attributes may cause an otherwise valid symbolic name
to become invalid or vice versa.

   <p>It is an error if the mapping between constructors and symbolic names
does not form a bijection. 
A program can contain multiple &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo;
declarations for a single Mercury type. 
The implementation is not required to check that the symbolic names
generated by separate &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo; declarations
are unique.

   <p>A module may contain &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo; declarations that
refer to imported types, subject to the usual visibility restrictions.

   <p>A &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo; declaration may only occur in the
implementation section of a module.

<!--  -->
<div class="node">
<a name="Using-foreign-enumerations-in-Mercury-code"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Data-passing-conventions">Data passing conventions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Mercury-enumerations-in-foreign-code">Using Mercury enumerations in foreign code</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-language-interface">Foreign language interface</a>

</div>

<h3 class="section">14.6 Using foreign enumerations in Mercury code</h3>

<p>The values used to represent a Mercury enumeration type in a foreign
language may be explicitly assigned by the programmer using a declaration
of the form:

<pre class="example">     :- pragma foreign_enum("<var>Lang</var>", <var>MercuryType</var>, <var>CtorValues</var>).
</pre>
   <p><var>CtorValues</var> is a list of pairs of the form:

<pre class="example">     [
         ctor_0 - "ForeignValue_0",
         ctor_1 - "ForeignValue_1",
         ...
         ctor_N - "ForeignValue_N"
     ]
</pre>
   <p>The first element of each pair is a constructor of the type <var>MercuryType</var>,
and the second is a value in the language <var>Lang</var> that will be used
to represent that constructor. 
The mapping defined by this list of pairs must form a bijection.

   <p>Mercury implementations may impose further foreign language-specific
restrictions on the form that values used to represent enumeration
constructors may take. 
See the language specific information below for details.

   <p>The Mercury implementation is not required to check the validity of
foreign enumeration values.

   <p>A &lsquo;<samp><span class="samp">pragma foreign_enum</span></samp>&rsquo; declaration must occur in the implementation
section of the module that defines the type <var>MercuryType</var>. 
It is an error if the type <var>MercuryType</var> is the subject of more than
one &lsquo;<samp><span class="samp">pragma foreign_enum</span></samp>&rsquo; declaration for a given foreign language.

   <p>Note that the default comparison for types that are the subject of a
&lsquo;<samp><span class="samp">pragma foreign_enum</span></samp>&rsquo; declaration will be defined by the foreign
values, rather than the order of the constructors in the
type declaration (as is usually the case).

<!-- XXX we need to specify a behaviour when there are multiple supported -->
<!-- foreign languages. -->
<!--  -->
<div class="node">
<a name="Adding-foreign-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Adding-foreign-definitions">Adding foreign definitions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Data-passing-conventions">Data passing conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-language-interface">Foreign language interface</a>

</div>

<h3 class="section">14.7 Adding foreign declarations</h3>

<p>Foreign language declarations (such as type declarations, header file
inclusions or macro definitions) can be included in the Mercury source file
as part of a &lsquo;<samp><span class="samp">foreign_decl</span></samp>&rsquo; declaration of the form

<pre class="example">     :- pragma foreign_decl("<var>Lang</var>", <var>DeclCode</var>).
</pre>
   <p>This declaration will have effects equivalent to including the specified
<var>DeclCode</var> in an automatically-generated source file of the specified
programming language, in a place appropriate for declarations,
and linking that source file with the Mercury program
(after having compiled it with a compiler for the specified programming
language, if appropriate).

   <p>Entities declared in &lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declarations are
visible in &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo;, &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">pragma foreign_enum</span></samp>&rsquo; declarations
that specify the same foreign language and occur in the same Mercury module.

   <p>By default, the contents of &lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declarations
are also visible in the same kinds of declarations in other modules
that import the module containing the &lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declaration. 
This is because they may be required to make sense of
types defined using &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; and/or
predicates defined using &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo;
in the containing module,
and these may be visible in other modules,
especially in the presence of intermodule optimization,

   <p>If you do not want the contents of a &lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declaration
to be visible in foreign language code in other modules,
you can use the following variant of the declaration:

<pre class="example">     :- pragma foreign_decl("<var>Lang</var>", local, <var>DeclCode</var>).
</pre>
   <p>Note: currently only the C and Erlang backends support this variant
of the &lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declaration.

   <p>The declarations for Mercury predicates or functions exported to a
foreign language using a &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declaration
are visible to foreign code in a &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo; or
&lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; declaration of the same module and also in those
of any sub-modules. 
They are not visible to the foreign code in &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo; or
&lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; declarations in any other module. 
They can be made visible using a declaration of the form:

<pre class="example">     :- pragma foreign_import_module("<var>Lang</var>", <var>ImportedModule</var>).
</pre>
   <p class="noindent">where <var>ImportedModule</var> is the name of the module containing
the &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declarations.

   <p>If <var>Lang</var> is <code>"C"</code> this is equivalent to

<pre class="example">     :- pragma foreign_decl("C", "#include ""<var>ImportedModule</var>.mh""").
</pre>
   <p class="noindent">where <samp><var>ImportedModule</var><span class="file">.mh</span></samp> is the automatically generated
header file containing the C declarations for the predicates
and functions exported to C.

   <p>&lsquo;<samp><span class="samp">pragma foreign_import_module</span></samp>&rsquo; should be used instead of the
explicit <code>#include</code> because &lsquo;<samp><span class="samp">pragma foreign_import_module</span></samp>&rsquo;
tells the implementation that <samp><var>ImportedModule</var><span class="file">.mh</span></samp> must be built
before the object file for the module containing the
&lsquo;<samp><span class="samp">pragma foreign_import_module</span></samp>&rsquo; declaration.

   <p>A cycle of &lsquo;<samp><span class="samp">pragma foreign_import_module</span></samp>&rsquo;, where the language is
&lsquo;<samp><span class="samp">"C#"</span></samp>&rsquo; or &lsquo;<samp><span class="samp">"Java"</span></samp>&rsquo;, is not permitted.

   <p>Note that the Melbourne Mercury implementation often implicitly inserts
&lsquo;<samp><span class="samp">pragma foreign_import_module</span></samp>&rsquo; declarations but programmers should
<em>not</em> write code that depends upon this behaviour;
&lsquo;<samp><span class="samp">pragma foreign_import_module</span></samp>&rsquo; declarations should always be explicitly
included if needed.

<div class="node">
<a name="Adding-foreign-definitions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Language-specific-bindings">Language specific bindings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Adding-foreign-declarations">Adding foreign declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-language-interface">Foreign language interface</a>

</div>

<h3 class="section">14.8 Adding foreign definitions</h3>

<p>Definitions of foreign language entities (such as functions or global
variables) may be included using a declaration of the form

<pre class="example">     :- pragma foreign_code("<var>Lang</var>", <var>Code</var>).
</pre>
   <p>This declaration will have effects equivalent to including the specified
<var>Code</var> in an automatically-generated source file of the specified
programming language, in a place appropriate for definitions,
and linking that source file with the Mercury program
(after having compiled it with a compiler for the specified programming
language, if appropriate).

   <p>Entities declared in &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo; declarations are
visible in &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; declarations that specify the same
foreign language and occur in the same Mercury module.

<!--  -->
<div class="node">
<a name="Language-specific-bindings"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Adding-foreign-definitions">Adding foreign definitions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-language-interface">Foreign language interface</a>

</div>

<h3 class="section">14.9 Language specific bindings</h3>

<!-- Please keep this menu in alphabetical order -->
<ul class="menu">
<li><a accesskey="1" href="#Interfacing-with-C">Interfacing with C	</a>:  How to write code to interface with C
<li><a accesskey="2" href="#Interfacing-with-C_0023">Interfacing with C#	</a>:  How to write code to interface with C#
<li><a accesskey="3" href="#Interfacing-with-Java">Interfacing with Java	</a>:  How to write code to interface with Java
<li><a accesskey="4" href="#Interfacing-with-Erlang">Interfacing with Erlang	</a>:  How to write code to interface with Erlang
</ul>

<p>All Mercury implementations should support interfacing with C. 
The set of other languages supported is implementation-defined. 
A suitable compiler or assembler for the foreign language
must be available on the system.

   <p>The University of Melbourne Mercury implementation supports
interfacing with the following languages:

     <dl>
<!-- Please keep this table in alphabetical order -->

     <dt>&lsquo;<samp><span class="samp">C</span></samp>&rsquo;<dd>Use the string <code>"C"</code> to set the foreign language to C.

     <br><dt>&lsquo;<samp><span class="samp">C#</span></samp>&rsquo;<dd>Use the string <code>"C#"</code> to set the foreign language to C#.

     <br><dt>&lsquo;<samp><span class="samp">Java</span></samp>&rsquo;<dd>Use the string <code>"Java"</code> to set the foreign language to Java.

     <br><dt>&lsquo;<samp><span class="samp">Erlang</span></samp>&rsquo;<dd>Use the string <code>"Erlang"</code> to set the foreign language to Erlang.

   </dl>

<!--  -->
<div class="node">
<a name="Interfacing-with-C"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Interfacing-with-C_0023">Interfacing with C#</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Language-specific-bindings">Language specific bindings</a>

</div>

<h4 class="subsection">14.9.1 Interfacing with C</h4>

<ul class="menu">
<li><a accesskey="1" href="#Using-pragma-foreign_005ftype-for-C">Using pragma foreign_type for C </a>:  Declaring C types in Mercury
<li><a accesskey="2" href="#Using-pragma-foreign_005fexport_005fenum-for-C">Using pragma foreign_export_enum for C </a>:  Using Mercury enumerations in C
<li><a accesskey="3" href="#Using-pragma-foreign_005fenum-for-C">Using pragma foreign_enum for C </a>:  Assigning Mercury enumerations
                                            values in C
<li><a accesskey="4" href="#Using-pragma-foreign_005fproc-for-C">Using pragma foreign_proc for C </a>:  Calling C code from Mercury
<li><a accesskey="5" href="#Using-pragma-foreign_005fexport-for-C">Using pragma foreign_export for C </a>:  Calling Mercury code from C
<li><a accesskey="6" href="#Using-pragma-foreign_005fdecl-for-C">Using pragma foreign_decl for C </a>:  Including C declarations in Mercury
<li><a accesskey="7" href="#Using-pragma-foreign_005fcode-for-C">Using pragma foreign_code for C </a>:  Including C code in Mercury
<li><a accesskey="8" href="#Memory-management-for-C">Memory management for C </a>:  Caveats about passing dynamically
                                            allocated memory to or from C. 
<li><a accesskey="9" href="#Linking-with-C-object-files">Linking with C object files </a>:  Linking with C object files and
                                            libraries.

</ul>

<div class="node">
<a name="Using-pragma-foreign_type-for-C"></a>
<a name="Using-pragma-foreign_005ftype-for-C"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fexport_005fenum-for-C">Using pragma foreign_export_enum for C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C">Interfacing with C</a>

</div>

<h5 class="subsubsection">14.9.1.1 Using pragma foreign_type for C</h5>

<p>A C &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; declaration has the form:

<pre class="example">     :- pragma foreign_type("C", <var>MercuryTypeName</var>, "<var>CForeignType</var>").
</pre>
   <p>For example,

<pre class="example">     :- pragma foreign_type("C", long_double, "long double").
</pre>
   <p>The <var>CForeignType</var> can be any C type name that obeys the following
restrictions. 
Function types, array types, and incomplete types are not allowed. 
The type name must be such that when declaring a variable in C of that
type, that no part of the type name is required after the variable name. 
(This rule prohibits, for example, function pointer types such as
&lsquo;<samp><span class="samp">void (*)(void)</span></samp>&rsquo;.  However, it would be OK to use a typedef name
which was defined as a function pointer type.)

   <p>C preprocessor directives (such as &lsquo;<samp><span class="samp">#if</span></samp>&rsquo;) may not be used in
<var>CForeignType</var>.  (You can however use a typedef name that refers
to a type defined in a &lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declaration, and
the &lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declaration may contain C preprocessor
directives.)

   <p><strong>With &lsquo;</strong><samp><span class="samp">--gc accurate</span></samp><strong>&rsquo;, foreign_types which are C pointer types
must not point to the Mercury heap.</strong>

   <p>If the <var>MercuryTypeName</var> is the type of a parameter of a procedure
defined using &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo;,
it will be passed to the foreign_proc's foreign language code
as <var>CForeignType</var>.

   <p>Furthermore, any Mercury procedure exported with &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo;
will use <var>CForeignType</var> as the type for any
parameters whose Mercury type is <var>MercuryTypeName</var>.

   <p>The builtin Mercury type <code>c_pointer</code> may be used to pass C pointers
between C functions which are called from Mercury.  For example:

<pre class="example">     :- module pointer_example.
     :- interface.
     
     :- type complicated_c_structure.
     
     % Initialise the abstract C structure that we pass around in Mercury.
     :- pred initialise_complicated_structure(complicated_c_structure::uo) is det.
     
     % Perform a calculation on the C structure.
     :- pred do_calculation(int::in, complicated_c_structure::di,
             complicated_c_structure::uo) is det.
     
     :- implementation.
     
     % Our C structure is implemented as a c_pointer.
     :- type complicated_c_structure
         ---&gt;    complicated_c_structure(c_pointer).
     
     :- pragma foreign_decl("C",
        extern struct foo *init_struct(void);
        extern struct foo *perform_calculation(int, struct foo *);
     ");
     
     :- pragma foreign_proc("C",
         initialise_complicated_structure(Structure::uo),
         [will_not_call_mercury, may_call_mercury],
     "
         Structure = init_struct();
     ").
     
     :- pragma foreign_proc("C",
         do_calculation(Value::in, Structure0::di, Structure::uo),
         [will_not_call_mercury, may_call_mercury],
     "
         Structure = perform_calculation(Value, Structure0);
     ").
</pre>
   <p>We strongly recommend the use of &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; instead of
<code>c_pointer</code> as the use of &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; results in
more type-safe code.

<div class="node">
<a name="Using-pragma-foreign_export_enum-for-C"></a>
<a name="Using-pragma-foreign_005fexport_005fenum-for-C"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fenum-for-C">Using pragma foreign_enum for C</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005ftype-for-C">Using pragma foreign_type for C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C">Interfacing with C</a>

</div>

<h5 class="subsubsection">14.9.1.2 Using pragma foreign_export_enum for C</h5>

<p>For C the symbolic names generated by a &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo;
must form valid C identifiers. 
These identifiers are used as the names of preprocessor macros. 
The body of each of these macros expands to a value that is identical
to that of the constructor to which the symbolic name corresponds in
the mapping established by the &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo;
declaration.

   <p>As noted in the <a href="#C-data-passing-conventions">C data passing conventions</a>, the type of these
values is &lsquo;<samp><span class="samp">MR_Word</span></samp>&rsquo;.

   <p>The default mapping used by &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo;
declarations for C is to use the Mercury constructor name as the
base of the symbolic name.  For example, the symbolic name for
the Mercury constructor &lsquo;<samp><span class="samp">foo</span></samp>&rsquo; would be <code>foo</code>.

<!-- It would be useful if there were some documented way of mapping -->
<!-- these things into [0, N - 1], e.g. for array lookups. -->
<div class="node">
<a name="Using-pragma-foreign_enum-for-C"></a>
<a name="Using-pragma-foreign_005fenum-for-C"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fproc-for-C">Using pragma foreign_proc for C</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fexport_005fenum-for-C">Using pragma foreign_export_enum for C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C">Interfacing with C</a>

</div>

<h5 class="subsubsection">14.9.1.3 Using pragma foreign_enum for C</h5>

<p>Foreign enumeration values in C must be constants of type &lsquo;<samp><span class="samp">MR_Integer</span></samp>&rsquo;. 
They may be specified as either integer literals or via preprocessor macros
that expand to integer literals.

<div class="node">
<a name="Using-pragma-foreign_proc-for-C"></a>
<a name="Using-pragma-foreign_005fproc-for-C"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fexport-for-C">Using pragma foreign_export for C</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fenum-for-C">Using pragma foreign_enum for C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C">Interfacing with C</a>

</div>

<h5 class="subsubsection">14.9.1.4 Using pragma foreign_proc for C</h5>

<p>The input and output variables will have C types corresponding
to their Mercury types, as determined by the rules specified in
<a href="#C-data-passing-conventions">C data passing conventions</a>.

   <p>The C code fragment may declare local variables,
up to a total size of 10kB for the procedure. 
<!-- The relevant parameter is LOCALS_SIZE, defined in runtime/mercury_engine.c. -->
If a procedure requires more than this for its local variables,
the code can be moved into a separate function
(defined in a &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo; declaration, for example).

   <p>The C code fragment should not declare any labels or static variables unless
there is also a &lsquo;<samp><span class="samp">pragma no_inline</span></samp>&rsquo; declaration or a
&lsquo;<samp><span class="samp">may_not_duplicate</span></samp>&rsquo; foreign code attribute for the procedure. 
The reason for this is that otherwise the Mercury implementation may inline
the procedure by duplicating the C code fragment for each call. 
If the C code fragment declared a static variable, inlining it in this way
could result in the program having multiple instances of the static variable,
rather than a single shared instance. 
If the C code fragment declared a label, inlining it in this way could result
in an error due to the same label being defined twice inside a single C
function.

   <p>C code in a <code>pragma foreign_proc</code> declaration for any procedure whose
determinism indicates that it can fail must assign a truth value to the macro
&lsquo;<samp><span class="samp">SUCCESS_INDICATOR</span></samp>&rsquo;. 
For example:

<pre class="example">     :- pred string.contains_char(string, character).
     :- mode string.contains_char(in, in) is semidet.
     
     :- pragma foreign_proc("C",
     	string.contains_char(Str::in, Ch::in),
             [will_not_call_mercury, promise_pure],
             "SUCCESS_INDICATOR = (strchr(Str, Ch) != NULL);").
</pre>
   <p><code>SUCCESS_INDICATOR</code> should not be used other than as the target of
an assignment. 
(For example, it may be <code>#define</code>d to a register, so you should not
try to take its address.) 
Procedures whose determinism indicates that they cannot fail
should not access <code>SUCCESS_INDICATOR</code>.

   <p>Arguments whose mode is input will have their values set by the Mercury
implementation on entry to the C code. 
If the procedure succeeds, the C code must set the values of all output
arguments. 
If the procedure fails, the C code need only set <code>SUCCESS_INDICATOR</code> to
false (zero).

   <p>The behaviour of a procedure defined using a &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo;
declaration whose body contains a &lsquo;<samp><span class="samp">return</span></samp>&rsquo; statement is undefined.

<div class="node">
<a name="Using-pragma-foreign_export-for-C"></a>
<a name="Using-pragma-foreign_005fexport-for-C"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fdecl-for-C">Using pragma foreign_decl for C</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fproc-for-C">Using pragma foreign_proc for C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C">Interfacing with C</a>

</div>

<h5 class="subsubsection">14.9.1.5 Using pragma foreign_export for C</h5>

<p>A &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declaration for C has the form:

<pre class="example">     :- pragma foreign_export("C", <var>MercuryMode</var>, "<var>C_Name</var>").
</pre>
   <p>For example,

<pre class="example">     :- pragma foreign_export("C", foo(in, in, out), "FOO").
</pre>
   <p>For each Mercury module containing &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declarations
for C, the Mercury implementation will automatically create a header file for
that module which declares a C function <var>C_Name</var>() for each of the
&lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declarations.  Each such C function is the C
interface to the specified Mercury procedure.

   <p>The type signature of the C interface to a Mercury procedure is determined as
follows.  Mercury types are converted to C types according to the rules in
<a href="#C-data-passing-conventions">C data passing conventions</a>.  Input arguments are passed by value. 
For output arguments, the caller must pass the address in which to store the
result.  If the Mercury procedure can fail, then its C interface function
returns a truth value indicating success or failure.  If the Mercury procedure
is a Mercury function that cannot fail, and the function result has an output
mode, then the C interface function will return the Mercury function result
value.  Otherwise the function result is appended as an extra argument. 
<!-- XXX We need to update this for dummy unit types. -->
Arguments of type &lsquo;<samp><span class="samp">io.state</span></samp>&rsquo; or &lsquo;<samp><span class="samp">store.store(_)</span></samp>&rsquo; are not passed
at all.  (The reason for this is that these types represent mutable state,
and in C modifications to mutable state are done via side effects, rather than
argument passing.)

   <p>Calling polymorphically typed Mercury procedures from C is a little bit more
difficult than calling ordinary (monomorphically typed) Mercury procedures. 
The simplest method is to just create monomorphic forwarding procedures that
call the polymorphic procedures, and export them, rather than exporting the
polymorphic procedures.

   <p>If you do export a polymorphically typed Mercury procedure, the compiler will
prepend one &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; argument to the parameter list of the C interface
function for each distinct type variable in the Mercury procedure's type
signature. 
The caller must arrange to pass in appropriate &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; values
corresponding to the types of the other arguments passed. 
These &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; arguments can be obtained using the Mercury
&lsquo;<samp><span class="samp">type_of</span></samp>&rsquo; function in the Mercury standard library module
&lsquo;<samp><span class="samp">type_desc</span></samp>&rsquo;.

   <p>To use the C declarations produced see <a href="#Using-pragma-foreign_005fdecl-for-C">Using pragma foreign_decl for C</a>.

<div class="node">
<a name="Using-pragma-foreign_decl-for-C"></a>
<a name="Using-pragma-foreign_005fdecl-for-C"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fcode-for-C">Using pragma foreign_code for C</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fexport-for-C">Using pragma foreign_export for C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C">Interfacing with C</a>

</div>

<h5 class="subsubsection">14.9.1.6 Using pragma foreign_decl for C</h5>

<p>Any macros, function prototypes, or other C declarations
that are used in &lsquo;<samp><span class="samp">foreign_code</span></samp>&rsquo;, &lsquo;<samp><span class="samp">foreign_type</span></samp>&rsquo;
or &lsquo;<samp><span class="samp">foreign_proc</span></samp>&rsquo; pragmas must be included using a
&lsquo;<samp><span class="samp">foreign_decl</span></samp>&rsquo; declaration of the form

<pre class="example">     :- pragma foreign_decl("C", <var>HeaderCode</var>).
</pre>
   <p class="noindent"><var>HeaderCode</var> can be a C &lsquo;<samp><span class="samp">#include</span></samp>&rsquo; line, for example

<pre class="example">     :- pragma foreign_decl("C", "#include &lt;math.h&gt;")
</pre>
   <p class="noindent">or

<pre class="example">     :- pragma foreign_decl("C", "#include ""tcl.h""").
</pre>
   <p class="noindent">or it may contain any C declarations, for example

<pre class="example">     :- pragma foreign_decl("C", "
             extern int errno;
             #define SIZE 200
             struct Employee {
                     char name[SIZE];
             };
             extern int bar;
             extern void foo(void);
     ").
</pre>
   <p>Mercury automatically includes certain headers such as <code>&lt;stdlib.h&gt;</code>,
but you should not rely on this, as the set of headers which Mercury
automatically includes is subject to change.

   <p>If a Mercury predicate or function exported using
a &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declaration is to be used within a
&lsquo;<samp><span class="samp">:- pragma foreign_code</span></samp>&rsquo; or &lsquo;<samp><span class="samp">:- pragma foreign_proc</span></samp>&rsquo;
declaration the header file for the module containing the
&lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declaration should be included using a
&lsquo;<samp><span class="samp">pragma foreign_import_module</span></samp>&rsquo; declaration, for example

<pre class="example">     :- pragma foreign_import_module("C", exporting_module).
</pre>
   <div class="node">
<a name="Using-pragma-foreign_code-for-C"></a>
<a name="Using-pragma-foreign_005fcode-for-C"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Memory-management-for-C">Memory management for C</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fdecl-for-C">Using pragma foreign_decl for C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C">Interfacing with C</a>

</div>

<h5 class="subsubsection">14.9.1.7 Using pragma foreign_code for C</h5>

<p>Definitions of C functions or global variables may be
included using a declaration of the form

<pre class="example">     :- pragma foreign_code("C", <var>Code</var>).
</pre>
   <p>For example,

<pre class="example">     :- pragma foreign_code("C", "
             int bar = 42;
             void foo(void) {}
     ").
</pre>
   <p>Such code is copied verbatim into the generated C file.

<div class="node">
<a name="Memory-management-for-C"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Linking-with-C-object-files">Linking with C object files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fcode-for-C">Using pragma foreign_code for C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C">Interfacing with C</a>

</div>

<h5 class="subsubsection">14.9.1.8 Memory management for C</h5>

<p>Passing pointers to dynamically-allocated memory from Mercury to code
written in other languages, or vice versa, is in general
implementation-dependent.

   <p>The current Mercury implementation supports two different methods of memory
management: conservative garbage collection, or no garbage collection. 
(With the latter method, heap storage is reclaimed only on backtracking.)

   <p>Conservative garbage collection makes inter-language calls simplest. 
When using conservative garbage collection, heap storage is reclaimed
automatically.  Pointers to dynamically-allocated memory can be passed
to and from C without taking any special precautions.

   <p>When using no garbage collection, you must be careful not to retain
pointers to memory on the Mercury heap after Mercury has backtracked
to before the point where that memory was allocated. 
You must also avoid the use of the macros
<code>MR_list_empty()</code> and <code>MR_list_cons()</code>. 
(The reason for this is that they may access Mercury's &lsquo;<samp><span class="samp">MR_hp</span></samp>&rsquo; register,
which might not be valid in C code.  Using them in the bodies of
procedures defined using &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; with
&lsquo;<samp><span class="samp">will_not_call_mercury</span></samp>&rsquo; would probably work, but we don't advise it.) 
Instead, you can write Mercury functions to perform these actions
and use &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; to access them from C. 
This alternative method also works with conservative garbage collection.

   <p>Future Mercury implementations may use non-conservative methods
of garbage collection.  For such implementations, it will be necessary
to explicitly register pointers passed to C with the garbage collector. 
The mechanism for doing this has not yet been decided on. 
It would be desirable to provide a single memory management interface
for use when interfacing with other languages that can work for all
methods of memory management, but more implementation experience is
needed before we can formulate such an interface.

<div class="node">
<a name="Linking-with-C-object-files"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Memory-management-for-C">Memory management for C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C">Interfacing with C</a>

</div>

<h5 class="subsubsection">14.9.1.9 Linking with C object files</h5>

<p>A Mercury implementation should allow you to link with object files or
libraries that were produced by compiling C code. 
The exact mechanism for linking with C object files is
implementation-dependent. 
The following text describes how it is done for the University of Melbourne
Mercury implementation.

   <p>To link an existing object file into your Mercury code, use the command line
option &lsquo;<samp><span class="samp">--link-object</span></samp>&rsquo;. 
For example, the following will link the object file &lsquo;<samp><span class="samp">my_function.o</span></samp>&rsquo; from
the current directory when compiling the program &lsquo;<samp><span class="samp">prog</span></samp>&rsquo;:

<pre class="example">     mmc --link-object my_functions.o prog
</pre>
   <p>The command line option &lsquo;<samp><span class="samp">--library</span></samp>&rsquo; (or &lsquo;<samp><span class="samp">-l</span></samp>&rsquo; for short)
can be used to link an existing library into your Mercury code. 
For example, the following will link the library file &lsquo;<samp><span class="samp">libfancy_library.a</span></samp>&rsquo;,
or perhaps the shared version &lsquo;<samp><span class="samp">libfancy_library.so</span></samp>&rsquo;, from the directory
&lsquo;<samp><span class="samp">/usr/local/contrib/lib</span></samp>&rsquo;, when compiling the program &lsquo;<samp><span class="samp">prog</span></samp>&rsquo;:

<pre class="example">     mmc -R/usr/local/contrib/lib -L/usr/local/contrib/lib --lfancy_library prog
</pre>
   <p>As illustrated by the example, the command line options &lsquo;<samp><span class="samp">-R</span></samp>&rsquo;, &lsquo;<samp><span class="samp">-L</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">-l</span></samp>&rsquo;, have the same meaning as they do with the Unix linker.

   <p>For more information, see the &ldquo;Libraries&rdquo; chapter of the
Mercury User's Guide.

<!--  -->
<div class="node">
<a name="Interfacing-with-C%23"></a>
<a name="Interfacing-with-C_0023"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Interfacing-with-Java">Interfacing with Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Interfacing-with-C">Interfacing with C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Language-specific-bindings">Language specific bindings</a>

</div>

<h4 class="subsection">14.9.2 Interfacing with C#</h4>

<ul class="menu">
<li><a accesskey="1" href="#Using-pragma-foreign_005ftype-for-C_0023">Using pragma foreign_type for C#	</a>:  Declaring C# types in Mercury
<li><a accesskey="2" href="#Using-pragma-foreign_005fexport_005fenum-for-C_0023">Using pragma foreign_export_enum for C# </a>:  Using Mercury enumerations in C#
<li><a accesskey="3" href="#Using-pragma-foreign_005fenum-for-C_0023">Using pragma foreign_enum for C# </a>:  Assigning Mercury enumerations
                                           values in C#
<li><a accesskey="4" href="#Using-pragma-foreign_005fproc-for-C_0023">Using pragma foreign_proc for C#	</a>:  Calling C# code from Mercury
<li><a accesskey="5" href="#Using-pragma-foreign_005fexport-for-C_0023">Using pragma foreign_export for C# </a>:  Calling Mercury code from C#
<li><a accesskey="6" href="#Using-pragma-foreign_005fdecl-for-C_0023">Using pragma foreign_decl for C#	</a>:  Including C# declarations in Mercury
<li><a accesskey="7" href="#Using-pragma-foreign_005fcode-for-C_0023">Using pragma foreign_code for C#	</a>:  Including C# code in Mercury
</ul>

<div class="node">
<a name="Using-pragma-foreign_type-for-C%23"></a>
<a name="Using-pragma-foreign_005ftype-for-C_0023"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fexport_005fenum-for-C_0023">Using pragma foreign_export_enum for C#</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C_0023">Interfacing with C#</a>

</div>

<h5 class="subsubsection">14.9.2.1 Using pragma foreign_type for C#</h5>

<p>A C# &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; declaration has the form:

<pre class="example">     :- pragma foreign_type("C#", <var>MercuryTypeName</var>, "<var>C#-Type</var>").
</pre>
   <p>The <var>C#-Type</var> can be any accessible C# type.

   <p>The effect of this declaration is that Mercury values of type
<var>MercuryTypeName</var> will be passed to and from C# foreign_procs
as having type <var>C#-Type</var>.

   <p>Furthermore, any Mercury procedure exported with &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo;
will use <var>C#-Type</var> as the type for any
parameters whose Mercury type is <var>MercuryTypeName</var>.

<div class="node">
<a name="Using-pragma-foreign_export_enum-for-C%23"></a>
<a name="Using-pragma-foreign_005fexport_005fenum-for-C_0023"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fenum-for-C_0023">Using pragma foreign_enum for C#</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005ftype-for-C_0023">Using pragma foreign_type for C#</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C_0023">Interfacing with C#</a>

</div>

<h5 class="subsubsection">14.9.2.2 Using pragma foreign_export_enum for C#</h5>

<p>For C# the symbolic names generated by a &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo;
must form valid C# identifiers. 
These identifiers are used as the names of static class members.

   <p>The default mapping used by &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo;
declarations for C# is to use the Mercury constructor name as the
base of the symbolic name.  For example, the symbolic name for
the Mercury constructor &lsquo;<samp><span class="samp">foo</span></samp>&rsquo; would be <code>foo</code>.

<div class="node">
<a name="Using-pragma-foreign_enum-for-C%23"></a>
<a name="Using-pragma-foreign_005fenum-for-C_0023"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fproc-for-C_0023">Using pragma foreign_proc for C#</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fexport_005fenum-for-C_0023">Using pragma foreign_export_enum for C#</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C_0023">Interfacing with C#</a>

</div>

<h5 class="subsubsection">14.9.2.3 Using pragma foreign_enum for C#</h5>

<p>Foreign enumeration values in C# must be a constant value expression
which is a valid initializer within an enumeration of underlying
type &lsquo;<samp><span class="samp">int</span></samp>&rsquo;.

<div class="node">
<a name="Using-pragma-foreign_proc-for-C%23"></a>
<a name="Using-pragma-foreign_005fproc-for-C_0023"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fexport-for-C_0023">Using pragma foreign_export for C#</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fenum-for-C_0023">Using pragma foreign_enum for C#</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C_0023">Interfacing with C#</a>

</div>

<h5 class="subsubsection">14.9.2.4 Using pragma foreign_proc for C#</h5>

<p>The C# code from C# pragma foreign_proc declarations will be placed in
the bodies of static member functions of an automatically-generated C# class. 
Since such C# code will become part of a static member function,
it must not refer to the &lsquo;<samp><span class="samp">this</span></samp>&rsquo; keyword. 
It may however refer to static member variables or static member
functions declared with &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo;.

   <p>The input and output variables for a C# &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; will
have C# types corresponding to their Mercury types.  The exact rules
for mapping Mercury types to C# types are described in
<a href="#C_0023-data-passing-conventions">C# data passing conventions</a>.

   <p>C# code in a <code>pragma foreign_proc</code> declaration
for any procedure whose determinism indicates that it can fail
must assign a value of type &lsquo;<samp><span class="samp">bool</span></samp>&rsquo; to the variable
&lsquo;<samp><span class="samp">SUCCESS_INDICATOR</span></samp>&rsquo;.  For example:

<pre class="example">     :- pred string.contains_char(string, character).
     :- mode string.contains_char(in, in) is semidet.
     
     :- pragma foreign_proc("C#",
     	string.contains_char(Str::in, Ch::in),
             [will_not_call_mercury, promise_pure],
             "SUCCESS_INDICATOR = (Str.IndexOf(Ch) != -1);").
</pre>
   <p class="noindent">C# code for procedures whose determinism indicates that they cannot fail
should not access <code>SUCCESS_INDICATOR</code>.

   <p>Arguments whose mode is input will have their values set by the
Mercury implementation on entry to the C# code.  If the procedure
succeeds, the C# code must set the values of all output arguments. 
If the procedure fails, the C# code need only
set <code>SUCCESS_INDICATOR</code> to false.

<div class="node">
<a name="Using-pragma-foreign_export-for-C%23"></a>
<a name="Using-pragma-foreign_005fexport-for-C_0023"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fdecl-for-C_0023">Using pragma foreign_decl for C#</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fproc-for-C_0023">Using pragma foreign_proc for C#</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C_0023">Interfacing with C#</a>

</div>

<h5 class="subsubsection">14.9.2.5 Using pragma foreign_export for C#</h5>

<p>A &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declaration for C# has the form:

<pre class="example">     :- pragma foreign_export("C#", <var>MercuryMode</var>, "<var>C#_Name</var>").
</pre>
   <p>For example,

<pre class="example">     :- pragma foreign_export("C#", foo(in, in, out), "FOO").
</pre>
   <p>The type signature of the C# interface to a Mercury procedure is as
described in <a href="#C_0023-data-passing-conventions">C# data passing conventions</a>.

   <p>Calling polymorphically typed Mercury procedures from C# is a little bit more
difficult than calling ordinary (monomorphically typed) Mercury procedures. 
The simplest method is to just create monomorphic forwarding procedures that
call the polymorphic procedures, and export them, rather than exporting the
polymorphic procedures.

   <p>If you do export a polymorphically typed Mercury procedure, the compiler will
prepend one &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; argument to the parameter list of the C# interface
function for each distinct type variable in the Mercury procedure's type
signature. 
The caller must arrange to pass in appropriate &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; values
corresponding to the types of the other arguments passed. 
These &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; arguments can be obtained using the Mercury
&lsquo;<samp><span class="samp">type_of</span></samp>&rsquo; function in the Mercury standard library module
&lsquo;<samp><span class="samp">type_desc</span></samp>&rsquo;.

<div class="node">
<a name="Using-pragma-foreign_decl-for-C%23"></a>
<a name="Using-pragma-foreign_005fdecl-for-C_0023"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fcode-for-C_0023">Using pragma foreign_code for C#</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fexport-for-C_0023">Using pragma foreign_export for C#</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C_0023">Interfacing with C#</a>

</div>

<h5 class="subsubsection">14.9.2.6 Using pragma foreign_decl for C#</h5>

<p>&lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declarations for C# can be used to provide
any top-level C# declarations (e.g. &lsquo;<samp><span class="samp">using</span></samp>&rsquo; declarations
or auxiliary class definitions) which are needed by C# code in
&lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; declarations in that module.

   <p>For example:

<pre class="example">     :- pragma foreign_decl("C#", "
     	using System;
     ").
     :- pred hello(io.state::di, io.state::uo) is det.
     :- pragma foreign_proc("C#",
     	hello(_IO0::di, _IO::uo),
     	[will_not_call_mercury],
     "
     	// here we can refer directly to Console rather than System.Console
     	Console.WriteLine(""hello world"");
     ").
</pre>
   <div class="node">
<a name="Using-pragma-foreign_code-for-C%23"></a>
<a name="Using-pragma-foreign_005fcode-for-C_0023"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fdecl-for-C_0023">Using pragma foreign_decl for C#</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-C_0023">Interfacing with C#</a>

</div>

<h5 class="subsubsection">14.9.2.7 Using pragma foreign_code for C#</h5>

<p>The C# code from &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; declarations for C# will be
placed in the bodies of static member functions of an
automatically-generated C# class.  &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo;
can be used to define additional members of this automatically-generated
class, which can then be referenced by &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo;
declarations for C# from that module.

   <p>For example:

<pre class="example">     :- pragma foreign_code("C#", "
     	static int counter = 0;
     ").
     
     :- impure pred incr_counter is det.
     :- pragma foreign_proc("C#", incr_counter,
     	[will_not_call_mercury], "counter++;").
     
     :- semipure func get_counter = int.
     :- pragma foreign_proc("C#",
     	get_counter = (Result::out),
     	[will_not_call_mercury, promise_semipure],
     	"Result = counter;").
</pre>
   <!--  -->
<div class="node">
<a name="Interfacing-with-Java"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Interfacing-with-Erlang">Interfacing with Erlang</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Interfacing-with-C_0023">Interfacing with C#</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Language-specific-bindings">Language specific bindings</a>

</div>

<h4 class="subsection">14.9.3 Interfacing with Java</h4>

<ul class="menu">
<li><a accesskey="1" href="#Using-pragma-foreign_005ftype-for-Java">Using pragma foreign_type for Java </a>:  Declaring Java types in Mercury
<li><a accesskey="2" href="#Using-pragma-foreign_005fexport_005fenum-for-Java">Using pragma foreign_export_enum for Java </a>:  Using Mercury enumerations in
                                               Java
<li><a accesskey="3" href="#Using-pragma-foreign_005fenum-for-Java">Using pragma foreign_enum for Java </a>:  Assigning Mercury enumerations
                                        values in Java
<li><a accesskey="4" href="#Using-pragma-foreign_005fproc-for-Java">Using pragma foreign_proc for Java </a>:  Calling Java code from Mercury
<li><a accesskey="5" href="#Using-pragma-foreign_005fexport-for-Java">Using pragma foreign_export for Java </a>:  Calling Mercury from Java code
<li><a accesskey="6" href="#Using-pragma-foreign_005fdecl-for-Java">Using pragma foreign_decl for Java </a>:  Including Java declarations in Mercury
<li><a accesskey="7" href="#Using-pragma-foreign_005fcode-for-Java">Using pragma foreign_code for Java </a>:  Including Java code in Mercury
</ul>

<div class="node">
<a name="Using-pragma-foreign_type-for-Java"></a>
<a name="Using-pragma-foreign_005ftype-for-Java"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fexport_005fenum-for-Java">Using pragma foreign_export_enum for Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Java">Interfacing with Java</a>

</div>

<h5 class="subsubsection">14.9.3.1 Using pragma foreign_type for Java</h5>

<p>A Java &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; declaration has the form:

<pre class="example">     :- pragma foreign_type("Java", <var>MercuryTypeName</var>, "<var>JavaType</var>").
</pre>
   <p>The <var>JavaType</var> can be any accessible non-primitive Java type.

   <p>The effect of this declaration is that Mercury values of type
<var>MercuryTypeName</var> will be passed to and from Java foreign_procs
as having type <var>JavaType</var>.

   <p>Furthermore, any Mercury procedure exported with &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo;
will use <var>JavaType</var> as the type for any
parameters whose Mercury type is <var>MercuryTypeName</var>.

<div class="node">
<a name="Using-pragma-foreign_export_enum-for-Java"></a>
<a name="Using-pragma-foreign_005fexport_005fenum-for-Java"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fenum-for-Java">Using pragma foreign_enum for Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005ftype-for-Java">Using pragma foreign_type for Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Java">Interfacing with Java</a>

</div>

<h5 class="subsubsection">14.9.3.2 Using pragma foreign_export_enum for Java</h5>

<p>For Java the symbolic names generated by a &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo;
must form valid Java identifiers. 
These identifiers are used as the names of static class members
which are assigned instances of the enumeration class.

   <p>The &lsquo;<samp><span class="samp">equals</span></samp>&rsquo; method should be used for equality testing of enumeration
values in Java code.

   <p>The default mapping used by &lsquo;<samp><span class="samp">pragma foreign_export_enum</span></samp>&rsquo;
declarations for Java is to use the Mercury constructor name as the
base of the symbolic name.  For example, the symbolic name for
the Mercury constructor &lsquo;<samp><span class="samp">foo</span></samp>&rsquo; would be <code>foo</code>.

<div class="node">
<a name="Using-pragma-foreign_enum-for-Java"></a>
<a name="Using-pragma-foreign_005fenum-for-Java"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fproc-for-Java">Using pragma foreign_proc for Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fexport_005fenum-for-Java">Using pragma foreign_export_enum for Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Java">Interfacing with Java</a>

</div>

<h5 class="subsubsection">14.9.3.3 Using pragma foreign_enum for Java</h5>

<p>&lsquo;<samp><span class="samp">pragma foreign_enum</span></samp>&rsquo; is currently not supported for Java.

<div class="node">
<a name="Using-pragma-foreign_proc-for-Java"></a>
<a name="Using-pragma-foreign_005fproc-for-Java"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fexport-for-Java">Using pragma foreign_export for Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fenum-for-Java">Using pragma foreign_enum for Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Java">Interfacing with Java</a>

</div>

<h5 class="subsubsection">14.9.3.4 Using pragma foreign_proc for Java</h5>

<p>The Java code from Java pragma foreign_proc declarations will be placed in
the bodies of static member functions of an automatically-generated Java class. 
Since such Java code will become part of a static member function,
it must not refer to the &lsquo;<samp><span class="samp">this</span></samp>&rsquo; keyword. 
It may however refer to static member variables or static member
functions declared with &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo;.

   <p>The input and output variables for a Java &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; will
have Java types corresponding to their Mercury types.  The exact rules
for mapping Mercury types to Java types are described in
<a href="#Java-data-passing-conventions">Java data passing conventions</a>.

   <p>The Java code in a <code>pragma foreign_proc</code> declaration
for a procedure whose determinism indicates that it can fail
must assign a value of type &lsquo;<samp><span class="samp">boolean</span></samp>&rsquo; to the variable
&lsquo;<samp><span class="samp">SUCCESS_INDICATOR</span></samp>&rsquo;.  For example:

<pre class="example">     :- pred string.contains_char(string, character).
     :- mode string.contains_char(in, in) is semidet.
     
     :- pragma foreign_proc("Java",
     	string.contains_char(Str::in, Ch::in),
             [will_not_call_mercury, promise_pure],
             "SUCCESS_INDICATOR = (Str.IndexOf(Ch) != -1);").
</pre>
   <p class="noindent">Java code for procedures whose determinism indicates that they cannot fail
should not refer to the <code>SUCCESS_INDICATOR</code> variable.

   <p>Arguments whose mode is input will have their values set by the
Mercury implementation on entry to the Java code. 
With our current implementation, the Java code must set the values
of all output variables, even if the procedure fails
(i.e. sets the &lsquo;<samp><span class="samp">SUCCESS_INDICATOR</span></samp>&rsquo; variable to <code>false</code>). 
<!-- If the procedure -->
<!-- succeeds, the Java code must set the values of all output arguments -->
<!-- If the procedure fails, the Java code need only -->
<!-- set the @code{SUCCESS_INDICATOR} variable to false. -->

<div class="node">
<a name="Using-pragma-foreign_export-for-Java"></a>
<a name="Using-pragma-foreign_005fexport-for-Java"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fdecl-for-Java">Using pragma foreign_decl for Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fproc-for-Java">Using pragma foreign_proc for Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Java">Interfacing with Java</a>

</div>

<h5 class="subsubsection">14.9.3.5 Using pragma foreign_export for Java</h5>

<p>A &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declaration for Java has the form:

<pre class="example">     :- pragma foreign_export("Java", <var>MercuryMode</var>, "<var>Java_Name</var>").
</pre>
   <p>For example,

<pre class="example">     :- pragma foreign_export("Java", foo(in, in, out), "FOO").
</pre>
   <p>The type signature of the Java interface to a Mercury procedure is as
described in <a href="#Java-data-passing-conventions">Java data passing conventions</a>.

   <p>Calling polymorphically typed Mercury procedures from Java is a little bit more
difficult than calling ordinary (monomorphically typed) Mercury procedures. 
The simplest method is to just create monomorphic forwarding procedures that
call the polymorphic procedures, and export them, rather than exporting the
polymorphic procedures.

   <p>If you do export a polymorphically typed Mercury procedure, the compiler will
prepend one &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; argument to the parameter list of the Java
interface function for each distinct type variable in the Mercury procedure's
type signature. 
The caller must arrange to pass in appropriate &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; values
corresponding to the types of the other arguments passed. 
These &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; arguments can be obtained using the Mercury
&lsquo;<samp><span class="samp">type_of</span></samp>&rsquo; function in the Mercury standard library module
&lsquo;<samp><span class="samp">type_desc</span></samp>&rsquo;.

<div class="node">
<a name="Using-pragma-foreign_decl-for-Java"></a>
<a name="Using-pragma-foreign_005fdecl-for-Java"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fcode-for-Java">Using pragma foreign_code for Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fexport-for-Java">Using pragma foreign_export for Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Java">Interfacing with Java</a>

</div>

<h5 class="subsubsection">14.9.3.6 Using pragma foreign_decl for Java</h5>

<p>&lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declarations for Java can be used to provide
any top-level Java declarations (e.g. &lsquo;<samp><span class="samp">import</span></samp>&rsquo; declarations
or auxiliary class definitions) which are needed by Java code in
&lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; declarations in that module.

   <p>For example:

<pre class="example">     :- pragma foreign_decl("Java", "
     import javax.swing.*;
     import java.awt.*;
     
     class MyApplet extends JApplet {
         public void init() {
             JLabel label = new JLabel(""Hello, world"");
             label.setHorizontalAlignment(JLabel.CENTER);
             getContentPane().add(label);
         }
     }
     ").
     :- pred hello(io.state::di, io.state::uo) is det.
     :- pragma foreign_proc("Java",
     	hello(_IO0::di, _IO::uo),
     	[will_not_call_mercury],
     "
     	MyApplet app = new MyApplet();
     	// ...
     ").
</pre>
   <div class="node">
<a name="Using-pragma-foreign_code-for-Java"></a>
<a name="Using-pragma-foreign_005fcode-for-Java"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fdecl-for-Java">Using pragma foreign_decl for Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Java">Interfacing with Java</a>

</div>

<h5 class="subsubsection">14.9.3.7 Using pragma foreign_code for Java</h5>

<p>The Java code from &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; declarations for Java will be
placed in the bodies of static member functions of an
automatically-generated Java class.  &lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo;
can be used to define additional members of this automatically-generated
class, which can then be referenced by &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo;
declarations for Java from that module.

   <p>For example:

<pre class="example">     :- pragma foreign_code("Java", "
     	static int counter = 0;
     ").
     
     :- impure pred incr_counter is det.
     :- pragma foreign_proc("Java", incr_counter,
     	[will_not_call_mercury], "counter++;").
     
     :- semipure func get_counter = int.
     :- pragma foreign_proc("Java",
     	get_counter = (Result::out),
     	[will_not_call_mercury, promise_semipure],
     	"Result = counter;").
</pre>
   <!--  -->
<div class="node">
<a name="Interfacing-with-Erlang"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Interfacing-with-Java">Interfacing with Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Language-specific-bindings">Language specific bindings</a>

</div>

<h4 class="subsection">14.9.4 Interfacing with Erlang</h4>

<ul class="menu">
<li><a accesskey="1" href="#Using-pragma-foreign_005ftype-for-Erlang">Using pragma foreign_type for Erlang </a>:  Declaring Erlang types in Mercury
<li><a accesskey="2" href="#Using-pragma-foreign_005fproc-for-Erlang">Using pragma foreign_proc for Erlang </a>:  Calling Erlang code from Mercury
<li><a accesskey="3" href="#Using-pragma-foreign_005fexport-for-Erlang">Using pragma foreign_export for Erlang </a>:  Calling Mercury from Erlang code
<li><a accesskey="4" href="#Using-pragma-foreign_005fdecl-for-Erlang">Using pragma foreign_decl for Erlang </a>:  Including Erlang declarations in Mercury
<li><a accesskey="5" href="#Using-pragma-foreign_005fcode-for-Erlang">Using pragma foreign_code for Erlang </a>:  Including Erlang code in Mercury
</ul>

<div class="node">
<a name="Using-pragma-foreign_type-for-Erlang"></a>
<a name="Using-pragma-foreign_005ftype-for-Erlang"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fproc-for-Erlang">Using pragma foreign_proc for Erlang</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Erlang">Interfacing with Erlang</a>

</div>

<h5 class="subsubsection">14.9.4.1 Using pragma foreign_type for Erlang</h5>

<p>An Erlang &lsquo;<samp><span class="samp">pragma foreign_type</span></samp>&rsquo; declaration has the form:

<pre class="example">     :- pragma foreign_type("Erlang", <var>MercuryTypeName</var>, "").
</pre>
   <p>The effect of this declaration is that Mercury values of type
<var>MercuryTypeName</var> will be passed to and from Erlang foreign_procs
as having some representation unknown to Mercury.

<div class="node">
<a name="Using-pragma-foreign_proc-for-Erlang"></a>
<a name="Using-pragma-foreign_005fproc-for-Erlang"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fexport-for-Erlang">Using pragma foreign_export for Erlang</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005ftype-for-Erlang">Using pragma foreign_type for Erlang</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Erlang">Interfacing with Erlang</a>

</div>

<h5 class="subsubsection">14.9.4.2 Using pragma foreign_proc for Erlang</h5>

<p>The input and output variables for a Erlang &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo;
will be the Erlang representations as described in
<a href="#Erlang-data-passing-conventions">Erlang data passing conventions</a>.

   <p>The Erlang code in a <code>pragma foreign_proc</code> declaration
for a procedure whose determinism indicates that it can fail
must assign either &lsquo;<samp><span class="samp">true</span></samp>&rsquo; or &lsquo;<samp><span class="samp">false</span></samp>&rsquo; to the variable
&lsquo;<samp><span class="samp">SUCCESS_INDICATOR</span></samp>&rsquo;.  For example:

<pre class="example">     :- pred contains_char(list(char)::in, char::in) is semidet.
     
     :- pragma foreign_proc("Erlang",
     	contains_char(Str::in, Ch::in),
             [will_not_call_mercury, promise_pure, thread_safe],
             "SUCCESS_INDICATOR = (string:chr(Str, Ch) =/= 0)").
</pre>
   <p>Arguments whose mode is input will have their values set by the
Mercury implementation on entry to the Erlang code. 
The Erlang code must set the values
of all output variables, even if the procedure fails
(i.e. sets the &lsquo;<samp><span class="samp">SUCCESS_INDICATOR</span></samp>&rsquo; variable to <code>false</code>).

<div class="node">
<a name="Using-pragma-foreign_export-for-Erlang"></a>
<a name="Using-pragma-foreign_005fexport-for-Erlang"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fdecl-for-Erlang">Using pragma foreign_decl for Erlang</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fproc-for-Erlang">Using pragma foreign_proc for Erlang</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Erlang">Interfacing with Erlang</a>

</div>

<h5 class="subsubsection">14.9.4.3 Using pragma foreign_export for Erlang</h5>

<p>A &lsquo;<samp><span class="samp">pragma foreign_export</span></samp>&rsquo; declaration for Erlang has the form:

<pre class="example">     :- pragma foreign_export("Erlang", <var>MercuryMode</var>, "<var>Erlang_Name</var>").
</pre>
   <p>For example,

<pre class="example">     :- pragma foreign_export("Erlang", foo(in, in, out), "foo").
</pre>
   <p>The type signature of the Erlang interface to a Mercury procedure is
described in <a href="#Erlang-data-passing-conventions">Erlang data passing conventions</a>.

   <p>Calling polymorphically typed Mercury procedures from Erlang is a little bit
more difficult than calling ordinary (monomorphically typed) Mercury
procedures.  The simplest method is to just create monomorphic forwarding
procedures that call the polymorphic procedures, and export them, rather
than exporting the polymorphic procedures.

   <p>If you do export a polymorphically typed Mercury procedure, the compiler will
prepend one &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; argument to the parameter list of the Erlang
interface function for each distinct type variable in the Mercury procedure's
type signature. 
The caller must arrange to pass in appropriate &lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; values
corresponding to the types of the other arguments passed.  These
&lsquo;<samp><span class="samp">type_info</span></samp>&rsquo; arguments can be obtained using the Mercury &lsquo;<samp><span class="samp">type_of</span></samp>&rsquo;
function in the Mercury standard library module &lsquo;<samp><span class="samp">type_desc</span></samp>&rsquo;.

<div class="node">
<a name="Using-pragma-foreign_decl-for-Erlang"></a>
<a name="Using-pragma-foreign_005fdecl-for-Erlang"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pragma-foreign_005fcode-for-Erlang">Using pragma foreign_code for Erlang</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fexport-for-Erlang">Using pragma foreign_export for Erlang</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Erlang">Interfacing with Erlang</a>

</div>

<h5 class="subsubsection">14.9.4.4 Using pragma foreign_decl for Erlang</h5>

<p>&lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declarations for Erlang can be used to provide
any top-level Erlang declarations (e.g. &lsquo;<samp><span class="samp">-define</span></samp>&rsquo; macro declarations)
which are needed by Erlang code.

   <p>&lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; blocks which do not have the &lsquo;<samp><span class="samp">local</span></samp>&rsquo; attribute
will be copied into the &lsquo;<samp><span class="samp">.hrl</span></samp>&rsquo; header file for that module, and
automatically included by other modules that import the module.  Therefore
&lsquo;<samp><span class="samp">-export</span></samp>&rsquo; directives and Erlang module attributes should only appear in
&lsquo;<samp><span class="samp">local</span></samp>&rsquo; blocks.

   <p>For example:

<pre class="example">     :- pragma foreign_decl("Erlang", "
     	-define(FOO, 42).
     ").
     :- pred hello(io.state::di, io.state::uo) is det.
     :- pragma foreign_proc("Erlang",
     	hello(_IO0::di, _IO::uo),
     	[will_not_call_mercury],
     "
     	io:format(""FOO = ~w~n"", [?FOO])
     ").
</pre>
   <div class="node">
<a name="Using-pragma-foreign_code-for-Erlang"></a>
<a name="Using-pragma-foreign_005fcode-for-Erlang"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-pragma-foreign_005fdecl-for-Erlang">Using pragma foreign_decl for Erlang</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interfacing-with-Erlang">Interfacing with Erlang</a>

</div>

<h5 class="subsubsection">14.9.4.5 Using pragma foreign_code for Erlang</h5>

<p>&lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo; can be used to define additional Erlang functions
which can then be referenced by &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; declarations for
Erlang from that module.  By adding &lsquo;<samp><span class="samp">-export</span></samp>&rsquo; directives inside
&lsquo;<samp><span class="samp">pragma foreign_decl</span></samp>&rsquo; declarations, those functions can additionally be
called from outside the defining module.

   <p>For example:

<pre class="example">     :- pragma foreign_code("Erlang", "
     	foo() -&gt; io:put_chars(""Foo."").
     ").
     
     :- impure pred say_foo is det.
     :- pragma foreign_proc("Erlang", say_foo,
     	[will_not_call_mercury], "foo()").
</pre>
   <!--  -->
<div class="node">
<a name="Impurity"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Solver-types">Solver types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Foreign-language-interface">Foreign language interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">15 Impurity declarations</h2>

<p>In order to efficiently implement certain predicates, it is occasionally
necessary to venture outside pure logic programming. 
Other predicates cannot be implemented at all within the paradigm of logic
programming, for example, all solutions predicates. 
Such predicates are often written using the foreign language interface. 
Sometimes, however, it would be more convenient, or more efficient, to write
such predicates using the facilities of Mercury. 
For example, it is much more convenient to access arguments of compound Mercury
terms in Mercury than in C, and the ability of the Mercury compiler to
specialize code can make higher-order predicates written in Mercury
significantly more efficient than similar C code.

   <p>One important aim of Mercury's impurity system is to make the
distinction between the pure and impure code very clear.  This is done
by requiring every impure predicate or function to be so declared, and
by requiring every call to an impure predicate or function to be flagged as
such. 
Predicates or functions that are implemented in terms of impure predicates
or functions are assumed to be impure themselves unless they are
explicitly promised to be pure.

   <p>Please note that the facilities described here are needed only very
rarely.  The main intent is for implementing language primitives such as
the all solutions predicates, or for implementing interfaces to foreign
language libraries using the foreign language interface.  Any other use of
&lsquo;<samp><span class="samp">impure</span></samp>&rsquo; or &lsquo;<samp><span class="samp">semipure</span></samp>&rsquo; probably indicates either a weakness in
the Mercury standard library, or the programmer's lack of familiarity
with the standard library.  Newcomers to Mercury are hence encouraged to
<strong>skip this section</strong>.

<ul class="menu">
<li><a accesskey="1" href="#Purity-levels">Purity levels</a>:        	Choosing the right level of purity. 
<li><a accesskey="2" href="#Purity-ordering">Purity ordering</a>:      	How purity levels are ordered
<li><a accesskey="3" href="#Impurity-semantics">Impurity semantics</a>:   	What impure code means. 
<li><a accesskey="4" href="#Declaring-impurity">Declaring impurity</a>:   	Declaring predicates impure. 
<li><a accesskey="5" href="#Impure-goals">Impure goals</a>:         	Marking a goal as impure. 
<li><a accesskey="6" href="#Promising-purity">Promising purity</a>:     	Promising that a predicate is pure. 
<li><a accesskey="7" href="#Impurity-Example">Impurity Example</a>:     	A simple example using impurity. 
<li><a accesskey="8" href="#Higher_002dorder-impurity">Higher-order impurity</a>:     	Using impurity with higher-order code. 
</ul>

<div class="node">
<a name="Purity-levels"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Purity-ordering">Purity ordering</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Impurity">Impurity</a>

</div>

<h3 class="section">15.1 Choosing the right level of purity</h3>

<p>Mercury distinguishes three &ldquo;levels&rdquo; of purity:

     <dl>
<dt><dfn>pure</dfn><dd>For pure procedures, the set of solutions depends only on the
values of the input arguments. 
They do not interact with the &ldquo;real&rdquo; world (i.e., do any
input/output) without taking an io.state (see <a href="#Types">Types</a>) as input and
returning one as output, and do not change the value of any data
structure that will not be undone on backtracking (unless the data
structure would be unreachable on backtracking).  Note that equality
axioms are important when considering the value of data structures. 
The declarative semantics of pure predicates is never affected by the
invocation of other predicates. 
It is possible for the invocation of pure predicates to affect the
operational behaviour of non-pure predicates and vice versa.

     <p>By default, Mercury predicates and functions are pure. 
Without using the foreign language interface, writing mode-specific
clauses or calling other impure predicates and functions it is
impossible to write impure code in Mercury.

     <br><dt><dfn>semipure</dfn><dd>Semipure predicates are just like pure predicates, except that their
declarative semantics may be affected by the invocation of impure
predicates.  That is, they are sensitive to the state of the computation
other than as reflected by their input arguments, though they do not
affect the state themselves.

     <br><dt><dfn>impure</dfn><dd>Impure predicates may perform I/O or modify hidden state,
even if these side effects alter the operational semantics
of other code.  However, impure predicates may not change
the declarative semantics of pure code. 
They must be type-, mode-, determinism- and uniqueness correct.

   </dl>

<div class="node">
<a name="Purity-ordering"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Impurity-semantics">Impurity semantics</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Purity-levels">Purity levels</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Impurity">Impurity</a>

</div>

<h3 class="section">15.2 Purity ordering</h3>

<p>The three levels of purity have a total ordering defined upon them
(which we will simply call the purity), where <code>pure &gt; semipure &gt; impure</code>.

<div class="node">
<a name="Impurity-semantics"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Declaring-impurity">Declaring impurity</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Purity-ordering">Purity ordering</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Impurity">Impurity</a>

</div>

<h3 class="section">15.3 Semantics</h3>

<p>It is important to the proper operation of impure and semipure code, to
the flexibility of the compiler to optimize pure code, and to the
semantics of the Mercury language, that a clear distinction be drawn
between ordinary Mercury code and imperative code written with Mercury
syntax.  How this distinction is drawn will be explained below; the
purpose of this section is to explain the semantics of programs with
impure predicates.

   <p>A <em>declarative</em> semantics of impure Mercury code would be largely
useless, because the declarative semantics cannot capture the intent of
the programmer.  Impure predicates are executed for their side-effects,
which by definition are not part of their declarative semantics.  Thus
it is the <em>operational</em> semantics of impure predicates that Mercury
must specify, and Mercury compilers must respect.

   <p>The operational semantics of a Mercury predicate which invokes
<em>impure</em> code is a modified form of the <em>strict sequential</em>
semantics (see <a href="#Semantics">Semantics</a>).  <em>Impure</em> goals may not be reordered
relative to any other goals; not even &ldquo;minimal&rdquo; reordering as implied
by the modes is permitted.  If any such reordering is needed, this is a
mode error.  However, <em>pure</em> and <em>semipure</em> goals may be
reordered as the compiler desires (within the bounds of the semantics
the user has specified for the program) as long as they are not moved
across an impure goal.  Execution of impure goals is strict: they must
be executed if they are reached, even if it can be determined that the
computation cannot lead to successful termination.

   <p>Semipure goals can be given a &ldquo;contextual&rdquo; declarative semantics. 
They cannot have any side-effects, so it is expected that, given the
context in which they are called (relative to any impure goals in the
program), their declarative semantics fully captures the intent of the
programmer.  Thus a semipure goal has a perfectly consistent declarative
semantics, until an impure goal is reached.  After that, it has another
(possibly different) declarative semantics, until the next impure goal
is executed, and so on.  Mercury compilers must respect this contextual
nature of the semantics of semipure goals; within a single context, a
compiler may treat a semipure goal as if it were pure.

<div class="node">
<a name="Declaring-impurity"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Impure-goals">Impure goals</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Impurity-semantics">Impurity semantics</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Impurity">Impurity</a>

</div>

<h3 class="section">15.4 Declaring impure functions and predicates</h3>

<p>Every Mercury predicate or function has exactly two purity values
associated with it. 
One is the <em>declared</em> purity of the predicate or function, which is
given by the programmer. 
The other value is the <em>inferred</em> purity,
which is calculated from the purity of goals in the body of the
predicate or function.

   <p>A predicate is declared to be impure or semipure by preceding the word
<code>pred</code> in its <code>pred</code> declaration with <code>impure</code>
or <code>semipure</code>, respectively. 
Similarly, a function is declared impure or semipure by preceding the
word <code>func</code> in its <code>func</code> declaration with <code>impure</code> or
<code>semipure</code>. 
That is, a declaration of the form:

<pre class="example">     :- impure pred <var>Pred</var>(<var>Arguments</var>...).
     :- semipure pred <var>Pred</var>(<var>Arguments</var>...).
</pre>
   <p class="noindent">or

<pre class="example">     :- impure func <var>Func</var>(<var>Arguments</var>...) = Result.
     :- semipure func <var>Func</var>(<var>Arguments</var>...) = Result.
</pre>
   <p class="noindent">declares the predicate <var>Pred</var> to be impure and the function
<var>Func</var> to be semipure, respectively.

   <p>Type class methods may also be declared as <code>impure</code> or
<code>semipure</code> by preceding the word <code>pred</code> or <code>func</code> with the
appropriate purity level.  An instance of the type class must provide
method implementations that are at least as pure as the method
declaration.

<div class="node">
<a name="Impure-goals"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Promising-purity">Promising purity</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Declaring-impurity">Declaring impurity</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Impurity">Impurity</a>

</div>

<h3 class="section">15.5 Marking a goal as impure</h3>

<p>If predicate <code>p/N</code> is declared to be <code>impure</code> (<code>semipure</code>)
then all calls to <code>p/N</code> must be annotated with <code>impure</code>
(<code>semipure</code>):

<pre class="example">     	impure p(X1, X2, ..., XN)
</pre>
   <p>If function <code>f/N</code> is declared to be <code>impure</code> (<code>semipure</code>)
then all applications of <code>f/N</code> must be obtained by unification with a
variable and the unification goal as a whole be annotated with <code>impure</code>

<pre class="example">     	impure X = f(X1, X2, ..., XN)
</pre>
   <p>Any call or unification goal containing a non-local variable with inst any that
appears in a negated context (i.e., in a negation or the condition of an
if-then-else goal) must be given an <code>impure</code> annotation because it may
violate referential transparency.

   <p>Compound goals should not have purity annotations.

   <p>The compiler will report an error if a required purity annotation is
omitted from a call or unification goal or if a <code>semipure</code> annotation
is used where an <code>impure</code> annotation is required.  The compiler will
report a warning if a semipure goal is annotated with <code>impure</code> or a
pure goal is annotated with <code>semipure</code>

   <p>The requirement that impure or semipure calls be marked with
<code>impure</code> or <code>semipure</code> allows someone
reading the code to tell which goals are not pure, making code which
relies on side effects somewhat less mysterious.  Furthermore, it means
that if a call is <em>not</em> preceded by <code>impure</code> or
<code>semipure</code>, then the reader can rely on the call having a proper
declarative semantics, without hidden side-effects.

<div class="node">
<a name="Promising-purity"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Impurity-Example">Impurity Example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Impure-goals">Impure goals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Impurity">Impurity</a>

</div>

<h3 class="section">15.6 Promising that a predicate is pure</h3>

<p>Predicates that are implemented in terms of impure or semipure predicates are
assumed to have the least of the purity of the goals in their body. 
The declared purity of a predicate must not be more pure
than the inferred purity; if it is, the compiler must generate an error. 
If the declared purity is less pure than the inferred purity, the
compiler should issue a warning (this is similar to the above case for
goals). 
Because the inferred purity of the predicate is calculated from the
declared purity of the calls it executes,  the lowest purity bound is
propagated up from callee to caller through the program.

   <p>In some cases the impurity of a predicate's body is an implementation
detail which should not be exposed to callers. These predicates are
pure or semipure even though they call impure or semipure predicates. 
The only way for the programmer to stop the propagation of impurity is to
explicitly promise that the predicate or function is pure or semipure.

   <p>Of course, the Mercury compiler cannot verify that the predicate's
purity matches the promise, so it is the programmer's responsibility
to ensure this.  If a predicate is promised pure or semipure and is not,
the behaviour of the program is undefined.

   <p>The programmer may promise that a predicate or function is pure or semipure
using the <code>promise_pure</code> and <code>promise_semipure</code> pragmas:

<pre class="example">     :- pragma promise_pure(<var>Name</var>/<var>Arity</var>).
     :- pragma promise_semipure(<var>Name</var>/<var>Arity</var>).
</pre>
   <p>Programmers should be very careful about mixing code that is promised
pure with impure predicates or functions that may manipulate the
same hidden state (for example, the impure predicates used to implement
a predicate that is promised pure); the &lsquo;<samp><span class="samp">promise_pure</span></samp>&rsquo; declaration
is supposed to promise that impure code cannot change the declarative
semantics of pure code.  The module system can be used to minimize the
possibility of making errors with such code, by keeping impure
predicates or functions behind the interface where code is promised
pure.

   <p>Note that the &lsquo;<samp><span class="samp">promise_pure</span></samp>&rsquo;, &lsquo;<samp><span class="samp">promise_semipure</span></samp>&rsquo;, and
&lsquo;<samp><span class="samp">promise_impure</span></samp>&rsquo; scopes described in <a href="#Goals">Goals</a> may be used to
promise purity at the finer level of goals within clauses.

<div class="node">
<a name="Impurity-Example"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Higher_002dorder-impurity">Higher-order impurity</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Promising-purity">Promising purity</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Impurity">Impurity</a>

</div>

<h3 class="section">15.7 An example using impurity</h3>

<p>The following example illustrates how a pure predicate may be
implemented using impure code.  Note that this code is not reentrant,
and so is not useful as is.  It is meant only as an example.

<pre class="example">     :- pragma foreign_decl("C", "#include &lt;limits.h&gt;").
     :- pragma foreign_decl("C", "extern MR_Integer max;").
     
     :- pragma foreign_code("C", "MR_Integer max;").
     
     :- impure pred init_max is det.
     :- pragma foreign_proc("C",
         init_max,
         [will_not_call_mercury],
     "
         max = INT_MIN;
     ").
     
     :- impure pred set_max(int::in) is det.
     :- pragma foreign_proc("C",
        set_max(X::in),
        [will_not_call_mercury],
     "
         if (X &gt; max) max = X;
     ").
     
     :- semipure func get_max = (int::out) is det.
     :- pragma foreign_proc("C",
         get_max = (X::out),
         [promise_semipure, will_not_call_mercury],
     "
         X = max;
     ").
     
     :- pragma promise_pure(max_solution/2).
     :- pred max_solution(pred(int), int).
     :- mode max_solution(pred(out) is multi, out) is det.
     
     max_solution(Generator, Max) :-
         impure init_max,
         (
             Generator(X),
             impure set_max(X),
             fail
         ;
             semipure Max = get_max
         ).
</pre>
   <div class="node">
<a name="Higher-order-impurity"></a>
<a name="Higher_002dorder-impurity"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Impurity-Example">Impurity Example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Impurity">Impurity</a>

</div>

<h3 class="section">15.8 Using impurity with higher-order code</h3>

<p>Higher-order code can manipulate impure or semipure predicates and functions,
provided that explicit purity annotations are used in three places:
on the higher-order types, on lambda expressions, and on higher-order calls. 
(There are no purity annotations on higher-order insts and modes, however.)

<ul class="menu">
<li><a accesskey="1" href="#Purity-annotations-on-higher_002dorder-types">Purity annotations on higher-order types</a>
<li><a accesskey="2" href="#Purity-annotations-on-lambda-expressions">Purity annotations on lambda expressions</a>
<li><a accesskey="3" href="#Purity-annotations-on-higher_002dorder-calls">Purity annotations on higher-order calls</a>
</ul>

<div class="node">
<a name="Purity-annotations-on-higher-order-types"></a>
<a name="Purity-annotations-on-higher_002dorder-types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Purity-annotations-on-lambda-expressions">Purity annotations on lambda expressions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Higher_002dorder-impurity">Higher-order impurity</a>

</div>

<h4 class="subsection">15.8.1 Purity annotations on higher-order types</h4>

<p>Ordinary higher-order types, such as &lsquo;<samp><span class="samp">pred(T1, T2)</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">func(T1, T2) = T</span></samp>&rsquo;, represent only pure predicates or pure functions. 
But for each ordinary higher-order type <var>Foo</var>, there are two corresponding
types &lsquo;<samp><span class="samp">semipure </span><var>Foo</var></samp>&rsquo; and &lsquo;<samp><span class="samp">impure </span><var>Foo</var></samp>&rsquo;.  These types
can be used for higher-order code that needs to manipulate impure or
semipure procedures.  For example the type &lsquo;<samp><span class="samp">impure func(int) = int</span></samp>&rsquo;
represents impure functions from &lsquo;<samp><span class="samp">int</span></samp>&rsquo; to &lsquo;<samp><span class="samp">int</span></samp>&rsquo;.

   <p>There are no implicit conversions and no subtyping relationship between
ordinary higher-order types and the corresponding impure or semipure
higher-order types.  However, a value of an ordinary higher-order
type can be explicit &ldquo;converted&rdquo; to a value of an impure (or semipure)
higher-order type by wrapping it in an impure (or semipure)
lambda expression that just calls the pure higher-order term.

<div class="node">
<a name="Purity-annotations-on-lambda-expressions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Purity-annotations-on-higher_002dorder-calls">Purity annotations on higher-order calls</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Purity-annotations-on-higher_002dorder-types">Purity annotations on higher-order types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Higher_002dorder-impurity">Higher-order impurity</a>

</div>

<h4 class="subsection">15.8.2 Purity annotations on lambda expressions</h4>

<p>Purity annotations are required on lambda expressions that call
semipure or impure code. 
Lambda expressions can be declared as &lsquo;<samp><span class="samp">semipure</span></samp>&rsquo; or &lsquo;<samp><span class="samp">impure</span></samp>&rsquo;
by including such an annotation before the &lsquo;<samp><span class="samp">pred</span></samp>&rsquo; or &lsquo;<samp><span class="samp">func</span></samp>&rsquo;
identifier in the lambda expression.  Such lambda expressions have
the corresponding &lsquo;<samp><span class="samp">semipure</span></samp>&rsquo; or &lsquo;<samp><span class="samp">impure</span></samp>&rsquo; higher-order type. 
For example, the expression

<pre class="example">     	(impure func(X) = Y :- semipure get_max(Y), impure set_max(X))
</pre>
   <p class="noindent">is an example of an impure function lambda expression with type
&lsquo;<samp><span class="samp">(impure func(int) = int)</span></samp>&rsquo;, and the expression

<pre class="example">     	(impure pred(X::in, Y::out) is det :-
     		semipure get_max(Y),
     		impure set_max(X))
</pre>
   <p>is an example of an impure predicate lambda expression
with type &lsquo;<samp><span class="samp">impure pred(int, int)</span></samp>&rsquo;.

<div class="node">
<a name="Purity-annotations-on-higher-order-calls"></a>
<a name="Purity-annotations-on-higher_002dorder-calls"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Purity-annotations-on-lambda-expressions">Purity annotations on lambda expressions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Higher_002dorder-impurity">Higher-order impurity</a>

</div>

<h4 class="subsection">15.8.3 Purity annotations on higher-order calls</h4>

<p>Any calls to impure or semipure higher-order terms must be explicitly
annotated as such.  For impure or semipure higher-order predicates,
the annotation is indicated by putting &lsquo;<samp><span class="samp">impure</span></samp>&rsquo; or &lsquo;<samp><span class="samp">semipure</span></samp>&rsquo;
before the call.  For example:

<pre class="example">     	:- func foo(impure pred(int)) = int.
     	:- mode foo(in(pred(out) is det)) = out is det.
     
     	foo(ImpurePred) = X1 + X2 :-
     		% using higher-order syntax
     		impure ImpurePred(X1),
     		% using the call/N syntax
     		impure call(ImpurePred, X2).
</pre>
   <p>For calling impure or semipure higher-order functions, the notation is
different than what you might expect.  In addition to using an &lsquo;<samp><span class="samp">impure</span></samp>&rsquo;
or &lsquo;<samp><span class="samp">semipure</span></samp>&rsquo; operator on the unification which invokes the higher-order
function application, you must also use &lsquo;<samp><span class="samp">impure_apply</span></samp>&rsquo;
or &lsquo;<samp><span class="samp">semipure_apply</span></samp>&rsquo; rather than using &lsquo;<samp><span class="samp">apply</span></samp>&rsquo; or higher-order syntax. 
<!-- XXX it would be nicer to change the implementation to support -->
<!-- nice syntax, rather than documenting this hack -->
For example:

<pre class="example">     	:- func map(impure func(T1) = T2, list(T1)) = list(T2).
     
     	map(_ImpureFunc, []) = [].
     	map(ImpureFunc, [X|Xs]) = [Y|Ys] :-
     		impure Y = impure_apply(ImpureFunc, X),
     		impure Ys = map(ImpureFunc, Ys).
</pre>
   <div class="node">
<a name="Solver-types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Trace-goals">Trace goals</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Impurity">Impurity</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">16 Solver types</h2>

<ul class="menu">
<li><a accesskey="1" href="#The-any-inst">The any inst</a>
<li><a accesskey="2" href="#Abstract-solver-type-declarations">Abstract solver type declarations</a>
<li><a accesskey="3" href="#Solver-type-definitions">Solver type definitions</a>
<li><a accesskey="4" href="#Implementing-solver-types">Implementing solver types</a>
<li><a accesskey="5" href="#Solver-types-and-negated-contexts">Solver types and negated contexts</a>
</ul>

<p>Solver types are an experimental addition to the language supporting the
implementation of constraint solvers.  A program may place constraints
on and between variables of a solver type, limiting the values those
variables may take on before they are actually bound.  For example, if
<code>X</code> and <code>Y</code> are variables belonging to a constrained integer
solver type, we might place constraints upon them such that <code>X &gt; 3
+ Y</code> and <code>Y =&lt; 7</code>.  A later attempt to unify <code>Y</code> with
<code>10</code> will fail (it would violate the second constraint); similarly
an attempt to unify <code>X</code> with <code>5</code> and <code>Y</code> with <code>4</code>
would fail (it would violate the first constraint).

<div class="node">
<a name="The-any-inst"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Abstract-solver-type-declarations">Abstract solver type declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Solver-types">Solver types</a>

</div>

<h3 class="section">16.1 The &lsquo;<samp><span class="samp">any</span></samp>&rsquo; inst</h3>

<p>Variables with solver types can have one of three possible insts: <code>free</code>,
<code>ground</code> or <code>any</code>. 
A variable with a solver type with inst <code>any</code> may not (yet) be
semantically ground, in the following sense: if a variable is semantically
ground then the set of values it unifies with form an equivalence class; if a
variable is non-ground then the set of values it unifies with do not form an
equivalence class.

   <p>More formally, <code>X</code> is ground if for values <code>Y</code> and
<code>Z</code> that unify with <code>X</code>, it is the case that <code>Y</code> and
<code>Z</code> also unify with each other.  <code>X</code> is non-ground if there
are values <code>Y</code> and <code>Z</code> that unify with <code>X</code>, but which do
not unify with each other.

   <p>A non-solver type value will have inst <code>any</code> if it is constructed using
one or more inst <code>any</code> values.

   <p>The built-in modes <code>ia</code> and <code>oa</code> are equivalent to <code>in(any)</code>
and <code>out(any)</code> respectively.

<div class="node">
<a name="Abstract-solver-type-declarations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Solver-type-definitions">Solver type definitions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-any-inst">The any inst</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Solver-types">Solver types</a>

</div>

<h3 class="section">16.2 Abstract solver type declarations</h3>

<p>The type declarations

<pre class="example">     :- solver type t1.
     :- solver type t2(T1, T2).
</pre>
   <p class="noindent">declare types <code>t1/0</code> and <code>t2/2</code> to be abstract solver types. 
Abstract solver type declarations are identical to ordinary abstract
type declarations except for the solver keyword.

<div class="node">
<a name="Solver-type-definitions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Implementing-solver-types">Implementing solver types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Abstract-solver-type-declarations">Abstract solver type declarations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Solver-types">Solver types</a>

</div>

<h3 class="section">16.3 Solver type definitions</h3>

<p>A solver type definition takes the following form:

<pre class="example">     :- solver type solver_type
             where   representation   is representation_type,
                     ground           is ground_inst,
                     any              is any_inst,
                     constraint_store is mutable_decls,
                     equality         is equality_pred,
                     comparison       is comparison_pred.
</pre>
   <p>The &lsquo;<samp><span class="samp">representation</span></samp>&rsquo; attribute is mandatory
&lsquo;<samp><span class="samp">ground_inst</span></samp>&rsquo; and &lsquo;<samp><span class="samp">any_inst</span></samp>&rsquo; default to &lsquo;<samp><span class="samp">ground</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">mutable_decls</span></samp>&rsquo; is either a single mutable declaration
(see <a href="#Module_002dlocal-mutable-variables">Module-local mutable variables</a>)
or a comma separated list of mutable declarations in brackets,
the equality and comparison attributes are optional (although a solver type
without equality would not be very useful), and attributes must appear in the
order shown.

   <p>The <code>representation_type</code> is the type used to implement the
<code>solver_type</code>.  A two-tier scheme of this kind is necessary for a
number of reasons, including
     <ul>
<li>a semantic gap is necessary to accommodate the fact that non-ground
<code>solver_type</code> values may be represented by ground
<code>representation_type</code> values (in the context of the corresponding
constraint solver state);
<li>this approach greatly simplifies the definition of equality and
comparison predicates for the <code>solver_type</code>. 
</ul>

<!-- XXX The following paragraph describes the old support for automatic -->
<!-- initialisation of solver types.  We no longer officially support -->
<!-- automatic initialisation as part of the language but the compiler -->
<!-- still contains the code necessary to implement it. -->
<!-- The @code{initialisation_pred} is the name of a predicate defined in the -->
<!-- same module as the solver type, with the following signature: -->
<!-- @example -->
<!-- :- pred initialisation_pred(solver_type::out(any)) is det. -->
<!-- @end example -->
<!-- Calls to this predicate are inserted automatically by the compiler when a -->
<!-- @code{free} @code{solver_type} variable has to be given inst @code{any}. -->
<!-- (The initialisation predicate is responsible for registering the new, -->
<!-- unbound variable with the corresponding constraint solver state.) -->
   <p>The <code>ground_inst</code> is the inst associated with
<code>representation_type</code> values denoting <code>ground</code>
<code>solver_type</code> values.

   <p>The <code>any_inst</code> is the inst associated with
<code>representation_type</code> values denoting <code>any</code> <code>solver_type</code>
values.

   <p>The compiler constructs four impure functions for converting between
<code>solver_type</code> values and <code>representation_type</code> values
(&lsquo;<samp><span class="samp">name</span></samp>&rsquo; is the function symbol used to name <code>solver_type</code> and
&lsquo;<samp><span class="samp">arity</span></samp>&rsquo; is the number of type parameters it takes):

<pre class="example">     :- impure func 'representation of ground name/arity'(solver_type) =
                             representation_type.
     :-        mode 'representation of ground name/arity'(in) =
                             out(ground_inst) is det.
     
     :- impure func 'representation of any name/arity'(solver_type) =
                             representation_type.
     :-        mode 'representation of any name/arity'(in(any)) =
                             out(any_inst) is det.
     
     :- impure func 'representation to ground name/arity'(representation_type) =
                             solver_type.
     :-        mode 'representation to ground name/arity'(in(ground_inst)) =
                             out is det.
     
     :- impure func 'representation to any name/arity'(representation_type) =
                             solver_type.
     :-        mode 'representation to any name/arity'(in(any_inst)) =
                             out(any) is det.
</pre>
   <p>These functions are impure because of the semantic gap issue mentioned
above.

   <p>These functions are constructed in-line as part of a source-to-source
transformation, hence it is an error to define a solver type in the
interface section of a module.

   <p>If <code>solver_type</code> is exported then it is a requirement that
<code>representation_type</code>, <code>initialisation_pred</code>, and, if
specified, <code>equality_pred</code> and <code>comparison_pred</code> are also
exported from the same module.

   <p>If <code>equality_pred</code> is not specified then the compiler will
generate an equality predicate that throws an exception of type
&lsquo;<samp><span class="samp">exception.software_error/0</span></samp>&rsquo; when called.

   <p>Likewise, if <code>comparison_pred</code> is not specified then the compiler
will generate a comparison predicate that throws an exception of
type &lsquo;<samp><span class="samp">exception.software_error/0</span></samp>&rsquo; when called.

   <p>If provided, any mutable declarations given for the <code>constraint_store</code>
attribute are equivalent to separate mutable declarations; their association
with the solver type is for the purposes of documentation.  That is,

<pre class="example">     :- solver type t
     	where ... constraint_store is [ mutable(a, int, 42, ground, []),
     					mutable(b, string, "Hi", ground, [])
     		  ],
     	      ...
</pre>
   <p class="noindent">is equivalent to

<pre class="example">     :- solver type t
     	where ...
     :- mutable(a, int, 42, ground, []).
     :- mutable(b, string, "Hi", ground, []).
</pre>
   <div class="node">
<a name="Implementing-solver-types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Solver-types-and-negated-contexts">Solver types and negated contexts</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Solver-type-definitions">Solver type definitions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Solver-types">Solver types</a>

</div>

<h3 class="section">16.4 Implementing solver types</h3>

<p>A solver type is an abstraction, implemented using a combination of a
private representation type and a constraint store.

   <p>The constraint store is an (impure) piece of state used to keep track of
the extant constraints on variables of the solver type.  This will
typically be implemented using foreign code.

   <p>It is important that changes to the constraint store are properly
trailed (see <a href="#Trailing">Trailing</a>) so that changes can be undone on
backtracking.

   <p>The solver type implementation should provide functions and predicates
to
     <ul>
<li>construct and deconstruct solver type values,
<li>to place constraints on solver type variables,
<li>to convert <code>any</code> solver type variables to <code>ground</code> if possible
(this is obviously an impure operation &mdash; see <a href="#Impurity">Impurity</a>),
<li>to convert solver type values to non-solver type values (again, this is
impure and requires the argument solver type values be
sufficiently ground),
<li>to ask questions about the extant constraints on solver type variables
without constraining them further (this too is impure because the set
of constraints on a variable may change during execution of the
program). 
</ul>

<div class="node">
<a name="Solver-types-and-negated-contexts"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Implementing-solver-types">Implementing solver types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Solver-types">Solver types</a>

</div>

<h3 class="section">16.5 Solver types and negated contexts</h3>

<p>Mercury's negation and if-then-else goals
(and hence also inequalities and universal quantifications)
are implemented using <em>negation as failure</em>,
meaning that the failure to find a proof of one statement is regarded as a
proof of its negation. 
Negation as failure is sound provided that no non-local variable
becomes further bound during the execution of a goal which may be negated. 
This includes negated goals themselves, as well as the conditions of
if-then-elses, which are negated iff they fail without producing any solution,
and the bodies of pred or func expressions, which may be called or applied
in one of the other contexts, or indeed in another pred or func expression.

   <p>Mercury checks that any solver variables that are used in the above contexts
are used in such a way that negation as failure remains sound. 
In the case of negation and if-then-else goals,
if any non-local solver type variable or higher order variable
with inst <code>any</code> is used in a negated context,
the goal must be placed inside a <code>promise_pure</code>, <code>promise_semipure</code>,
or <code>promise_impure</code> scope. 
The first two promises assert that (among other things)
no solver variable becomes further bound in the negated context. 
The third promise makes the weaker assertion that the goal satisfies
the requirements of all impure goals (namely, that it doesn't interfere
with the semantics of other pure goals).

   <p>In the case of pred and func expressions, Mercury allows three possibilities. 
The higher order value may be considered <code>ground</code>, which means that
all non-local variables used in the body of the expression
(including those with other higher order values) must themselves be ground. 
Higher order values that are ground can be safely called or applied
in any context, including negated contexts, since none of their (ground)
non-local variables can become further bound by doing so. 
Alternatively, the higher order value may be considered to have inst
<code>any</code>, which allows non-local variables used in the body of the
expression to have inst <code>any</code>. 
Calling or applying these values <em>may</em> further bind non-local variables,
so if this occurs in a negated context then,
as in the case of solver variables, a promise will be required around the
negation or if-then-else.

   <p>Pred and func expressions with inst <code>any</code> are written using
<code>any_pred</code> and <code>any_func</code> in place of <code>pred</code> and <code>func</code>,
respectively.

   <p>The third possibility is that the higher order value can be given an
impure type (see <a href="#Higher_002dorder-impurity">Higher-order impurity</a>).

<div class="node">
<a name="Trace-goals"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pragmas">Pragmas</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Solver-types">Solver types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">17 Trace goals</h2>

<p>Sometimes, programmers find themselves
needing to perform some side-effects in the middle of declarative code. 
One example is an operation that takes so long that
users may think the program has gone into an infinite loop:
periodically printing a progress message can give them reassurance. 
Another example is a program that is
too long-running for its behaviour to be analyzed via debuggers
and too complex for analysis via profilers;
a programmable logging facility generating data
for analysis by a specially-written program may be the best option. 
However, inserting arbitrary side effects into declarative code
is against the spirit of Mercury. 
Trace goals exist to provide a mechanism
to code these side effects in a disciplined fashion.

   <p>The format of trace goals is <code>trace </code><var>Params</var> <var>Goal</var>. 
<var>Goal</var> must be a valid goal;
<var>Params</var> must be a valid list of one or more trace parameters. 
The following example shows all four of the available kinds of parameters:
&lsquo;<samp><span class="samp">compile_time</span></samp>&rsquo;, &lsquo;<samp><span class="samp">run_time</span></samp>&rsquo;, &lsquo;<samp><span class="samp">io</span></samp>&rsquo; and &lsquo;<samp><span class="samp">state</span></samp>&rsquo;. 
(In practice, it is far more typical to have just one parameter, &lsquo;<samp><span class="samp">io</span></samp>&rsquo;.)

<pre class="example">     :- mutable(logging_level, int, 0, ground, []).
     
     :- pred time_consuming_task(data::in, result::out) is det.
     
     time_consuming_task(In, Out) :-
             trace [
                     compile_time(flag("do_logging") or grade(debug)),
                     run_time(env("VERBOSE")),
                     io(!IO),
                     state(logging_level, !LoggingLevel)
             ] (
                     io.write_string("Time_consuming_task start\n", !IO),
                     ( !.LoggingLevel &gt; 1 -&gt;
                             io.write_string("Input is ", !IO),
                             io.write(In, !IO),
                             io.nl(!IO)
                     ;
                             true
                     )
             ),
             ...
             % perform the actual task
</pre>
   <p>The &lsquo;<samp><span class="samp">compile_time</span></samp>&rsquo; parameter says under what circumstances
the trace goal should be included in the executable program. 
In the example, at least one of two conditions has to be true:
either this module has to be compiled
with the option &lsquo;<samp><span class="samp">--trace-flag=do_logging</span></samp>&rsquo;,
or it has to be compiled in a debugging grade.

   <p>In general, the single argument of the &lsquo;<samp><span class="samp">compile_time</span></samp>&rsquo; function symbol
is a boolean expression of primitive compile-time conditions. Valid boolean
operators in these expressions are &lsquo;<samp><span class="samp">and</span></samp>&rsquo;, &lsquo;<samp><span class="samp">or</span></samp>&rsquo; and &lsquo;<samp><span class="samp">not</span></samp>&rsquo;. 
There are three kinds of primitive compile-time conditions. 
The first has the form &lsquo;<samp><span class="samp">flag(</span><var>FlagName</var><span class="samp">)</span></samp>&rsquo;,
where <var>FlagName</var> is an arbitrary name picked by the programmer;
this condition is true
if the module is compiled with the option &lsquo;<samp><span class="samp">--trace-flag=</span><var>FlagName</var></samp>&rsquo;. 
The second has the form &lsquo;<samp><span class="samp">tracelevel(shallow)</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">tracelevel(deep)</span></samp>&rsquo;;
this condition is true (irrespective of grade)
if the module is compiled with at least the specified trace level. 
The third has the form &lsquo;<samp><span class="samp">grade(GradeTest)</span></samp>&rsquo;. 
The supported &lsquo;<samp><span class="samp">GradeTests</span></samp>&rsquo;s and their meanings are as follows.

     <dl>
<dt>&lsquo;<samp><span class="samp">debug</span></samp>&rsquo;<dd>True if the module is compiled with execution tracing enabled. 
<br><dt>&lsquo;<samp><span class="samp">ssdebug</span></samp>&rsquo;<dd>True if the module is compiled with source-to-source debugging enabled. 
<br><dt>&lsquo;<samp><span class="samp">prof</span></samp>&rsquo;<dd>True if the module is compiled with non-deep profiling enabled. 
<br><dt>&lsquo;<samp><span class="samp">profdeep</span></samp>&rsquo;<dd>True if the module is compiled with deep profiling enabled. 
<br><dt>&lsquo;<samp><span class="samp">par</span></samp>&rsquo;<dd>True if the module is compiled with parallel execution enabled. 
<br><dt>&lsquo;<samp><span class="samp">trail</span></samp>&rsquo;<dd>True if the module is compiled with trailing enabled. 
<br><dt>&lsquo;<samp><span class="samp">rbmm</span></samp>&rsquo;<dd>True if the module is compiled with region based memory management enabled. 
<br><dt>&lsquo;<samp><span class="samp">llds</span></samp>&rsquo;<dd>True if the module is compiled with &ndash;highlevel-code disabled. 
<br><dt>&lsquo;<samp><span class="samp">mlds</span></samp>&rsquo;<dd>True if the module is compiled with &ndash;highlevel-code enabled. 
<br><dt>&lsquo;<samp><span class="samp">c</span></samp>&rsquo;<dd>True if the target language of the compilation is C. 
<br><dt>&lsquo;<samp><span class="samp">il</span></samp>&rsquo;<dd>True if the target language of the compilation is MS IL. 
<br><dt>&lsquo;<samp><span class="samp">csharp</span></samp>&rsquo;<dd>True if the target language of the compilation is C#. 
<br><dt>&lsquo;<samp><span class="samp">java</span></samp>&rsquo;<dd>True if the target language of the compilation is Java. 
<br><dt>&lsquo;<samp><span class="samp">erlang</span></samp>&rsquo;<dd>True if the target language of the compilation is Erlang. 
</dl>
   <!-- (We may support the specification of other kinds of grades in the future.) -->

   <p>The &lsquo;<samp><span class="samp">run_time</span></samp>&rsquo; parameter says under what circumstances the trace goal,
if included in the executable program, should actually be executed. 
In this case, the environment variable &lsquo;<samp><span class="samp">VERBOSE</span></samp>&rsquo; has be to set
when the program starts execution. 
(It doesn't matter what value it is set to.)

   <p>In general, the single argument of the &lsquo;<samp><span class="samp">run_time</span></samp>&rsquo; function symbol
is a boolean expression of primitive run-time conditions. Valid boolean
operators in these expressions are &lsquo;<samp><span class="samp">and</span></samp>&rsquo;, &lsquo;<samp><span class="samp">or</span></samp>&rsquo; and &lsquo;<samp><span class="samp">not</span></samp>&rsquo;. 
There is just one primitive run-time condition. 
It has the form &lsquo;<samp><span class="samp">env(</span><var>EnvVarName</var><span class="samp">)</span></samp>&rsquo;,
this condition is true
if the environment variable <var>EnvVarName</var>
exists when the program starts execution.

   <p>The &lsquo;<samp><span class="samp">compile_time</span></samp>&rsquo; and &lsquo;<samp><span class="samp">run_time</span></samp>&rsquo; parameters
may not appear in the parameter list more than once;
programmers who want more than one condition
have to specify how (with what boolean operators)
their values should be combined. 
However, it is ok for them not to appear in the parameter list at all. 
If there is no &lsquo;<samp><span class="samp">compile_time</span></samp>&rsquo; parameter,
the trace goal is always compiled into the executable;
if there is no &lsquo;<samp><span class="samp">run_time</span></samp>&rsquo; parameter,
the trace goal is always executed (if it is compiled into the executable).

   <p>Since the trace goal may end up
either not compiled into the executable or just not executed,
it cannot bind any variables that occur in the surrounding code. 
(If it were allowed to bind such variables,
then those variables would stay unbound
if either the compile time or the run time condition were false.) 
This greatly restricts what trace goals can do.

   <p>The usual reason for including a trace goal
in a procedure body is to perform some I/O,
which requires access to the I/O state. 
The &lsquo;<samp><span class="samp">io</span></samp>&rsquo; parameter supplies this access. 
Its argument must be the name of a state variable prefixed by &lsquo;<samp><span class="samp">!</span></samp>&rsquo;;
by convention, it is usually &lsquo;<samp><span class="samp">!IO</span></samp>&rsquo;. 
The language implementation supplies
the initial unique value of the I/O state
as the value of &lsquo;<samp><span class="samp">!.IO</span></samp>&rsquo; at the start of the trace goal;
it requires the trace goal to give back
the final unique value of the I/O state
as the value of &lsquo;<samp><span class="samp">!.IO</span></samp>&rsquo; current at the end of the trace goal.

   <p>Note that trace goals that wish to do I/O
must include this parameter in their parameter list
<em>even if</em> the surrounding code already has access to an I/O state. 
This is because otherwise,
doing any I/O inside the trace goal
would destroy the value of the current I/O state,
changing the instantiation state of the variable holding it,
and trace goals are not allowed to do that.

   <p>The &lsquo;<samp><span class="samp">io</span></samp>&rsquo; parameter may appear in the parameter list at most once,
since it doesn't make sense to have
two copies of the I/O state available to the trace goal.

   <p>Besides doing I/O, trace goals may read and possibly write
the values of mutable variables. 
Each mutable the trace goal wants access to should be listed
in its own &lsquo;<samp><span class="samp">state</span></samp>&rsquo; parameter
(which may therefore appear in the parameter list more than once). 
Each &lsquo;<samp><span class="samp">state</span></samp>&rsquo; parameter has two arguments:
the first gives the name of the mutable,
while the second must be the name of a state variable prefixed by &lsquo;<samp><span class="samp">!</span></samp>&rsquo;,
e.g. &lsquo;<samp><span class="samp">!LoggingLevel</span></samp>&rsquo;. 
The language implementation supplies
the initial value of the mutable
as the value of (in this case) &lsquo;<samp><span class="samp">!.LoggingLevel</span></samp>&rsquo;
at the start of the trace goal;
at the end of the trace goal,
it puts the value of &lsquo;<samp><span class="samp">!.LoggingLevel</span></samp>&rsquo; current then
back into the mutable.

   <p>The intention here is that trace goals
should be able to access mutables that give them information
about the parameters within which they should operate. 
The ability of trace goals to actually <em>update</em> the values of mutables
is intended to allow the implementation of trace goals
whose actions depend on the actions executed by previous trace goals. 
For example, a trace goal could test
whether the current input value is the same as the previous input value,
and if it is, then it can say so instead of printing the value out again. 
Another possibility is a progress message
which is printed not for every item processed, but for every 1000th item,
reassuring users without overwhelming them with a deluge of output.

   <p>This kind of code is the <em>only</em> intended use of this ability. 
Any program in which the value of a mutable set by a trace goal
is inspected by code that is not itself within a trace goal
is explicitly violating the intended uses of trace goals. 
Only the difficulty of implementing the required global program analysis
prevents the language design from outlawing such programs in the first place.

   <p>The compiler will not delete trace goals
from the bodies of the procedures containing them. 
However, trace goals inside a procedure don't prevent
calls to that procedure from being optimized away,
if such optimization is otherwise possible. 
(There is no point in debugging or logging
operations that don't actually occur.) 
In their effect on program optimizations,
trace goals function as a kind of impure code,
but one with an implicit promise_pure around the clause in which they occur. 
<!-- zs: I think saying the following is more likely to confuse than enlighten: -->
<!-- The trace goal scope itself acts -->
<!-- as a promise_pure scope for any impure code inside it. -->

<div class="node">
<a name="Pragmas"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Implementation_002ddependent-extensions">Implementation-dependent extensions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Trace-goals">Trace goals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">18 Pragmas</h2>

<p>The pragma declarations described below are a standard part of the Mercury
language, as are the pragmas for controlling the foreign language interface
(see <a href="#Foreign-language-interface">Foreign language interface</a>) and impurity (see <a href="#Impurity">Impurity</a>). 
As an extension, implementations may also choose to support additional
pragmas with implementation-dependent semantics
(see <a href="#Implementation_002ddependent-extensions">Implementation-dependent extensions</a>).

<ul class="menu">
<li><a accesskey="1" href="#Inlining">Inlining</a>:                     Pragmas can be used to suggest or prevent
                                procedure inlining. 
<li><a accesskey="2" href="#Type-specialization">Type specialization</a>:          Pragmas can be used to produce specialized
                                versions of polymorphic procedures. 
<li><a accesskey="3" href="#Obsolescence">Obsolescence</a>:                 Library developers can declare old versions
                                of predicates or functions to be obsolete. 
<li><a accesskey="4" href="#No-determinism-warnings">No determinism warnings</a>:      Pragmas can be used to suppress warnings
                                about too loose determinism declarations. 
<li><a accesskey="5" href="#Source-file-name">Source file name</a>:             The &lsquo;<samp><span class="samp">source_file</span></samp>&rsquo; pragma and
                                &lsquo;<samp><span class="samp">#</span><var>line</var></samp>&rsquo; directives provide support
                                for preprocessors and other tools that
                                generate Mercury code. 
</ul>

<div class="node">
<a name="Inlining"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Type-specialization">Type specialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragmas">Pragmas</a>

</div>

<h3 class="section">18.1 Inlining</h3>

<p>A declaration of the form

<pre class="example">     :- pragma inline(<var>Name</var>/<var>Arity</var>).
</pre>
   <p class="noindent">is a hint to the compiler that all calls to the predicate(s) or function(s)
with name <var>Name</var> and arity <var>Arity</var> should be inlined.

   <p>The current Mercury implementation is smart enough to inline
simple predicates even without this hint.

   <p>A declaration of the form

<pre class="example">     :- pragma no_inline(<var>Name</var>/<var>Arity</var>).
</pre>
   <p class="noindent">ensures the compiler will not inline this predicate.  This may be used
simply for performance concerns (inlining can cause unwanted code bloat
in some cases) or to prevent possibly dangerous inlining when using
low-level C code.

<div class="node">
<a name="Type-specialization"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Obsolescence">Obsolescence</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Inlining">Inlining</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragmas">Pragmas</a>

</div>

<h3 class="section">18.2 Type specialization</h3>

<p>The overhead of polymorphism can in some cases be significant, especially
where polymorphic predicates make heavy use of class method calls or the
built-in unification and comparison routines. To avoid this, the programmer
can suggest to the compiler that a specialized version of a procedure should
be created for a specific set of argument types.

<ul class="menu">
<li><a accesskey="1" href="#Syntax-and-semantics-of-type-specialization-pragmas">Syntax and semantics of type specialization pragmas</a>
<li><a accesskey="2" href="#When-to-use-type-specialization">When to use type specialization</a>
<li><a accesskey="3" href="#Implementation-specific-details">Implementation specific details</a>
</ul>

<div class="node">
<a name="Syntax-and-semantics-of-type-specialization-pragmas"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#When-to-use-type-specialization">When to use type specialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-specialization">Type specialization</a>

</div>

<h4 class="subsection">18.2.1 Syntax and semantics of type specialization pragmas</h4>

<p>A declaration of the form

<pre class="example">     :- pragma type_spec(<var>Name</var>/<var>Arity</var>, <var>Subst</var>).
     :- pragma type_spec(<var>Name</var>(<var>Modes</var>), <var>Subst</var>).
</pre>
   <p class="noindent">suggests to the compiler that a specialized version of predicate(s)
or function(s) with name <var>Name</var> and arity <var>Arity</var> should be
created with the type substitution given by <var>Subst</var> applied to the
argument types. The second form of the declaration only suggests
specialization of the specified mode of the predicate or function.

   <p>The substitution is written as a conjunction of bindings of the form
&lsquo;<samp><var>TypeVar</var><span class="samp">&nbsp;=&nbsp;</span><var>Type</var></samp>&rsquo;<!-- /@w -->, for example &lsquo;<samp><span class="samp">K&nbsp;=&nbsp;int</span></samp>&rsquo;<!-- /@w --> or
&lsquo;<samp><span class="samp">(K&nbsp;=&nbsp;int,&nbsp;V&nbsp;=&nbsp;list(int))</span></samp>&rsquo;<!-- /@w -->.

   <p>The declarations

<pre class="example">     :- pred map.lookup(map(K, V), K, V).
     :- pragma type_spec(map.lookup/3, K = int).
</pre>
   <p class="noindent">give a hint to the compiler that a version of &lsquo;<samp><span class="samp">map.lookup/3</span></samp>&rsquo; should
be created for integer keys.

   <p>Implementations are free to ignore &lsquo;<samp><span class="samp">pragma type_spec</span></samp>&rsquo; declarations. 
Implementations are also free to perform type specialization
even in the absence of any &lsquo;<samp><span class="samp">pragma type_spec</span></samp>&rsquo; declarations.

<div class="node">
<a name="When-to-use-type-specialization"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Implementation-specific-details">Implementation specific details</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Syntax-and-semantics-of-type-specialization-pragmas">Syntax and semantics of type specialization pragmas</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-specialization">Type specialization</a>

</div>

<h4 class="subsection">18.2.2 When to use type specialization</h4>

<p>The set of types for which a predicate or function should be specialized is
best determined by profiling your application. Overuse of type specialization
will result in code bloat.

   <p>Type specialization of predicates or functions which
unify or compare polymorphic variables is most effective when
the specialized types are built-in types such as &lsquo;<samp><span class="samp">int</span></samp>&rsquo;, &lsquo;<samp><span class="samp">float</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">string</span></samp>&rsquo;, or enumeration types, since their unification and
comparison procedures are simple and can be inlined.

   <p>Predicates or functions which make use of type class method calls
may also be candidates for specialization. Again, this is most effective
when the called type class methods are simple enough to be inlined.

<div class="node">
<a name="Implementation-specific-details"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#When-to-use-type-specialization">When to use type specialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Type-specialization">Type specialization</a>

</div>

<h4 class="subsection">18.2.3 Implementation specific details</h4>

<p>The University of Melbourne Mercury compiler performs user-requested type
specializations when invoked with &lsquo;<samp><span class="samp">--user-guided-type-specialization</span></samp>&rsquo;,
which is enabled at optimization level &lsquo;<samp><span class="samp">-O2</span></samp>&rsquo; or higher. 
However, for the Java back-end, user-requested type specializations
are ignored.

<div class="node">
<a name="Obsolescence"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#No-determinism-warnings">No determinism warnings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Type-specialization">Type specialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragmas">Pragmas</a>

</div>

<h3 class="section">18.3 Obsolescence</h3>

<p>A declaration of the form

<pre class="example">     :- pragma obsolete(<var>Name</var>/<var>Arity</var>).
</pre>
   <p class="noindent">declares that the predicate(s) or function(s)
with name <var>Name</var> and arity <var>Arity</var> are &ldquo;obsolete&rdquo;:
it instructs the compiler to issue a warning whenever the named
predicate(s) or function(s) are used.

   <p>&lsquo;<samp><span class="samp">pragma obsolete</span></samp>&rsquo; declarations are intended for use by library
developers, to allow gradual (rather than abrupt) evolution of library
interfaces.  If a library developer changes the interface of a library
predicate, they should leave the old version of that predicate in the
library, but mark it as obsolete using a &lsquo;<samp><span class="samp">pragma obsolete</span></samp>&rsquo;
declaration, and document how library users should modify their code to
suit the new interface.  The users of the library will then get a
warning if they use obsolete features, and can consult the library
documentation to determine how to fix their code.  Eventually, when the
library developer deems that users have had sufficient warning, they
can remove the old version entirely.

<div class="node">
<a name="No-determinism-warnings"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Source-file-name">Source file name</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Obsolescence">Obsolescence</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragmas">Pragmas</a>

</div>

<h3 class="section">18.4 No determinism warnings</h3>

<p>A declaration of the form

<pre class="example">     :- pragma no_determinism_warning(<var>Name</var>/<var>Arity</var>).
</pre>
   <p class="noindent">tells the compiler not to generate any warnings
that the determinism declarations of procedures of the predicate or function
with name <var>Name</var> and arity <var>Arity</var> are not as tight as they could be.

   <p>&lsquo;<samp><span class="samp">pragma no_determinism_warning</span></samp>&rsquo; declarations are intended for use
in situations in which the code of a predicate has one determinism,
but the declared determinism of the procedure must be looser
due to some outside requirement. 
One such situation is when a set of procedures are all possible values
of the same higher order variable,
which requires them to have the same argument types, modes, and determinisms. 
If (say) most of the procedures are det
but some are erroneous (that is, they always throws an exception),
the procedures that are declared det
but whose bodies have determinism erroneous
will get a warning saying their determinism declaration could be tighter,
unless the programmer specifies this pragma for them.

<div class="node">
<a name="Source-file-name"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#No-determinism-warnings">No determinism warnings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragmas">Pragmas</a>

</div>

<h3 class="section">18.5 Source file name</h3>

<p>The &lsquo;<samp><span class="samp">source_file</span></samp>&rsquo; pragma and &lsquo;<samp><span class="samp">#</span><var>line</var></samp>&rsquo; directives provide
support for preprocessors and other tools that generate Mercury code. 
The tool can insert these directives into the generated Mercury code
to allow the Mercury compiler to report diagnostics (error and warning
messages) at the original source code location, rather than at the
location in the automatically generated Mercury code.

   <p>A &lsquo;<samp><span class="samp">source_file</span></samp>&rsquo; pragma is a declaration of the form

<pre class="example">     :- pragma source_file(<var>Name</var>).
</pre>
   <p class="noindent">where <var>Name</var> is a string that specifies the name of the source file.

   <p>For example, if a preprocessor generated a file <samp><span class="file">foo.m</span></samp> based on a
input file <samp><span class="file">foo.m.in</span></samp>, and it copied lines 20, 30, and 31 from
<samp><span class="file">foo.m.in</span></samp>, the following directives would ensure that any
error or warnings for those lines copied from <samp><span class="file">foo.m</span></samp> were reported
at their original source locations in <samp><span class="file">foo.m.in</span></samp>.

<pre class="example">     :- module foo.
     :- pragma source_file("foo.m.in").
     #20
     % this line comes from line 20 of foo.m
     #30
     % this line comes from line 30 of foo.m
     % this line comes from line 31 of foo.m
     :- pragma source_file("foo.m").
     #10
     % this automatically generated line is line 10 of foo.m
</pre>
   <p>Note that if a generated file contains some text which is copied from a
source file, and some which is automatically generated, it is a good
idea to use &lsquo;<samp><span class="samp">pragma source_file</span></samp>&rsquo; and &lsquo;<samp><span class="samp">#</span><var>line</var></samp>&rsquo; directives
to reset the source file name and line number to point back to the
generated file for the automatically generated text, as in the above
example.

<div class="node">
<a name="Implementation-dependent-extensions"></a>
<a name="Implementation_002ddependent-extensions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bibliography">Bibliography</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragmas">Pragmas</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">19 Implementation-dependent extensions</h2>

<p>The University of Melbourne Mercury implementation supports the following
extensions to the Mercury language:

<ul class="menu">
<li><a accesskey="1" href="#Fact-tables">Fact tables</a>:                  Support for very large tables of facts. 
<!-- XXX STM -->
<!-- The documentation of STM is commented out because its support is -->
<!-- not yet complete. All such lines are preceded by XXX STM. -->
<!-- * Software Transactional Memory:: -->
<!-- Support for synchronisation of threads without -->
<!-- explicit locking. -->
<li><a accesskey="2" href="#Tabled-evaluation">Tabled evaluation</a>:            Support for automatically recording previously
                                calculated results and detecting or avoiding
                                certain kinds of infinite loops. 
<li><a accesskey="3" href="#Termination-analysis">Termination analysis</a>:         Support for automatic proofs of termination. 
<li><a accesskey="4" href="#Feature-sets">Feature sets</a>:                 Support for checking that optional features of
                                the implementation are supported at compile
                                time. 
<li><a accesskey="5" href="#Trailing">Trailing</a>:                     Undoing side-effects on backtracking.

   </ul>
<!-- XXX The `reserved tag' pragma is not documented because it is intended to -->
<!-- be used with `any' insts, which are themselves not yet documented. -->
<!-- Also, it is a quite low-level facility, and very -->
<!-- implementation-specific... -->
<!-- * Reserved tag::		Support for Herbrand constraint solvers. -->

<div class="node">
<a name="Fact-tables"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tabled-evaluation">Tabled evaluation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Implementation_002ddependent-extensions">Implementation-dependent extensions</a>

</div>

<h3 class="section">19.1 Fact tables</h3>

<p>Large tables of facts can be compiled using a different algorithm that
is more efficient and produces more efficient code.

   <p>A declaration of the form

<pre class="example">     :- pragma fact_table(<var>Name</var>/<var>Arity</var>, <var>FileName</var>).
</pre>
   <p class="noindent">tells the compiler that the predicate or function with name <var>Name</var>
and arity <var>Arity</var> is defined by a set of facts in an external file
<var>FileName</var>.  Defining large tables of facts in this way allows the
compiler to use a more efficient algorithm for compiling them. 
This algorithm uses less memory than would normally be required
to compile the facts so much larger tables are possible.

   <p>Each mode is indexed on all its input arguments so the compiler can
produce very efficient code using this technique.

   <p>In the current implementation, the table of facts is compiled into a
separate C file named &lsquo;<samp><var>FileName</var><span class="samp">.c</span></samp>&rsquo;.  The compiler will
automatically generate the correct dependencies for this file when the
command &lsquo;<samp><span class="samp">mmake </span><var>main_module</var><span class="samp">.depend</span></samp>&rsquo; is invoked.  This ensures
that the C file will be compiled to &lsquo;<samp><var>FileName</var><span class="samp">.o</span></samp>&rsquo; and then
linked with the other object files when &lsquo;<samp><span class="samp">mmake </span><var>main_module</var></samp>&rsquo;
is invoked.

   <p>The main limitation of the &lsquo;<samp><span class="samp">fact_table</span></samp>&rsquo; pragma is that
in the current implementation,
predicates or functions defined as fact tables can only have
arguments of types &lsquo;<samp><span class="samp">string</span></samp>&rsquo;, &lsquo;<samp><span class="samp">int</span></samp>&rsquo; or &lsquo;<samp><span class="samp">float</span></samp>&rsquo;.

   <p>Another limitation is that the &lsquo;<samp><span class="samp">--high-level-code</span></samp>&rsquo; back-end does
not support &lsquo;<samp><span class="samp">pragma fact_table</span></samp>&rsquo; for procedures with determinism
&lsquo;<samp><span class="samp">nondet</span></samp>&rsquo; or &lsquo;<samp><span class="samp">multi</span></samp>&rsquo;.

<!-- XXX STM -->
<!-- @node Software Transactional Memory -->
<!-- @section Software Transactional Memory -->
<!-- (Note: Software Transactional Memory is still in development and many -->
<!-- aspects c documented here might change without notice. -->
<!-- Please use with caution.) -->
<!-- Software Transactional Memory or STM -->
<!-- is an method of synchronising access to shared data -->
<!-- between concurrently running threads. -->
<!-- It is an alternative to the use of explicit locking. -->
<!-- The way to synchronise threads using Software Transactional Memory -->
<!-- is through the use of the @samp{atomic} scope. -->
<!-- The syntax of an atomic scope is @code{atomic @var{Params} @var{Goal}}. -->
<!-- @var{Goal} must be a valid goal; -->
<!-- @var{Params} must be a list of atomic parameters -->
<!-- which must include the @samp{outer} and @samp{inner} parameters. -->
<!-- The following example shows the use of the atomic scope: -->
<!-- @example -->
<!-- :- pred add_2_atomically(stm_var(int)::in, io::di, io::uo) is cc_multi. -->
<!-- add_2_atomically(TVar, IO0, IO) :- -->
<!-- atomic [ outer(IO0, IO1), inner(STM0, STM) ] ( -->
<!-- read_stm_var(TVar, X, STM0, STM1), -->
<!-- Y = X + 2, -->
<!-- write_stm_var(TVar, Y, STM1, STM) -->
<!-- ), -->
<!-- io.write_string("Value of Y is ", IO1, IO2), -->
<!-- io.write(Y, IO2, IO3), -->
<!-- io.nl(IO3, IO). -->
<!-- @end example -->
<!-- The @samp{outer} parameter takes a pair of variables of type @samp{io.io}. -->
<!-- As the atomic scope can be seen as an operation which changes the I/O state, -->
<!-- the modes of these variables must be @samp{di} and @samp{uo} respectively. -->
<!-- The @samp{inner} parameter takes a pair of variables of type @samp{stm}. -->
<!-- When the atomic scope is executed, -->
<!-- these variables supply and consume the @samp{stm} state -->
<!-- which can be used by the Software Transactional Memory primitives. -->
<!-- Calling these primitives requires threading the @samp{stm} state -->
<!-- in a way similar to I/O operations and, -->
<!-- as such, the modes of these variables must also be @samp{di} and @samp{uo}. -->
<!-- The code within the atomic scope is restricted -->
<!-- in the same way as code which takes the I/O state. -->
<!-- The code within the atomic scope -->
<!-- must be either @samp{det} or @samp{cc_multi}. -->
<!-- Due to the way Software Transactional Memory provides synchronous behaviour, -->
<!-- it is likely that the goal will be executed more than once. -->
<!-- As it is unknown how many times (if any) the inner goal will be repeated, -->
<!-- only pure code or code which makes use of the @samp{stm} state -->
<!-- should be placed inside an atomic scope. -->
<!-- (Trace goals are permitted but should not be used for any action -->
<!-- that depends on the number of times the goal is executed). -->
<!-- Using the atomic scope requires the program to explicitly import the modules -->
<!-- @samp{stm_builtin}, @samp{exception} and @samp{univ}. -->
<!-- This restriction will soon be dropped, -->
<!-- as the compiler itself will do the required imports. -->
<!-- In STM systems, data shared between threads -->
<!-- is stored in @samp{Transaction Variables}. -->
<!-- This is the only form of shared data -->
<!-- which the atomic scope will synchronise. -->
<!-- @samp{Transaction Variables} can be operated on -->
<!-- using the following predicates: -->
<!-- @example -->
<!-- :- pred new_stm_var(T::in, stm_var(T)::out, io::di, io::uo) is det. -->
<!-- :- pred read_stm_var(stm_var(T)::in, T::out, stm::di, stm::uo) is det. -->
<!-- :- pred write_stm_var(stm_var(T)::in, T::in, stm::di, stm::uo) is det. -->
<!-- @end example -->
<!-- The @samp{new_stm_var} creates a new transaction variable -->
<!-- whose the type and initial value are given by the first argument, -->
<!-- and returns a reference to it. -->
<!-- Only one copy of the transaction variable exists in memory, -->
<!-- but references to it can be duplicated. -->
<!-- Unifications and tests of references -->
<!-- affect only the references themselves, -->
<!-- and do not affect the underlying transaction variables. -->
<!-- To get or set the value of the actual transaction variable, -->
<!-- programs must call -->
<!-- the builtins @samp{read_stm_var} and @samp{write_stm_var}. -->
<!-- These calls take a reference to a transaction variable -->
<!-- and either set or return the value of the transaction variable. -->
<!-- @footnote{In actual fact, write_stm_var does not update the variable. -->
<!-- The update is instead written to a log, -->
<!-- and the real transaction variable is changed -->
<!-- only when the atomic goal has completed -->
<!-- and the whole log has been validated.} -->
<!-- As the calls to @samp{read_stm_var} and @samp{write_stm_var} -->
<!-- take a pair of @samp{stm} states, -->
<!-- they can only appear within an atomic scope. -->
<div class="node">
<a name="Tabled-evaluation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Termination-analysis">Termination analysis</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Fact-tables">Fact tables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Implementation_002ddependent-extensions">Implementation-dependent extensions</a>

</div>

<h3 class="section">19.2 Tabled evaluation</h3>

<p>(Note: &ldquo;Tabled evaluation&rdquo; has no relation to the &ldquo;fact tables&rdquo;
described above.)

   <p>Ordinarily, the results of each procedure call are not recorded;
if the same procedure is called with the same arguments,
then the answer(s) must be recomputed again. 
For some procedures, this recomputation can be very wasteful.

   <p>With tabled evaluation, the implementation keeps a table containing the
previously computed results of the specified procedure;
this table is sometimes called the memo table
(since it &ldquo;remembers&rdquo; previous answers). 
At each procedure call, the implementation will search the memo table
to check whether the answer(s) have already been computed,
and if so, the answers will be returned directly from the memo table
rather than being recomputed. 
This can result in much faster execution, at the cost of additional
space to record answers in the table.

   <p>The implementation can also check at runtime for the situation
where a procedure calls itself recursively with the same arguments,
which would normally result in a infinite loop;
if this situation is encountered, it can (at the programmer's option)
either throw an exception, or avoid the infinite loop
by computing solutions using a &ldquo;minimal model&rdquo; semantics. 
(Specifically, the minimal model computed by our implementation
is the perfect model.)

   <p>The current Mercury implementation supports
three different pragmas for tabling, to cover these three cases:
&lsquo;<samp><span class="samp">loop_check</span></samp>&rsquo;, &lsquo;<samp><span class="samp">memo</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">minimal_model</span></samp>&rsquo;. 
The &lsquo;<samp><span class="samp">loop_check</span></samp>&rsquo; pragma asks only for loop checking. 
With this pragma, the memo table will map each distinct set of input arguments
only to a single boolean saying whether
a call with those arguments is currently active or not;
the pragma's only effect is to cause the predicate to throw an exception
if this boolean says that the current call has the same arguments
as one of its ancestors, which indicates an infinite recursive loop. 
The &lsquo;<samp><span class="samp">memo</span></samp>&rsquo; pragma asks for both loop checking and memoization. 
With this pragma, the memo table will map each distinct set of input arguments
either to the set of results computed previously for those arguments,
or to an indication that the call is still active
and thus those results are still being computed. 
This predicate will thus look for infinite recursive loops
(and throw an exception if and when it finds one)
but it will also record all its solutions in the memo table,
and will avoid recomputing solutions
that are already available in the memo table. 
The &lsquo;<samp><span class="samp">minimal_model</span></samp>&rsquo; pragma asks for the computation
of a &ldquo;minimal model&rdquo; semantics. 
These differ from the &lsquo;<samp><span class="samp">memo</span></samp>&rsquo; pragma in that
the detection of what appears to be an infinite recursive loop is not fatal. 
The implementation will consider the apparently infinitely recursive calls
to fail if the call concerned has no way of computing any solutions
it hasn't already computed and recorded,
and it does have such a way, then it switches the execution to explore
those ways before coming back to the apparently infinitely recursive call.

   <p>The syntax for each of these declarations is

<pre class="example">     :- pragma memo(<var>Name</var>/<var>Arity</var>).
     :- pragma memo(<var>Name</var>/<var>Arity</var>, [<var>list of tabling attributes</var>]).
     :- pragma loop_check(<var>Name</var>/<var>Arity</var>).
     :- pragma loop_check(<var>Name</var>/<var>Arity</var>, [<var>list of tabling attributes</var>]).
     :- pragma minimal_model(<var>Name</var>/<var>Arity</var>).
     :- pragma minimal_model(<var>Name</var>/<var>Arity</var>, [<var>list of tabling attributes</var>]).
</pre>
   <p class="noindent">where <var>Name</var>/<var>Arity</var> specifies
the predicate or function to which the declaration applies. 
The declaration applies to all modes of the predicate and/or function named. 
At most one of these declarations may be specified
for any given predicate or function.

   <p>Programmers can also request the application of tabling
only to one particular mode of a predicate or function,
via declarations such as these:

<pre class="example">     :- pragma memo(<var>Name</var>(in, in, out)).
     :- pragma memo(<var>Name</var>(in, in, out), [<var>list of tabling attributes</var>]).
     :- pragma loop_check(<var>Name</var>(in, out)).
     :- pragma loop_check(<var>Name</var>(in, out), [<var>list of tabling attributes</var>]).
     :- pragma minimal_model(<var>Name</var>(in, in, out, out)).
     :- pragma minimal_model(<var>Name</var>(in, in, out, out), [<var>list of tabling attributes</var>]).
</pre>
   <p>Because all variants of tabling record the values of input arguments,
and all except &lsquo;<samp><span class="samp">loop_check</span></samp>&rsquo; also record the values of output arguments,
you cannot apply any of these pragmas to procedures
whose arguments' modes include any unique component.

   <p>Tabled evaluation of a predicate or function that has an argument whose type
is a foreign type will result in a run-time error unless the foreign type
is one for which the &lsquo;<samp><span class="samp">can_pass_as_mercury_type</span></samp>&rsquo; and &lsquo;<samp><span class="samp">stable</span></samp>&rsquo;
assertions have been made (see <a href="#Using-foreign-types-from-Mercury">Using foreign types from Mercury</a>).

   <p>The optional list of attributes allows programmers
to control some aspects of the management of the memo table(s)
of the procedure(s) affected by the pragma.

   <p>The &lsquo;<samp><span class="samp">allow_reset</span></samp>&rsquo; attribute asks the compiler
to define a predicate that, when called, resets the memo table. 
The name of this predicate will be &ldquo;table_reset_for&rdquo;,
followed by the name of the tabled predicate, followed by its arity,
and (if the predicate has more than one mode) by the mode number
(the first declared mode is mode 0, the second is mode 1, and so on). 
These three or four components are separated by underscores. 
The reset predicate takes a di/uo pair of I/O states as arguments. 
The presence of these I/O state arguments in the reset predicate,
and the fact that tabled predicates cannot have unique arguments
together imply that a memo table cannot be reset
while a call using that memo table is active.

   <p>The &lsquo;<samp><span class="samp">statistics</span></samp>&rsquo; attribute asks the compiler
to define a predicate that, when called,
returns statistics about the memo table. 
The name of this predicate will be &ldquo;table_statistics_for&rdquo;,
followed by the name of the tabled predicate, followed by its arity,
and (if the predicate has more than one mode) by the mode number
(the first declared mode is mode 0, the second is mode 1, and so on). 
These three or four components are separated by underscores. 
The statistics predicate takes three arguments. 
The second and third are a di/uo pair of I/O states,
while the first is an output argument that contains information
about accesses to and modifications of the procedure's memo table,
both since the creation of the table,
and since the last call to this predicate. 
The type of this argument is defined in the file table_builtin.m
in the Mercury standard library. 
That module also contains a predicate for printing out this information
in a programmer-friendly format.

   <p>The remaining two attributes, &lsquo;<samp><span class="samp">fast_loose</span></samp>&rsquo; and &lsquo;<samp><span class="samp">specified</span></samp>&rsquo;,
control how arguments are looked up in the memo table. 
The default implementation
looks up the <em>value</em> of each input argument,
and thus requires time proportional to
the number of function symbols in the input arguments. 
This is the only implementation allowed for minimal model tabling,
but for predicates tabled with the &lsquo;<samp><span class="samp">loop_check</span></samp>&rsquo; and &lsquo;<samp><span class="samp">memo</span></samp>&rsquo; pragmas,
programmers can also choose some other tabling methods.

   <p>The &lsquo;<samp><span class="samp">fast_loose</span></samp>&rsquo; attribute asks the compiler to generate code
that looks up only the <em>address</em> of each input argument in the memo table,
which means that the time required
is linear only in the <em>number</em> of input arguments, not their <em>size</em>. 
The tradeoff is that &lsquo;<samp><span class="samp">fast_loose</span></samp>&rsquo; does not recognize
calls as duplicates if they involve input arguments that are logically equal
but are stored at different locations in memory. 
The following declaration calls for this variant of tabling.

<pre class="example">     :- pragma memo(<var>Name</var>(in, in, in, out),
     	[allow_reset, statistics, fast_loose]).
</pre>
   <p>The &lsquo;<samp><span class="samp">specified</span></samp>&rsquo; attribute allows programmers to choose
individually, for each input argument, whether that argument
should be looked up in the memo table by value or by address,
or whether it should be looked up at all:

<pre class="example">     :- pragma memo(<var>Name</var>(in, in, in, out), [allow_reset, statistics,
     	specified([value, addr, promise_implied, output])]).
</pre>
   <p>The &lsquo;<samp><span class="samp">specified</span></samp>&rsquo; attribute should have an argument which is a list,
and this list should contain one element
for each argument of the predicate or function concerned
(if a function, the last element is for the return value). 
For output arguments, the list element should be &lsquo;<samp><span class="samp">output</span></samp>&rsquo;. 
For input arguments, the list element may be
&lsquo;<samp><span class="samp">value</span></samp>&rsquo;, &lsquo;<samp><span class="samp">addr</span></samp>&rsquo; or &lsquo;<samp><span class="samp">promise_implied</span></samp>&rsquo;. 
The first calls for tabling the argument by value,
the second calls for tabling the argument by address,
and the third calls for not tabling the argument at all. 
This last course of action promises that any two calls
that agree on the values of the value-tabled input arguments
and on the addresses of the address-tabled input arguments
will behave the same regardless of the values of the untabled input arguments. 
In most cases, this will mean that the values of the untabled arguments
are implied by the values of the value-tabled arguments
and the addresses of the address-tabled arguments,
though the promise can also be fulfilled
if the table predicate or function does not actually use
the untabled argument for computing any of its output. 
(It is ok for it to use the untabled argument
to decide what exception to throw.)

<!-- Experimental: -->
<!-- The @samp{specified} attribute can additionally take an argument after -->
<!-- the list, which is either @samp{hidden_arg_value} or @samp{hidden_arg_addr}. -->
<!-- If @samp{hidden_arg_addr} is specified, extra arguments introduced by the -->
<!-- compiler will be tabled by address, otherwise they are tabled by value. -->
<!-- @samp{hidden_arg_value} is assumed if neither is present. -->
   <p>If the tabled predicate or function has only one mode,
then this declaration can also be specified without giving the argument modes:

<pre class="example">     :- pragma memo(<var>Name</var>/<var>Arity</var>, [allow_reset, statistics,
     	specified([value, addr, promise_implied, output])]).
</pre>
   <p>Note that a &lsquo;<samp><span class="samp">pragma minimal_model</span></samp>&rsquo; declaration
changes the declarative semantics of the specified predicate or function:
instead of using the completion of the clauses as the basis for the semantics,
as is normally the case in Mercury,
the declarative semantics that is used is a &ldquo;minimal model&rdquo; semantics,
specifically, the perfect model semantics. 
Anything which is true or false in the completion semantics
is also true or false (respectively) in the perfect model semantics,
but there are goals for which the perfect model specifies
that the result is true or false,
whereas the completion semantics leaves the result unspecified. 
For these goals, the usual Mercury semantics requires the
implementation to either loop or report an error message,
but the perfect model semantics requires a particular answer to be returned. 
In particular, the perfect model semantics says that
any call that is not true in <em>all</em> models is false.

   <p>Programmers should therefore use a &lsquo;<samp><span class="samp">pragma minimal_model</span></samp>&rsquo; declaration
only in cases where their intended interpretation for a procedure
coincides with the perfect model for that procedure. 
Fortunately, however, this is usually what programmers intend.

<!-- XXX give an example -->
   <p>For more information on tabling, see K. Sagonas's PhD thesis
<!-- XXX this citation doesn't come out properly in DVI format -->
<cite>The SLG-WAM: A Search-Efficient Engine for Well-Founded Evaluation
of Normal Logic Programs.</cite> See <a href="#g_t_005b4_005d">[4]</a>. 
The operational semantics of procedures with a &lsquo;<samp><span class="samp">pragma minimal_model</span></samp>&rsquo;
declaration corresponds to what Sagonas calls &ldquo;SLGd resolution&rdquo;.

   <p>In the general case,
the execution mechanism required by minimal model tabling is quite complicated,
requiring the ability to delay goals and then wake them up again. 
The Mercury implementation uses a technique based on
copying relevant parts of the stack to the heap when delaying goals. 
It is described in
<!-- XXX this citation may not come out properly in DVI format -->
<cite>Tabling in Mercury: design and implementation</cite>
by Z. Somogyi and K. Sagonas,
Proceedings of the Eight International Symposium
on Practical Aspects of Declarative Languages.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<strong>Please note:</strong>
the current implementation of tabling does not support
all the possible compilation grades
(see the &ldquo;Compilation model options&rdquo; section of the Mercury User's Guide)
allowed by the Mercury implementation. 
In particular, minimal model tabling is incompatible with
high level code, the use of trailing, and accurate garbage collection. 
</td></tr></table>

<div class="node">
<a name="Termination-analysis"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Feature-sets">Feature sets</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tabled-evaluation">Tabled evaluation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Implementation_002ddependent-extensions">Implementation-dependent extensions</a>

</div>

<h3 class="section">19.3 Termination analysis</h3>

<p>The compiler includes a termination analyser which can be used to prove
termination of predicates and functions.  Details of the analysis is
available in &ldquo;Termination Analysis for Mercury&rdquo; by Chris Speirs, Zoltan
Somogyi and Harald Sondergaard.  See <a href="#g_t_005b1_005d">[1]</a>. 
<!-- XXX this citation doesn't come out properly in DVI format -->

   <p>The analysis is based around an algorithm proposed by Gerhard Groger
and Lutz Plumer in their paper &ldquo;Handling of mutual recursion in
automatic termination proofs for logic programs.&rdquo; See <a href="#g_t_005b2_005d">[2]</a>. 
<!-- XXX this citation doesn't come out properly in DVI format -->

   <p>For an introduction to termination analysis for logic programs, please
refer to &ldquo;Termination Analysis for Logic Programs&rdquo; by Chris Speirs. 
<!-- XXX this citation doesn't come out properly in DVI format -->
See <a href="#g_t_005b3_005d">[3]</a>.

   <p>Information about the termination properties of a predicate or function
can be given to the compiler.  Pragmas are also available to require
the compiler to prove termination of a given predicate or function, or
to give an error message if it cannot do so.

   <p>The analyser is enabled by the option &lsquo;<samp><span class="samp">--enable-termination</span></samp>&rsquo;, which
can be abbreviated to &lsquo;<samp><span class="samp">--enable-term</span></samp>&rsquo;.  When termination analysis
is enabled, any predicates or functions with a &lsquo;<samp><span class="samp">check_termination</span></samp>&rsquo;
pragma defined on them will have their termination checked, and if
termination cannot be proved, the compiler will emit an error message
detailing the reason that termination could not be proved.

   <p>The option &lsquo;<samp><span class="samp">--check-termination</span></samp>&rsquo;, which may be abbreviated
to &lsquo;<samp><span class="samp">--check-term</span></samp>&rsquo; or &lsquo;<samp><span class="samp">--chk-term</span></samp>&rsquo;, forces the compiler to
check the termination of all predicates in the module. 
It is common for the compiler to be unable to prove termination of some
predicates and functions because they call other predicates which could
not be proved to terminate or because they use language features (such
as higher order calls) which cannot be usefully analysed. 
In this case, the compiler only emits a warning for these
predicates and functions if the &lsquo;<samp><span class="samp">--verbose-check-termination</span></samp>&rsquo;
option is enabled.  For every predicate or function that the compiler
cannot prove the termination of, a warning message is emitted, but
compilation continues.  The &lsquo;<samp><span class="samp">--check-termination</span></samp>&rsquo; option implies
the &lsquo;<samp><span class="samp">--enable-termination</span></samp>&rsquo; option.

   <p>The accuracy of the termination analysis is substantially degraded if
intermodule optimization is not enabled.  Unless intermodule
optimization is enabled, the compiler must assume that any imported
predicate may not terminate.

   <p>By default, the compiler assumes that a procedure defined
using the foreign language interface will terminate for all input
if it does not call Mercury.  If it does call Mercury then by default
the compiler will assume that it may not terminate.

   <p>The foreign code attributes &lsquo;<samp><span class="samp">terminates</span></samp>&rsquo;/&lsquo;<samp><span class="samp">does_not_terminate</span></samp>&rsquo;
may be used to force the compiler to treat a foreign_proc as
terminating/non-terminating irrespective of whether it calls Mercury. 
As a matter of style, it is preferable to use foreign code attributes
for foreign_procs rather than the termination pragmas described below.

   <p>The following declarations can be used to inform the compiler of the
termination properties of a predicate or function.

<pre class="example">     :- pragma terminates(<var>Name</var>/<var>Arity</var>).
</pre>
   <p>This declaration may be used to inform the compiler that this predicate
or function is guaranteed to terminate for any input.  This is useful
when the compiler cannot prove termination of some predicates or
functions which are in turn preventing the compiler from proving
termination of other predicates or functions.  This declaration
affects not only the predicate specified but also
any other predicates that are mutually recursive with it.

<pre class="example">     :- pragma does_not_terminate(<var>Name</var>/<var>Arity</var>).
</pre>
   <p>This declaration may be used to inform the compiler that this predicate
may not terminate.  This declaration affects not only the predicate
specified but also any other predicates that are mutually recursive
with it.

<pre class="example">     :- pragma check_termination(<var>Name</var>/<var>Arity</var>).
</pre>
   <p>This pragma forces the compiler to prove termination of this predicate. 
If it cannot prove the termination of the specified predicate or
function then the compiler will quit with an error message.

<!-- XXX The `reserved tag' pragma is not documented because it is intended to -->
<!-- be used with `any' insts, which are themselves not yet documented. -->
<!-- Also, it is a quite low-level facility, and very -->
<!-- implementation-specific... -->
<!-- @node Reserved tag -->
<!-- @section Reserved tag -->
<!-- The University of Melbourne Mercury implementation includes some fairly -->
<!-- low-level support for implementing Herbrand constraint solvers -->
<!-- (i.e. Prolog-style logic variables). -->
<!-- In particular, you can use the @samp{reserve_tag} pragma -->
<!-- to tell the compiler to reserve a tag in the data representation -->
<!-- for a type.  The intent is for this tag to be used to represent -->
<!-- unbound variables with inst @samp{any}. -->
<!-- The @samp{reserve_tag} pragma declaration has the following form: -->
<!-- @example -->
<!-- :- pragma reserve_tag(@var{type-name} / @var{type-arity}). -->
<!-- @end example -->
<!-- The @var{type-name} and @var{type-arity} must specify the name -->
<!-- and arity of a discriminated union type defined in the same module, -->
<!-- and the @samp{reserve_tag} pragma must occur in the same section -->
<!-- (interface or implementation) of the module as the type definition. -->
<!-- The effect of this declaration is that values whose primary -->
<!-- tag is zero are reserved for use in representing unbound variables. -->
<!-- Note that to actually create an unbound variable, you need to -->
<!-- use the foreign language interface code, and the code will probably -->
<!-- need to be aware of the Mercury compiler's data representation. -->
<!-- The @samp{reserve_tag} pragma has the same effect to the -->
<!-- @samp{-reserve-tag} compiler option (which is documented -->
<!-- in the Mercury user's guide), -->
<!-- except that the pragma applies just to the specified type, -->
<!-- whereas the compiler option applies to discriminated union types -->
<!-- in the program. -->
<!-- Note that neither the @samp{reserve_tag} pragma nor the @samp{-reserve-tag} -->
<!-- compiler option will have any useful effect if the @samp{-high-level-data} -->
<!-- option is used (e.g. for the .NET or Java back-ends). -->
<!-- XXX TO DO! -->
<!-- @node Compile-time garbage collection -->
<!-- @section Compile-time garbage collection -->
<!-- The compiler includes a compile-time garbage collection system (CTGC). This -->
<!-- system consists of a structure sharing analysis, followed by a structure -->
<!-- reuse analysis. -->
<!-- @node Structure sharing analysis -->
<!-- @subsection Structure sharing analysis -->
<!-- The compiler includes a structure sharing analysis system. -->
<!-- @node Structure reuse analysis -->
<!-- @subsection Structure reuse analysis -->
<!-- The compiler includes a structure reuse analysis system. -->
<div class="node">
<a name="Feature-sets"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Trailing">Trailing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Termination-analysis">Termination analysis</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Implementation_002ddependent-extensions">Implementation-dependent extensions</a>

</div>

<h3 class="section">19.4 Feature sets</h3>

<p>The University of Melbourne Mercury implementation supports a number
of optional compilation model features,
such as <a href="#Trailing">Trailing</a> or <a href="#Tabled-evaluation">Tabled evaluation</a>. 
Feature sets allow the programmer to assert that a module requires
the presence of one or more optional features in the compilation model. 
These assertions can be made use a &lsquo;<samp><span class="samp">pragma require_feature_set</span></samp>&rsquo;
declaration.

   <p>The &lsquo;<samp><span class="samp">require_feature_set</span></samp>&rsquo; pragma declaration has the following form:
<pre class="example">     :- pragma require_feature_set(<var>Features</var>).
</pre>
   <p>where &lsquo;<samp><span class="samp">Features</span></samp>&rsquo; is a (possibly empty) list of features.

   <p>The supported features are:
     <dl>
<dt>&lsquo;<samp><span class="samp">concurrency</span></samp>&rsquo;<dd>This specifies that the compilation model must
support concurrent execution of multiple threads.

     <br><dt>&lsquo;<samp><span class="samp">single_prec_float</span></samp>&rsquo;<dd>This specifies that the compilation model must use
single precision floats. 
This feature cannot be specified together with the &lsquo;<samp><span class="samp">double_prec_float</span></samp>&rsquo;
feature.

     <br><dt>&lsquo;<samp><span class="samp">double_prec_float</span></samp>&rsquo;,<dd>This feature specifies that the compilation model must use double precision
floats. 
This feature cannot be specified together with the &lsquo;<samp><span class="samp">single_prec_float</span></samp>&rsquo;
feature.

     <br><dt>&lsquo;<samp><span class="samp">memo</span></samp>&rsquo;<dd>This feature specifies that the compilation model must support memoisation
(see <a href="#Tabled-evaluation">Tabled evaluation</a>).

     <br><dt>&lsquo;<samp><span class="samp">parallel_conj</span></samp>&rsquo;<dd>This feature specifies that the compilation model must support
parallel execution of conjunctions. 
This feature cannot be specified together with the &lsquo;<samp><span class="samp">trailing</span></samp>&rsquo;
feature.

     <br><dt>&lsquo;<samp><span class="samp">trailing</span></samp>&rsquo;<dd>This feature specifies that the compilation model must support
trailing, see <a href="#Trailing">Trailing</a>. 
This feature cannot be specified together with the &lsquo;<samp><span class="samp">parallel_conj</span></samp>&rsquo;
feature.

     <br><dt>&lsquo;<samp><span class="samp">strict_sequential</span></samp>&rsquo;<dd>This feature specifies that a semantics that is equivalent to the strict
sequential operational semantics must be used.

     <br><dt>&lsquo;<samp><span class="samp">conservative_gc</span></samp>&rsquo;<dd>This feature specifies that a module requires conservative garbage
collection. 
This feature is only checked when using the C backends
It is ignored by the non-C backends.

   </dl>

   <p>When a module containing a &lsquo;<samp><span class="samp">pragma require_feature_set</span></samp>&rsquo; declaration
is compiled, the implementation checks to see that the specified features
are supported by the compilation model. 
It emits an error if they are not.

   <p>A &lsquo;<samp><span class="samp">pragma require_feature_set</span></samp>&rsquo; may only occur in the implementation
section of a module.

   <p>A &lsquo;<samp><span class="samp">pragma require_feature_set</span></samp>&rsquo; affects only the module in which
it occurs; in particular it does not affect any sub-modules

   <p>If a module contains multiple &lsquo;<samp><span class="samp">pragma require_feature_set</span></samp>&rsquo; declarations
then the implementation should emit an error if any of them specifies a
feature that is not supported by the compilation model.

<div class="node">
<a name="Trailing"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Feature-sets">Feature sets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Implementation_002ddependent-extensions">Implementation-dependent extensions</a>

</div>

<h3 class="section">19.5 Trailing</h3>

<p>In certain compilation grades (see the &ldquo;Compilation model options&rdquo;
section of the Mercury User's Guide), the University of Melbourne
Mercury implementation supports trailing.  Trailing is a means
of having side-effects, such as destructive updates to data structures,
undone on backtracking.  The basic idea is that during forward
execution, whenever you perform a destructive modification to
a data structure that may still be live on backtracking,
you should record whatever information is necessary to restore it
on a stack-like data structure called the &ldquo;trail&rdquo;.  Then, if
a computation fails, and execution backtracks to before
those updates were performed, the Mercury runtime engine will
traverse the trail back to the most recent choice point,
undoing all those updates.

   <p>The interface used is a set of C functions (which are actually
implemented as macros) and types.  Typically these will be
called from C code within &lsquo;<samp><span class="samp">pragma foreign_proc</span></samp>&rsquo; or
&lsquo;<samp><span class="samp">pragma foreign_code</span></samp>&rsquo; declarations in Mercury code.

   <p>For an example of the use of this interface, see the module
<samp><span class="file">extras/trailed_update/tr_array.m</span></samp> in the Mercury extras distribution.

<ul class="menu">
<li><a accesskey="1" href="#Choice-points">Choice points</a>
<li><a accesskey="2" href="#Value-trailing">Value trailing</a>
<li><a accesskey="3" href="#Function-trailing">Function trailing</a>
<li><a accesskey="4" href="#Delayed-goals-and-floundering">Delayed goals and floundering</a>
<li><a accesskey="5" href="#Avoiding-redundant-trailing">Avoiding redundant trailing</a>
</ul>

<div class="node">
<a name="Choice-points"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Value-trailing">Value trailing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Trailing">Trailing</a>

</div>

<h4 class="subsection">19.5.1 Choice points</h4>

<p>A &ldquo;choice point&rdquo; is a point in the computation to
which execution might backtrack when a goal fails or
throws an exception.  The &ldquo;current&rdquo;
choice point is the one that was most recently
encountered; that is also the one to which execution
will branch if the current computation fails.

   <p>When you trail an update, the Mercury engine will ensure that if
execution ever backtracks to the choice point that was current
at the time of trailing, then the update will be undone.

   <p>If the Mercury compiler determines that it will never
need to backtrack to a particular choice point, then it will
&ldquo;prune&rdquo; away that choice point.  If a choice point is pruned,
the trail entries for those updates will not necessarily be discarded,
because in general they may still be necessary in case we backtrack
to a prior choice point.

<div class="node">
<a name="Value-trailing"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Function-trailing">Function trailing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Choice-points">Choice points</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Trailing">Trailing</a>

</div>

<h4 class="subsection">19.5.2 Value trailing</h4>

<p>The simplest form of trailing is value trailing. 
This allows you to trail updates to memory and have
the Mercury runtime engine automatically undo them
on backtracking.

     <dl>
<dt><b>&bull; </b><code>MR_trail_value()</code><dd>Prototype:
     <pre class="example">          void MR_trail_value(MR_Word *<var>address</var>, MR_Word <var>value</var>);
</pre>
     <p>Ensures that if future execution backtracks to the
current choice point, then <var>value</var> will be placed in <var>address</var>.
     <pre class="sp">
     
     </pre>
     <br><dt><b>&bull; </b><code>MR_trail_current_value()</code><dd>Prototype:
     <pre class="example">          void MR_trail_current_value(MR_Word *<var>address</var>);
</pre>
     <p>Ensures that if future execution backtracks to the
current choice point, the value currently in <var>address</var>
will be restored.

     <p>&lsquo;<samp><span class="samp">MR_trail_current_value(</span><var>address</var><span class="samp">)</span></samp>&rsquo; is equivalent to
&lsquo;<samp><span class="samp">MR_trail_value(</span><var>address</var><span class="samp">, *</span><var>address</var><span class="samp">)</span></samp>&rsquo;.

   </dl>

   <p>Note that <var>address</var> must be word aligned for
both <code>MR_trail_current_value()</code> and <code>MR_trail_value()</code>. 
(The address of Mercury data structures that have been passed to
C via the foreign language interface are guaranteed to be appropriately
aligned.)

<div class="node">
<a name="Function-trailing"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Delayed-goals-and-floundering">Delayed goals and floundering</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Value-trailing">Value trailing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Trailing">Trailing</a>

</div>

<h4 class="subsection">19.5.3 Function trailing</h4>

<p>For more complicated uses of trailing, you can store the address
of a C function on the trail and have the Mercury runtime call your
function back whenever future execution backtracks to the current choice point
or earlier, or whenever that choice point is pruned, because execution
commits to never backtracking over that point,
or whenever that choice point is garbage collected.

   <p>Note the garbage collector in the current Mercury implementation
does not garbage-collect the trail; this case is mentioned
only so that we can cater for possible future extensions.

     <dl>
<dt><b>&bull; </b><code>MR_trail_function()</code><dd>Prototype:
     <pre class="example">          typedef enum {
                  MR_undo,
                  MR_exception,
                  MR_retry,
                  MR_commit,
                  MR_solve,
                  MR_gc
          } MR_untrail_reason;
          
          void MR_trail_function(
                  void (*<var>untrail_func</var>)(void *, MR_untrail_reason),
                  void *<var>value</var>
          );
</pre>
     <p class="noindent">A call to &lsquo;<samp><span class="samp">MR_trail_function(</span><var>untrail_func</var><span class="samp">, </span><var>value</var><span class="samp">)</span></samp>&rsquo;
adds an entry to the function trail. 
The Mercury implementation ensures that
if future execution ever backtracks to current choicepoint,
or backtracks past the current choicepoint to some earlier choicepoint,
then <code>(*</code><var>untrail_func</var><code>)(</code><var>value</var><code>, </code><var>reason</var><code>)</code> will be called,
where <var>reason</var> will be &lsquo;<samp><span class="samp">MR_undo</span></samp>&rsquo; if the backtracking was due to
a goal failing, &lsquo;<samp><span class="samp">MR_exception</span></samp>&rsquo; if the backtracking was due to
a goal throwing an exception, or &lsquo;<samp><span class="samp">MR_retry</span></samp>&rsquo; if the backtracking
was due to the use of the &ldquo;retry&rdquo; command in &lsquo;<samp><span class="samp">mdb</span></samp>&rsquo;, the Mercury debugger,
or any similar user request in a debugger. 
The Mercury implementation also ensures that if the current choice point is
pruned because execution commits to never backtracking to it,
then <code>(*</code><var>untrail_func</var><code>)(</code><var>value</var><code>, MR_commit)</code> will be called. 
It also ensures that if execution requires that the current goal be
solvable, then <code>(*</code><var>untrail_func</var><code>)(</code><var>value</var><code>, MR_solve)</code>
will be called.  This happens in calls to <code>solutions/2</code>, for example. 
(<code>MR_commit</code> is used for &ldquo;hard&rdquo; commits, i.e. when we commit
to a solution and prune away the alternative solutions; <code>MR_solve</code>
is used for &ldquo;soft&rdquo; commits, i.e. when we must commit to a solution
but do not prune away all the alternatives.)

     <p>MR_gc is currently not used &mdash;
it is reserved for future use.

   </dl>

   <p>Typically if the <var>untrail_func</var> is called with <var>reason</var> being
&lsquo;<samp><span class="samp">MR_undo</span></samp>&rsquo;, &lsquo;<samp><span class="samp">MR_exception</span></samp>&rsquo;, or &lsquo;<samp><span class="samp">MR_retry</span></samp>&rsquo;, then it should undo
the effects of the update(s) specified by <var>value</var>, and then free any
resources associated with that trail entry.  If it is called with <var>reason</var>
being &lsquo;<samp><span class="samp">MR_commit</span></samp>&rsquo; or &lsquo;<samp><span class="samp">MR_solve</span></samp>&rsquo;, then it should not undo the
update(s); instead, it may check for floundering (see the next section). 
In the &lsquo;<samp><span class="samp">MR_commit</span></samp>&rsquo; case it may, in some cases, be possible to
also free resources associated with the trail entry. 
If it is called with anything else (such as &lsquo;<samp><span class="samp">MR_gc</span></samp>&rsquo;),
then it should probably abort execution with an error message.

   <p>Note that the address of the C function passed as the first argument of
<code>MR_trail_function()</code> must be word aligned.

<div class="node">
<a name="Delayed-goals-and-floundering"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Avoiding-redundant-trailing">Avoiding redundant trailing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Function-trailing">Function trailing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Trailing">Trailing</a>

</div>

<h4 class="subsection">19.5.4 Delayed goals and floundering</h4>

<p>Another use for the function trail is check for floundering
in the presence of delayed goals.

   <p>Often, when implementing certain kinds of constraint solvers, it may
not be possible to actually solve all of the constraints at the time
they are added.  Instead, it may be necessary to simply delay their
execution until a later time, in the hope the constraints may become
solvable when more information is available.  If you do implement a
constraint solver with these properties, then at certain points in
the computation &mdash; for example, after executing a negated goal &mdash; it
is important for the system to check that their are no outstanding
delayed goals which might cause failure, before execution commits
to this execution path.  If there are any such delayed goals, the
computation is said to &ldquo;flounder&rdquo;.  If the check for floundering was
omitted, then it could lead to unsound behaviour,  such as a negation
failing even though logically speaking it ought to have succeeded.

   <p>The check for floundering can be implemented using the function trail,
by simply calling &lsquo;<samp><span class="samp">MR_trail_function()</span></samp>&rsquo; to add a function trail
entry whenever you create a delayed goal, and putting the appropriate
check for floundering in the &lsquo;<samp><span class="samp">MR_commit</span></samp>&rsquo; and &lsquo;<samp><span class="samp">MR_solve</span></samp>&rsquo; cases
of your function. 
The Mercury extras distribution includes an example of this:
see the &lsquo;<samp><span class="samp">ML_var_untrail_func()</span></samp>&rsquo; function in the file
&lsquo;<samp><span class="samp">extras/trailed_update/var.m</span></samp>&rsquo;.) 
If your function does detect floundering, then it should print
an error message and then abort execution.

<div class="node">
<a name="Avoiding-redundant-trailing"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Delayed-goals-and-floundering">Delayed goals and floundering</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Trailing">Trailing</a>

</div>

<h4 class="subsection">19.5.5 Avoiding redundant trailing</h4>

<p>If a mutable data structure is updated multiple times, and each update
is recorded on the trail using the functions described above, then
some of this trailing may be redundant.  It is generally not necessary
to record enough information to recover the original state of the
data structure for <em>every</em> update on the trail; instead, it is
enough to record the original state of each updated data structure
just once for each choice point occurring after the data structure
is allocated, rather than once for each update.

   <p>The functions described below provide a means to avoid
redundant trailing.

     <dl>
<dt><b>&bull; </b><code>MR_ChoicepointId</code><dd>Declaration:
     <pre class="example">          typedef ... MR_ChoicepointId;
</pre>
     <p>The type <code>MR_ChoicepointId</code> is an abstract type used
to hold the identity of a choice point.  Values of this
type can be compared using C's &lsquo;<samp><span class="samp">==</span></samp>&rsquo; operator
or using &lsquo;<samp><span class="samp">MR_choicepoint_newer()</span></samp>&rsquo;.
     <pre class="sp">
     
     </pre>
     <br><dt><b>&bull; </b><code>MR_current_choicepoint_id()</code><dd>Prototype:
     <pre class="example">          MR_ChoicepointId MR_current_choicepoint_id(void);
</pre>
     <p><code>MR_current_choicepoint_id()</code> returns a value indicating
the identity of the most recent choice point; that is, the
point to which execution would backtrack if the current computation
failed. 
The value remains meaningful if the choicepoint is pruned
away by a commit, but is not meaningful after backtracking
past the point where the choicepoint was created (since
choicepoint ids may be reused after backtracking).
     <pre class="sp">
     
     </pre>
     <br><dt><b>&bull; </b><code>MR_null_choicepoint_id()</code><dd>Prototype:
     <pre class="example">          MR_ChoicepointId MR_null_choicepoint_id(void);
</pre>
     <p><code>MR_null_choicepoint_id()</code> returns a &ldquo;null&rdquo; value that is
distinct from any value ever returned by <code>MR_current_choicepoint_id</code>. 
(Note that <code>MR_null_choicepoint_id()</code>
is a macro that is guaranteed to be suitable for use as a
static initializer, so that it can for example be used to
provide the initial value of a C global variable.)
     <pre class="sp">
     
     </pre>
     <br><dt><b>&bull; </b><code>MR_choicepoint_newer()</code><dd>Prototype:
     <pre class="example">          bool MR_choicepoint_newer(MR_ChoicepointId, MR_ChoicepointId);
</pre>
     <p><code>MR_choicepoint_newer(x, y)</code> true iff the choicepoint indicated by
&lsquo;<samp><span class="samp">x</span></samp>&rsquo; is newer than (i.e. was created more recently than) the
choicepoint indicated by &lsquo;<samp><span class="samp">y</span></samp>&rsquo;.  The null ChoicepointId is considered
older than any non-null ChoicepointId.  If either of the choice points
have been backtracked over, the behaviour is undefined.

   </dl>

   <p>The way these functions are generally used is as follows. 
When you create a mutable data structure, you should call
<code>MR_current_choicepoint_id()</code> and save the value it returns
as a &lsquo;<samp><span class="samp">prev_choicepoint</span></samp>&rsquo; field in your data structure. 
When you are about to modify your mutable data structure,
you can then call <code>MR_current_choicepoint_id()</code> again and
compare the result from that call with the value saved in
the &lsquo;<samp><span class="samp">prev_choicepoint</span></samp>&rsquo; field in the data structure
using <code>MR_choicepoint_newer()</code>. 
If the current choicepoint is newer, then you must trail the update,
and update the &lsquo;<samp><span class="samp">prev_choicepoint</span></samp>&rsquo; field with the new value;
furthermore, you must also take care that on backtracking the
previous value of the &lsquo;<samp><span class="samp">prev_choicepoint</span></samp>&rsquo; field in your data
structure is restored to its previous value, by trailing that update too. 
But if <code>MR_current_choice_id()</code> is not newer than the
<code>prev_choicepoint</code> field, then you can safely perform
the update to your data structure without trailing it.

   <p>If your mutable data structure is a C global variable,
then you can use <code>MR_null_choicepoint_id()</code>
for the initial value of the &lsquo;<samp><span class="samp">prev_choicepoint</span></samp>&rsquo; field. 
If on the other hand your mutable data structure
is created by a predicate or function that uses tabled evaluation
(see <a href="#Tabled-evaluation">Tabled evaluation</a>),
then you <em>should</em> use <code>MR_null_choicepoint_id()</code>
for the initial value of the field. 
Doing so will ensure that the data will be reset to its initial value
if execution backtracks to a point before
the mutable data structure was created,
which is important because this copy of the mutable data structure
will be tabled and will therefore be produced again
if later execution attempts to create another instance of it.

   <p>For an example of avoiding redundant trailing, see the sample module below.

   <p>Note that there is a cost to this &mdash; you have to include
an extra field in your data structure for each part of
the data structure which you might update, you
need to perform a test for each update to decide whether
or not to trail it, and if you do need to trail the update,
then you have an extra field that you need to trail. 
Whether or not the benefits from avoiding redundant trailing
outweigh these costs will depend on your application.

<pre class="example">     :- module trailing_example.
     :- interface.
     
     :- type int_ref.
     
         % Create a new int_ref with the specified value.
         %
     :- pred new_int_ref(int_ref::uo, int::in) is det.
     
         % update_int_ref(Ref0, Ref, OldVal, NewVal).
         % Ref0 has value OldVal and Ref has value NewVal.
         %
     :- pred update_int_ref(int_ref::mdi, int_ref::muo, int::out, int::in)
         is det.
     
     :- implementation.
     
     :- pragma foreign_decl("C", "
     
     typedef struct {
         MR_ChoicepointId prev_choicepoint;
         MR_Integer data;
     } C_IntRef;
     
     ").
     
     :- pragma foreign_type("C", int_ref, "C_IntRef *").
     
     :- pragma foreign_proc("C",
         new_int_ref(Ref::uo, Value::in),
         [will_not_call_mercury, promise_pure],
     "
         C_Intref *x = malloc(sizeof(C_IntRef));
         x-&gt;prev_choicepoint = MR_current_choicepoint_id();
         x-&gt;data = Value;
         Ref = x;
     ").
     
     :- pragma foreign_proc("C",
         update_int_ref(Ref0::mdi, Ref::muo, OldValue::out, NewValue::in),
         [will_not_call_mercury, promise_pure],
     "
         C_IntRef *x = Ref0;
         OldValue = x-&gt;data;
     
         /* Check whether we need to trail this update. */
         if (MR_choicepoint_newer(MR_current_choicepoint_id(),
             x-&gt;prev_choicepoint))
         {
             /*
             ** Trail both x-&gt;data and x-&gt;prev_choicepoint,
             ** since we're about to update them both.
             */
             assert(sizeof(x-&gt;data) == sizeof(MR_Word));
             assert(sizeof(x-&gt;prev_choicepoint) == sizeof(MR_Word));
             MR_trail_current_value((MR_Word *)&amp;x-&gt;data);
             MR_trail_current_value((MR_Word *)&amp;x-&gt;prev_choicepoint);
     
             /*
             ** Update x-&gt;prev_choicepoint to indicate that
             ** x-&gt;data's previous value has been trailed
             ** at this choice point.
             */
             x-&gt;prev_choicepoint = MR_current_choicepoint_id();
         }
         x-&gt;data = NewValue;
         Ref = Ref0;
     ").
     
</pre>
   <!-- @item @code{void MR_untrail_to(MR_TrailEntry *@var{old_trail_ptr}, MR_untrail_reason @var{reason});} -->
<!-- Apply all the trail entries between @samp{MR_trail_ptr} and -->
<!-- @var{old_trail_ptr}, using the specified @var{reason}. -->
<!-- This function is called by the Mercury engine after backtracking, -->
<!-- after a commit, or after catching an exception. -->
<!-- There is probably little need for user code to call this function, -->
<!-- but it might be needed if you're doing certain low-level things -->
<!-- such as implementing your own exception handling. -->
<div class="node">
<a name="Bibliography"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Implementation_002ddependent-extensions">Implementation-dependent extensions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">20 Bibliography</h2>

<ul class="menu">
<li><a accesskey="1" href="#g_t_005b1_005d">[1]</a>:          Spiers, Somogyi, and Sondergaard,
                <cite>Termination Analysis for Mercury</cite>. 
<li><a accesskey="2" href="#g_t_005b2_005d">[2]</a>:         	Groger and Plumer, <cite>Handling of mutual recursion in
                automatic termination proofs for logic programs</cite>. 
<li><a accesskey="3" href="#g_t_005b3_005d">[3]</a>:          Spiers, <cite>Termination Analysis for logic programs</cite>. 
<li><a accesskey="4" href="#g_t_005b4_005d">[4]</a>:          Sagonas, <cite>The SLG-WAM: A Search-Efficient Engine
                for Well-Founded Evaluation of Normal Logic Programs</cite>. 
<li><a accesskey="5" href="#g_t_005b5_005d">[5]</a>:          Demoen and Sagonas, <cite>CAT: the copying approach to tabling</cite>. 
</ul>

<div class="node">
<a name="%5b1%5d"></a>
<a name="g_t_005b1_005d"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#g_t_005b2_005d">[2]</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bibliography">Bibliography</a>

</div>

<h3 class="unnumberedsec">[1]</h3>

<p>Chris Speirs, Zoltan Somogyi and Harald Sondergaard, <cite>Termination
Analysis for Mercury</cite>.  In P. Van Hentenryck, editor, <cite>Static
Analysis: Proceedings of the 4th International Symposium</cite>, Lecture
Notes in Computer Science. Springer, 1997.  A longer version is
available for download from
&lt;http://www.cs.mu.oz.au/publications/tr_db/mu_97_09.ps.gz&gt;.

<div class="node">
<a name="%5b2%5d"></a>
<a name="g_t_005b2_005d"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#g_t_005b3_005d">[3]</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_005b1_005d">[1]</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bibliography">Bibliography</a>

</div>

<h3 class="unnumberedsec">[2]</h3>

<p>Gerhard Groger and Lutz Plumer, <cite>Handling of mutual recursion in
automatic termination proofs for logic programs.</cite>  In K. Apt, editor,
<cite>The Proceedings of the Joint International Conference and Symposium on
Logic Programming</cite>, pages 336&ndash;350.  MIT Press, 1992.

<div class="node">
<a name="%5b3%5d"></a>
<a name="g_t_005b3_005d"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#g_t_005b4_005d">[4]</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_005b2_005d">[2]</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bibliography">Bibliography</a>

</div>

<h3 class="unnumberedsec">[3]</h3>

<p>Chris Speirs, <cite>Termination Analysis for Logic Programs</cite>,
Technical Report 97/23, Department of Computer Science, The University
of Melbourne, Melbourne, Australia, 1997.  Available from
&lt;http://www.cs.mu.oz.au/mercury/papers/mu_97_23.ps.gz&gt;.

<div class="node">
<a name="%5b4%5d"></a>
<a name="g_t_005b4_005d"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#g_t_005b5_005d">[5]</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_005b3_005d">[3]</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bibliography">Bibliography</a>

</div>

<h3 class="unnumberedsec">[4]</h3>

<p>K. Sagonas, <cite>The SLG-WAM: A Search-Efficient Engine
for Well-Founded Evaluation of Normal Logic Programs</cite>,
PhD thesis, SUNY at Stony Brook, 1996.  Available from <br>
&lt;http://www.cs.kuleuven.ac.be/~kostis/Thesis/thesis.ps.gz&gt;.

<div class="node">
<a name="%5b5%5d"></a>
<a name="g_t_005b5_005d"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_005b4_005d">[4]</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bibliography">Bibliography</a>

</div>

<h3 class="unnumberedsec">[5]</h3>

<p>B. Demoen and K. Sagonas, <cite>CAT: the copying approach to tabling</cite>,
submitted for publication,
Katholieke Universiteit Leuven, 1998.

   <div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Operator term (see <a href="#Terms">Terms</a>).</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> The type of an explicitly
type qualified term may be an instance of the type specified by the
qualifier. This allows explicit type qualifications to constrain the
types of two data-terms to be identical, without knowing the exact types
of the data-terms. It also allows type qualifications to refer to the
types of the results of existentially typed predicates or functions.</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> If <var>equalitypred</var> is not an equivalence relation,
then the program is inconsistent: its declarative semantics
contains a contradiction, because the additional axioms for the user-defined
equality contradict the standard equality axioms.  That implies that the
implementation may compute any answer at all (see <a href="#Semantics">Semantics</a>),
i.e. the behaviour of the program is undefined.</p>

   <hr></div>

</body></html>

