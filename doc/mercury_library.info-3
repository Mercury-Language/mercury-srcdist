This is mercury_library.info, produced by makeinfo version 4.7 from
library.texi_pp.

INFO-DIR-SECTION The Mercury Programming Language
START-INFO-DIR-ENTRY
* Mercury Library: (mercury_library).  The Mercury Library Reference Manual.
END-INFO-DIR-ENTRY

   This file documents the Mercury standard library, version
rotd-2007-12-21.

   Copyright (C) 1995-1997,1999-2007 The University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: mercury_library.info,  Node: set,  Next: set_ordlist,  Prev: set_ctree234,  Up: Top

61 set
******

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1994-1997, 1999-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: set.m.
     % Main authors: conway, fjh, benyi.
     % Stability: high.
     %
     % This module provides a set ADT.
     % The implementation represents sets using ordered lists.
     % This file just calls the equivalent predicates in set_ordlist.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module set.
     :- interface.

     :- import_module bool.
     :- import_module list.

     %--------------------------------------------------%

     :- type set(T).

         % `set.init(Set)' is true iff `Set' is an empty set.
         %
     :- pred set.init(set(T)::uo) is det.
     :- func set.init = set(T).

         % `set.list_to_set(List, Set)' is true iff `Set' is the set
         % containing only the members of `List'.
         %
     :- pred set.list_to_set(list(T)::in, set(T)::out) is det.
     :- func set.list_to_set(list(T)) = set(T).

         % Synonyms for set.list_to_set/1.
         %
     :- func set.from_list(list(T)) = set(T).
     :- func set.set(list(T)) = set(T).

         % `set.sorted_list_to_set(List, Set)' is true iff `Set' is the set
         % containing only the members of `List'.  `List' must be sorted
         % and must not contain any duplicates.
         %
     :- pred set.sorted_list_to_set(list(T)::in, set(T)::out) is det.
     :- func set.sorted_list_to_set(list(T)) = set(T).

         % A synonym for set.sorted_list_to_set/1.
         %
     :- func set.from_sorted_list(list(T)) = set(T).

         % `set.to_sorted_list(Set, List)' is true iff `List' is the list
         % of all the members of `Set', in sorted order without any
         % duplicates.
         %
     :- pred set.to_sorted_list(set(T)::in, list(T)::out) is det.
     :- func set.to_sorted_list(set(T)) = list(T).

         % `set.singleton_set(Set, Elem)' is true iff `Set' is the set
         % containing just the single element `Elem'.
         %
     :- pred set.singleton_set(set(T), T).
     :- mode set.singleton_set(in, out) is semidet.
     :- mode set.singleton_set(out, in) is det.

     :- func set.make_singleton_set(T) = set(T).

         % `set.equal(SetA, SetB)' is true iff
         % `SetA' and `SetB' contain the same elements.
         %
     :- pred set.equal(set(T)::in, set(T)::in) is semidet.

     :- pred set.empty(set(T)::in) is semidet.

     :- pred set.non_empty(set(T)::in) is semidet.

         % `set.subset(SetA, SetB)' is true iff `SetA' is a subset of `SetB'.
         %
     :- pred set.subset(set(T)::in, set(T)::in) is semidet.

         % `set.superset(SetA, SetB)' is true iff `SetA' is a
         % superset of `SetB'.
         %
     :- pred set.superset(set(T)::in, set(T)::in) is semidet.

         % `set.member(X, Set)' is true iff `X' is a member of `Set'.
         %
     :- pred set.member(T, set(T)).
     :- mode set.member(in, in) is semidet.
     :- mode set.member(out, in) is nondet.

         % `set_is_member(X, Set, Result)' returns
         % `Result = yes' iff `X' is a member of `Set'.
         %
     :- pred set.is_member(T::in, set(T)::in, bool::out) is det.

         % `set.contains(Set, X)' is true iff `X' is a member of `Set'.
         %
     :- pred set.contains(set(T)::in, T::in) is semidet.

         % `set.insert(Set0, X, Set)' is true iff `Set' is the union of
         % `Set0' and the set containing only `X'.
         %
     :- pred set.insert(set(T)::in, T::in, set(T)::out) is det.

         % XXX rwab1: I think we should reverse the args. here for
         % higher order programming.
         %
     :- func set.insert(set(T), T) = set(T).

         % `set.insert_list(Set0, Xs, Set)' is true iff `Set' is the union of
         % `Set0' and the set containing only the members of `Xs'.
         %
     :- pred set.insert_list(set(T)::in, list(T)::in, set(T)::out) is det.

         % XXX rwab1: I think we should reverse the args. here for
         % higher order programming.
         %
     :- func set.insert_list(set(T), list(T)) = set(T).

         % `set.delete(Set0, X, Set)' is true iff `Set' is the relative
         % complement of `Set0' and the set containing only `X', i.e.
         % if `Set' is the set which contains all the elements of `Set0'
         % except `X'.
         %
     :- pred set.delete(set(T)::in, T::in, set(T)::out) is det.

         % XXX rwab1: I think we should reverse the args. here for
         % higher order programming.
         %
     :- func set.delete(set(T), T) = set(T).

         % `set.delete_list(Set0, Xs, Set)' is true iff `Set' is the relative
         % complement of `Set0' and the set containing only the members of
         % `Xs'.
         %
     :- pred set.delete_list(set(T)::in, list(T)::in, set(T)::out) is det.

         % XXX rwab1: I think we should reverse the args. here for
         % higher order programming.
         %
     :- func set.delete_list(set(T), list(T)) = set(T).

         % `set.remove(Set0, X, Set)' is true iff `Set0' contains `X',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only `X', i.e.  if `Set' is the set which contains
         % all the elements of `Set0' except `X'.
         %
     :- pred set.remove(set(T)::in, T::in, set(T)::out) is semidet.

         % `set.remove_list(Set0, Xs, Set)' is true iff `Xs' does not
         % contain any duplicates, `Set0' contains every member of `Xs',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only the members of `Xs'.
         %
     :- pred set.remove_list(set(T)::in, list(T)::in, set(T)::out) is semidet.

         % `set.remove_least(Set0, Elem, Set)' is true iff
         % `Set0' is not empty, `Elem' is the smallest element in `Set0'
         % (with elements ordered using the standard ordering given
         % by compare/3), and `Set' is the set containing all the
         % elements of `Set0' except `Elem'.
         %
     :- pred set.remove_least(set(T)::in, T::out, set(T)::out) is semidet.

         % `set_union(SetA, SetB, Set)' is true iff `Set' is the union of
         % `SetA' and `SetB'.  If the sets are known to be of different
         % sizes, then for efficiency make `SetA' the larger of the two.
         % (The current implementation using sorted lists with duplicates
         % removed is not sensitive to the ordering of the input arguments,
         % but other set implementations may be, so observing this convention
         % will make it less likely that you will encounter problems if
         % the implementation is changed.)
         %
     :- pred set.union(set(T)::in, set(T)::in, set(T)::out) is det.
     :- func set.union(set(T), set(T)) = set(T).

         % `set.union_list(A, B)' is true iff `B' is the union of
         % all the sets in `A'.
         %
     :- func set.union_list(list(set(T))) = set(T).

         % `set.power_union(A, B)' is true iff `B' is the union of
         % all the sets in `A'.
         %
     :- pred set.power_union(set(set(T))::in, set(T)::out) is det.
     :- func set.power_union(set(set(T))) = set(T).

         % `set.intersect(SetA, SetB, Set)' is true iff `Set' is the
         % intersection of `SetA' and `SetB'. If the two sets are
         % known to be unequal in size, then making SetA be the larger
         % set will usually be more efficient.
         % (The current implementation, using sorted lists with duplicates
         % removed is not sensitive to the ordering of the input arguments
         % but other set implementations may be, so observing this convention
         % will make it less likely that you will encounter problems if
         % the implementation is changed.)
         %
     :- pred set.intersect(set(T)::in, set(T)::in, set(T)::out) is det.
     :- func set.intersect(set(T), set(T)) = set(T).

         % `set.power_intersect(A, B)' is true iff `B' is the intersection of
         % all the sets in `A'.
         %
     :- pred set.power_intersect(set(set(T))::in, set(T)::out) is det.
     :- func set.power_intersect(set(set(T))) = set(T).

         % `set.intersect_list(A, B)' is true iff `B' is the intersection of
         % all the sets in `A'.
         %
     :- func set.intersect_list(list(set(T))) = set(T).

         % `set.difference(SetA, SetB, Set)' is true iff `Set' is the
         % set containing all the elements of `SetA' except those that
         % occur in `SetB'.
         %
     :- pred set.difference(set(T)::in, set(T)::in, set(T)::out) is det.
     :- func set.difference(set(T), set(T)) = set(T).

         % `set.count(Set, Count)' is true iff `Set' has `Count' elements.
         % i.e. `Count' is the cardinality (size) of the set.
         %
     :- pred set.count(set(T)::in, int::out) is det.
     :- func set.count(set(T)) = int.

         % Support for higher order set processing.

         % map(F, S) =
         %   list_to_set(list.map(F, to_sorted_list(S))).
         %
     :- func set.map(func(T1) = T2, set(T1)) = set(T2).

         % set.map_fold(P, S0, S, A0, A) :-
         %   L0 = set.to_sorted_list(S0),
         %   list.map_foldl(P, L0, L, A0, A),
         %   S = set.list_to_set(L).
         %
     :- pred set.map_fold(pred(T1, T2, T3, T3), set(T1), set(T2), T3, T3).
     :- mode set.map_fold(pred(in, out, in, out) is det, in, out, in, out) is det.

         % set.filter(P, S) =
         %   sorted_list_to_set(list.filter(P, to_sorted_list(S))).
         %
     :- func set.filter(pred(T1), set(T1)) = set(T1).
     :- mode set.filter(pred(in) is semidet, in) = out is det.

         % set.filter_map(PF, S) =
         %   list_to_set(list.filter_map(PF, to_sorted_list(S))).
         %
     :- func set.filter_map(func(T1) = T2, set(T1)) = set(T2).
     :- mode set.filter_map(func(in) = out is semidet, in) = out is det.

         % set.fold(F, S, A) =
         %   list.foldl(F, to_sorted_list(S), A).
         %
     :- func set.fold(func(T, A) = A, set(T), A) = A.

     :- pred set.fold(pred(T, A, A), set(T), A, A).
     :- mode set.fold(pred(in, di, uo) is det, in, di, uo) is det.
     :- mode set.fold(pred(in, in, out) is det, in, in, out) is det.
     :- mode set.fold(pred(in, in, out) is semidet, in, in, out) is semidet.

     :- pred set.fold2(pred(T, A, A, B, B), set(T), A, A, B, B).
     :- mode set.fold2(pred(in, in, out, di, uo) is det, in,
         in, out, di, uo) is det.
     :- mode set.fold2(pred(in, in, out, in, out) is det, in,
         in, out, in, out) is det.
     :- mode set.fold2(pred(in, in, out, in, out) is semidet,
         in, in, out, in, out) is semidet.

     :- pred set.fold3(pred(T, A, A, B, B, C, C), set(T), A, A, B, B, C, C).
     :- mode set.fold3(pred(in, in, out, in, out, di, uo) is det, in,
         in, out, in, out, di, uo) is det.
     :- mode set.fold3(pred(in, in, out, in, out, in, out) is det, in,
         in, out, in, out, in, out) is det.
     :- mode set.fold3(pred(in, in, out, in, out, in, out) is semidet, in,
         in, out, in, out, in, out) is semidet.

     :- pred set.fold4(pred(T, A, A, B, B, C, C, D, D), set(T), A, A, B, B,
             C, C, D, D).
     :- mode set.fold4(pred(in, in, out, in, out, in, out, in, out) is det, in,
         in, out, in, out, in, out, in, out) is det.
     :- mode set.fold4(pred(in, in, out, in, out, in, out, di, uo) is det, in,
         in, out, in, out, in, out, di, uo) is det.
     :- mode set.fold4(pred(in, in, out, in, out, in, out, in, out) is semidet, in,
         in, out, in, out, in, out, in, out) is semidet.

         % set.divide(Pred, Set, TruePart, FalsePart):
         % TruePart consists of those elements of Set for which Pred succeeds;
         % FalsePart consists of those elements of Set for which Pred fails.
         %
     :- pred set.divide(pred(T)::in(pred(in) is semidet), set(T)::in,
         set(T)::out, set(T)::out) is det.

         % set_divide_by_set(DivideBySet, Set, InPart, OutPart):
         % InPart consists of those elements of Set which are also in
         % DivideBySet; OutPart consists of those elements of which are
         % not in DivideBySet.
         %
     :- pred set.divide_by_set(set(T)::in, set(T)::in, set(T)::out, set(T)::out)
         is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: set_ordlist,  Next: set_tree234,  Prev: set,  Up: Top

62 set_ordlist
**************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1996-1997,1999-2002, 2004-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: set_ordlist.m.
     % Main authors: conway, fjh.
     % Stability: medium.
     %
     % This file contains a `set' ADT.
     % Sets are implemented here as sorted lists without duplicates.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module set_ordlist.
     :- interface.

     :- import_module bool.
     :- import_module list.

     %--------------------------------------------------%

     :- type set_ordlist(_T).

         % `set_ordlist.list_to_set(List, Set)' is true iff `Set' is the set
         % containing only the members of `List'.
         %
     :- pred set_ordlist.list_to_set(list(T)::in, set_ordlist(T)::out) is det.
     :- func set_ordlist.list_to_set(list(T)) = set_ordlist(T).

         % A synonym for set_ordlist.list_to_set/1.
         %
     :- func set_ordlist.from_list(list(T)) = set_ordlist(T).

         % `set_ordlist.sorted_list_to_set(List, Set)' is true iff `Set' is
         % the set containing only the members of `List'.  `List' must be sorted.
         %
     :- pred set_ordlist.sorted_list_to_set(list(T)::in, set_ordlist(T)::out)
         is det.
     :- func set_ordlist.sorted_list_to_set(list(T)) = set_ordlist(T).

         % A synonym for set_ordrlist.sorted_list_to_set/1.
         %
     :- func set_ordlist.from_sorted_list(list(T)) = set_ordlist(T).

         % `set_ordlist.to_sorted_list(Set, List)' is true iff `List' is the
         % list of all the members of `Set', in sorted order.
         %
     :- pred set_ordlist.to_sorted_list(set_ordlist(T)::in, list(T)::out) is det.
     :- func set_ordlist.to_sorted_list(set_ordlist(T)) = list(T).

         % `set_ordlist.init(Set)' is true iff `Set' is an empty set.
         %
     :- pred set_ordlist.init(set_ordlist(_T)::uo) is det.
     :- func set_ordlist.init = set_ordlist(T).

         % `set_ordlist.singleton_set(Set, Elem)' is true iff `Set' is the set
         % containing just the single element `Elem'.
         %
     :- pred set_ordlist.singleton_set(set_ordlist(T), T).
     :- mode set_ordlist.singleton_set(in, out) is semidet.
     :- mode set_ordlist.singleton_set(out, in) is det.

     :- func set_ordlist.make_singleton_set(T) = set_ordlist(T).

         % `set_ordlist.equal(SetA, SetB)' is true iff
         % `SetA' and `SetB' contain the same elements.
         %
     :- pred set_ordlist.equal(set_ordlist(T)::in, set_ordlist(T)::in) is semidet.

         % `set_ordlist.empty(Set)' is true iff `Set' is an empty set.
         %
     :- pred set_ordlist.empty(set_ordlist(_T)::in) is semidet.

         % `set_ordlist.subset(SetA, SetB)' is true iff `SetA' is a subset of
         % `SetB'.
         %
     :- pred set_ordlist.subset(set_ordlist(T)::in, set_ordlist(T)::in) is semidet.

         % `set_ordlist.superset(SetA, SetB)' is true iff `SetA' is a
         % superset of `SetB'.
         %
     :- pred set_ordlist.superset(set_ordlist(T)::in, set_ordlist(T)::in)
         is semidet.

         % `set_ordlist.member(X, Set)' is true iff `X' is a member of `Set'.
         %
     :- pred set_ordlist.member(T, set_ordlist(T)).
     :- mode set_ordlist.member(in, in) is semidet.
     :- mode set_ordlist.member(out, in) is nondet.

         % `set_ordlist.is_member(X, Set, Result)' returns
         % `Result = yes' iff `X' is a member of `Set'.
         %
     :- pred set_ordlist.is_member(T::in, set_ordlist(T)::in, bool::out) is det.

         % `set_ordlist.contains(Set, X)' is true iff `X' is a member of `Set'.
         %
     :- pred set_ordlist.contains(set_ordlist(T)::in, T::in) is semidet.

         % `set_ordlist.insert(Set0, X, Set)' is true iff `Set' is the union
         % of `Set0' and the set containing only `X'.
         %
     :- pred set_ordlist.insert(set_ordlist(T)::in, T::in, set_ordlist(T)::out)
         is det.

     :- func set_ordlist.insert(set_ordlist(T), T) = set_ordlist(T).

         % `set_ordlist.insert_list(Set0, Xs, Set)' is true iff `Set' is the
         % union of `Set0' and the set containing only the members of `Xs'.
         %
     :- pred set_ordlist.insert_list(set_ordlist(T)::in, list(T)::in,
         set_ordlist(T)::out) is det.
     :- func set_ordlist.insert_list(set_ordlist(T), list(T)) = set_ordlist(T).

         % `set_ordlist.delete(Set0, X, Set)' is true iff `Set' is the
         % relative complement of `Set0' and the set containing only `X', i.e.
         % if `Set' is the set which contains all the elements of `Set0'
         % except `X'.
         %
     :- pred set_ordlist.delete(set_ordlist(T)::in, T::in, set_ordlist(T)::out)
         is det.
     :- func set_ordlist.delete(set_ordlist(T), T) = set_ordlist(T).

         % `set_ordlist.delete_list(Set0, Xs, Set)' is true iff `Set' is the
         % relative complement of `Set0' and the set containing only the members
         % of `Xs'.
         %
     :- pred set_ordlist.delete_list(set_ordlist(T)::in, list(T)::in,
         set_ordlist(T)::out) is det.
     :- func set_ordlist.delete_list(set_ordlist(T), list(T)) = set_ordlist(T).

         % `set_ordlist.remove(Set0, X, Set)' is true iff `Set0' contains `X',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only `X', i.e.  if `Set' is the set which contains
         % all the elements of `Set0' except `X'.
         %
     :- pred set_ordlist.remove(set_ordlist(T)::in, T::in, set_ordlist(T)::out)
         is semidet.

         % `set_ordlist.remove_list(Set0, Xs, Set)' is true iff Xs does not
         % contain any duplicates, `Set0' contains every member of `Xs',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only the members of `Xs'.
         %
     :- pred set_ordlist.remove_list(set_ordlist(T)::in, list(T)::in,
         set_ordlist(T)::out) is semidet.

         % `set_ordlist.remove_least(Set0, X, Set)' is true iff `X' is the
         % least element in `Set0', and `Set' is the set which contains all the
         % elements of `Set0' except `X'.

     :- pred set_ordlist.remove_least(set_ordlist(T)::in, T::out,
         set_ordlist(T)::out) is semidet.

         % `set_ordlist_union(SetA, SetB, Set)' is true iff `Set' is the union
         % of `SetA' and `SetB'. The efficiency of the union operation is
         % O(card(SetA)+card(SetB)) and is not sensitive to the argument
         % ordering.
         %
     :- pred set_ordlist.union(set_ordlist(T)::in, set_ordlist(T)::in,
         set_ordlist(T)::out) is det.

     :- func set_ordlist.union(set_ordlist(T), set_ordlist(T)) = set_ordlist(T).

         % `set_ordlist.union_list(A, B)' is true iff `B' is the union of
         % all the sets in `A'
         %
     :- func set_ordlist.union_list(list(set_ordlist(T))) = set_ordlist(T).

         % `set_ordlist.power_union(A, B)' is true iff `B' is the union of
         % all the sets in `A'
         %
     :- pred set_ordlist.power_union(set_ordlist(set_ordlist(T))::in,
         set_ordlist(T)::out) is det.

     :- func set_ordlist.power_union(set_ordlist(set_ordlist(T))) = set_ordlist(T).

         % `set_ordlist.intersect(SetA, SetB, Set)' is true iff `Set' is the
         % intersection of `SetA' and `SetB'. The efficiency of the intersection
         % operation is not influenced by the argument order.
         %
     :- pred set_ordlist.intersect(set_ordlist(T), set_ordlist(T), set_ordlist(T)).
     :- mode set_ordlist.intersect(in, in, out) is det.
     :- mode set_ordlist.intersect(in, in, in) is semidet.

     :- func set_ordlist.intersect(set_ordlist(T), set_ordlist(T))
         = set_ordlist(T).

         % `set_ordlist.power_intersect(A, B)' is true iff `B' is the
         % intersection of all the sets in `A'.
         %
     :- pred set_ordlist.power_intersect(set_ordlist(set_ordlist(T))::in,
         set_ordlist(T)::out) is det.
     :- func set_ordlist.power_intersect(set_ordlist(set_ordlist(T)))
         = set_ordlist(T).

         % `set_ordlist.intersect_list(A, B)' is true iff `B' is the
         % intersection of all the sets in `A'.

     :- func set_ordlist.intersect_list(list(set_ordlist(T))) = set_ordlist(T).

         % `set_ordlist.difference(SetA, SetB, Set)' is true iff `Set' is the
         % set containing all the elements of `SetA' except those that
         % occur in `SetB'.
         %
     :- pred set_ordlist.difference(set_ordlist(T)::in, set_ordlist(T)::in,
         set_ordlist(T)::out) is det.
     :- func set_ordlist.difference(set_ordlist(T), set_ordlist(T))
         = set_ordlist(T).

         % `set_ordlist.count(Set, Count)' is true iff `Set' has
         % `Count' elements.
         %
     :- pred set_ordlist.count(set_ordlist(T)::in, int::out) is det.
     :- func set_ordlist.count(set_ordlist(T)) = int.

     :- func set_ordlist.map(func(T1) = T2, set_ordlist(T1)) = set_ordlist(T2).

     :- func set_ordlist.filter_map(func(T1) = T2, set_ordlist(T1))
         = set_ordlist(T2).
     :- mode set_ordlist.filter_map(func(in) = out is semidet, in) = out is det.

     :- func set_ordlist.fold(func(T1, T2) = T2, set_ordlist(T1), T2) = T2.

         % set_ordlist.divide(Pred, Set, TruePart, FalsePart):
         % TruePart consists of those elements of Set for which Pred succeeds;
         % FalsePart consists of those elements of Set for which Pred fails.
         %
     :- pred set_ordlist.divide(pred(T)::in(pred(in) is semidet),
         set_ordlist(T)::in, set_ordlist(T)::out, set_ordlist(T)::out)
         is det.

         % set_ordlist.divide_by_set(DivideBySet, Set, InPart, OutPart):
         % InPart consists of those elements of Set which are also in
         % DivideBySet; OutPart consists of those elements of which are
         % not in DivideBySet.
         %
     :- pred set_ordlist.divide_by_set(set_ordlist(T)::in, set_ordlist(T)::in,
         set_ordlist(T)::out, set_ordlist(T)::out) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: set_tree234,  Next: set_unordlist,  Prev: set_ordlist,  Up: Top

63 set_tree234
**************

     %--------------------------------------------------%
     % vim:ts=4 sw=4 expandtab
     %--------------------------------------------------%
     % Copyright (C) 2005-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: set_tree234.m.
     % Author: zs.
     % Stability: high.
     %
     % This modules implements sets using 2-3-4 trees.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module set_tree234.
     :- interface.

     :- import_module bool.
     :- import_module list.

     %--------------------------------------------------%

     :- type set_tree234(_T).

         % `set_tree234.init = Set' is true iff `Set' is an empty set.
         %
     :- func set_tree234.init = set_tree234(T).

         % `set_tree234.singleton_set(Elem, Set)' is true iff `Set' is the set
         % containing just the single element `Elem'.
         %
     :- pred set_tree234.singleton_set(T, set_tree234(T)).
     :- mode set_tree234.singleton_set(in, out) is det.
     :- mode set_tree234.singleton_set(out, in) is semidet.

     :- func set_tree234.make_singleton_set(T) = set_tree234(T).

         % `set_tree234.empty(Set)' is true iff `Set' is an empty set.
         %
     :- pred set_tree234.empty(set_tree234(_T)::in) is semidet.

         % `set_tree234.member(X, Set)' is true iff `X' is a member of `Set'.
         %
     :- pred set_tree234.member(set_tree234(T), T).
     :- mode set_tree234.member(in, in) is semidet.
     :- mode set_tree234.member(in, out) is nondet.

         % `set_tree234.is_member(Set, X, Result)' returns
         % `Result = yes' iff `X' is a member of `Set'.
         %
     :- pred set_tree234.is_member(set_tree234(T)::in, T::in, bool::out) is det.
     :- func set_tree234.is_member(set_tree234(T), T) = bool.

         % `set_tree234.contains(Set, X)' is true iff `X' is a member of `Set'.
         %
     :- pred set_tree234.contains(set_tree234(T)::in, T::in) is semidet.

         % `set_tree234.list_to_set(List) = Set' is true iff `Set' is the set
         % containing only the members of `List'.
         %
     :- func set_tree234.list_to_set(list(T)) = set_tree234(T).

         % `set_tree234.sorted_list_to_set(List) = Set' is true iff `Set' is
         % the set containing only the members of `List'. `List' must be sorted.
         %
     :- func set_tree234.sorted_list_to_set(list(T)) = set_tree234(T).

         % `set_tree234.to_sorted_list(Set) = List' is true iff `List' is the
         % list of all the members of `Set', in sorted order.
         %
     :- func set_tree234.to_sorted_list(set_tree234(T)) = list(T).

         % `set_tree234.equal(SetA, SetB)' is true iff
         % `SetA' and `SetB' contain the same elements.
         %
     :- pred set_tree234.equal(set_tree234(T)::in, set_tree234(T)::in) is semidet.

         % `set_tree234.subset(SetA, SetB)' is true iff `SetA' is a subset of
         % `SetB'.
         %
     :- pred set_tree234.subset(set_tree234(T)::in, set_tree234(T)::in) is semidet.

         % `set_tree234.superset(SetA, SetB)' is true iff `SetA' is a
         % superset of `SetB'.
         %
     :- pred set_tree234.superset(set_tree234(T)::in, set_tree234(T)::in)
         is semidet.

         % `set_tree234.insert(X, Set0, Set)' is true iff `Set' is the union
         % of `Set0' and the set containing only `X'.
         %
     :- pred set_tree234.insert(T::in, set_tree234(T)::in, set_tree234(T)::out)
         is det.
     :- func set_tree234.insert(T, set_tree234(T)) = set_tree234(T).

         % `set_tree234.insert_list(Xs, Set0, Set)' is true iff `Set' is the
         % union of `Set0' and the set containing only the members of `Xs'.
         %
     :- pred set_tree234.insert_list(list(T)::in,
         set_tree234(T)::in, set_tree234(T)::out) is det.
     :- func set_tree234.insert_list(list(T), set_tree234(T)) = set_tree234(T).

         % `set_tree234.delete(X, Set0, Set)' is true iff `Set' is the
         % relative complement of `Set0' and the set containing only `X', i.e.
         % if `Set' is the set which contains all the elements of `Set0'
         % except `X'.
         %
     :- pred set_tree234.delete(T::in, set_tree234(T)::in, set_tree234(T)::out)
         is det.
     :- func set_tree234.delete(T, set_tree234(T)) = set_tree234(T).

         % `set_tree234.delete_list(Xs, Set0, Set)' is true iff `Set' is the
         % relative complement of `Set0' and the set containing only the members
         % of `Xs'.
         %
     :- pred set_tree234.delete_list(list(T)::in,
         set_tree234(T)::in, set_tree234(T)::out) is det.
     :- func set_tree234.delete_list(list(T), set_tree234(T)) = set_tree234(T).

         % `set_tree234.remove(X, Set0, Set)' is true iff `Set0' contains `X',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only `X', i.e.  if `Set' is the set which contains
         % all the elements of `Set0' except `X'.
         %
     :- pred set_tree234.remove(T::in, set_tree234(T)::in, set_tree234(T)::out)
         is semidet.

         % `set_tree234.remove_list(Xs, Set0, Set)' is true iff Xs does not
         % contain any duplicates, `Set0' contains every member of `Xs',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only the members of `Xs'.
         %
     :- pred set_tree234.remove_list(list(T)::in,
         set_tree234(T)::in, set_tree234(T)::out) is semidet.

         % `set_tree234.remove_least(X, Set0, Set)' is true iff `X' is the
         % least element in `Set0', and `Set' is the set which contains all the
         % elements of `Set0' except `X'.
         %
     :- pred set_tree234.remove_least(T::out,
         set_tree234(T)::in, set_tree234(T)::out) is semidet.

         % `set_tree234_union(SetA, SetB) = Set' is true iff `Set' is the union
         % of `SetA' and `SetB'.
         %
     :- pred set_tree234.union(set_tree234(T)::in, set_tree234(T)::in,
         set_tree234(T)::out) is det.
     :- func set_tree234.union(set_tree234(T), set_tree234(T)) = set_tree234(T).

         % `set_tree234.union_list(A, B)' is true iff `B' is the union of
         % all the sets in `A'
         %
     :- pred set_tree234.union_list(list(set_tree234(T))::in, set_tree234(T)::out)
         is det.
     :- func set_tree234.union_list(list(set_tree234(T))) = set_tree234(T).

         % `set_tree234.power_union(A) = B' is true iff `B' is the union of
         % all the sets in `A'
         %
     :- pred set_tree234.power_union(set_tree234(set_tree234(T))::in,
         set_tree234(T)::out) is det.
     :- func set_tree234.power_union(set_tree234(set_tree234(T))) = set_tree234(T).

         % `set_tree234.intersect(SetA, SetB) = Set' is true iff `Set' is the
         % intersection of `SetA' and `SetB'.
         %
     :- pred set_tree234.intersect(set_tree234(T)::in, set_tree234(T)::in,
         set_tree234(T)::out) is det.
     :- func set_tree234.intersect(set_tree234(T), set_tree234(T))
         = set_tree234(T).

         % `set_tree234.power_intersect(A, B)' is true iff `B' is the
         % intersection of all the sets in `A'.
         %
     :- func set_tree234.power_intersect(set_tree234(set_tree234(T)))
         = set_tree234(T).

         % `set_tree234.intersect_list(A, B)' is true iff `B' is the
         % intersection of all the sets in `A'.
         %
     :- func set_tree234.intersect_list(list(set_tree234(T))) = set_tree234(T).

         % `set_tree234.difference(SetA, SetB, Set)' is true iff `Set' is the
         % set containing all the elements of `SetA' except those that
         % occur in `SetB'.
         %
     :- pred set_tree234.difference(set_tree234(T)::in, set_tree234(T)::in,
         set_tree234(T)::out) is det.
     :- func set_tree234.difference(set_tree234(T), set_tree234(T))
         = set_tree234(T).

         % `set_tree234.count(Set, Count)' is true iff `Set' has
         % `Count' elements.
         %
     :- func set_tree234.count(set_tree234(T)) = int.

     :- pred set_tree234.map(pred(T1, T2)::in(pred(in, out) is det),
         set_tree234(T1)::in, set_tree234(T2)::out) is det.
     :- func set_tree234.map(func(T1) = T2, set_tree234(T1)) = set_tree234(T2).

     :- pred set_tree234.filter_map(pred(T1, T2)::in(pred(in, out) is semidet),
         set_tree234(T1)::in, set_tree234(T2)::out) is det.

     :- func set_tree234.filter_map(func(T1) = T2, set_tree234(T1))
         = set_tree234(T2).
     :- mode set_tree234.filter_map(func(in) = out is semidet, in) = out is det.

     :- pred set_tree234.fold(pred(T1, T2, T2)::in(pred(in, in, out) is det),
         set_tree234(T1)::in, T2::in, T2::out) is det.
     :- func set_tree234.fold(func(T1, T2) = T2, set_tree234(T1), T2) = T2.

     :- pred set_tree234.fold2(
         pred(T1, T2, T2, T3, T3)::in(pred(in, in, out, in, out) is det),
         set_tree234(T1)::in, T2::in, T2::out, T3::in, T3::out) is det.

         % set_tree234.divide(Pred, Set, TruePart, FalsePart):
         % TruePart consists of those elements of Set for which Pred succeeds;
         % FalsePart consists of those elements of Set for which Pred fails.
         %
     :- pred set_tree234.divide(pred(T)::in(pred(in) is semidet),
         set_tree234(T)::in, set_tree234(T)::out, set_tree234(T)::out) is det.

         % set_tree234.divide_by_set(DivideBySet, Set, InPart, OutPart):
         % InPart consists of those elements of Set which are also in
         % DivideBySet; OutPart consists of those elements of which are
         % not in DivideBySet.
         %
     :- pred set_tree234.divide_by_set(set_tree234(T)::in, set_tree234(T)::in,
         set_tree234(T)::out, set_tree234(T)::out) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: set_unordlist,  Next: solutions,  Prev: set_tree234,  Up: Top

64 set_unordlist
****************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1995-1997,1999-2002, 2004-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: set_unordlist.m.
     % Main authors: conway, fjh.
     % Stability: medium.
     %
     % This file contains a `set' ADT.
     % Sets are implemented here as unsorted lists, which may contain duplicates.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module set_unordlist.
     :- interface.

     :- import_module bool.
     :- import_module list.

     %--------------------------------------------------%

     :- type set_unordlist(_T).

         % `set_unordlist.list_to_set(List, Set)' is true iff `Set' is the set
         % containing only the members of `List'.
         %
     :- pred set_unordlist.list_to_set(list(T)::in, set_unordlist(T)::out) is det.
     :- func set_unordlist.list_to_set(list(T)) = set_unordlist(T).

         % A synonym for set_unordlist.list_to_set/1.
         %
     :- func set_unordlist.from_list(list(T)) = set_unordlist(T).

         % `set_unordlist.sorted_list_to_set(List, Set)' is true iff `Set' is
         % the set containing only the members of `List'.  `List' must be sorted.
         %
     :- pred set_unordlist.sorted_list_to_set(list(T)::in, set_unordlist(T)::out)
         is det.
     :- func set_unordlist.sorted_list_to_set(list(T)) = set_unordlist(T).

         % A synonym for set_unordlist.sorted_list_to_set/1.
         %
     :- func set_unordlist.from_sorted_list(list(T)) = set_unordlist(T).

         % `set_unordlist.to_sorted_list(Set, List)' is true iff `List' is the
         % list of all the members of `Set', in sorted order.
         %
     :- pred set_unordlist.to_sorted_list(set_unordlist(T)::in, list(T)::out)
         is det.
     :- func set_unordlist.to_sorted_list(set_unordlist(T)) = list(T).

         % `set_unordlist.init(Set)' is true iff `Set' is an empty set.
         %
     :- pred set_unordlist.init(set_unordlist(_T)::uo) is det.
     :- func set_unordlist.init = set_unordlist(T).

         % `set_unordlist.singleton_set(Set, Elem)' is true iff `Set' is the set
         % containing just the single element `Elem'.
         %
     :- pred set_unordlist.singleton_set(set_unordlist(T), T).
     :- mode set_unordlist.singleton_set(in, out) is semidet.
     :- mode set_unordlist.singleton_set(out, in) is det.

     :- func set_unordlist.make_singleton_set(T) = set_unordlist(T).

         % `set_unordlist.equal(SetA, SetB)' is true iff
         % `SetA' and `SetB' contain the same elements.
         %
     :- pred set_unordlist.equal(set_unordlist(T)::in, set_unordlist(T)::in)
         is semidet.

         % `set_unordlist.empty(Set)' is true iff `Set' is an empty set.
         %
     :- pred set_unordlist.empty(set_unordlist(_T)::in) is semidet.

         % `set_unordlist.subset(SetA, SetB)' is true iff `SetA' is a subset of
         % `SetB'.
         %
     :- pred set_unordlist.subset(set_unordlist(T)::in, set_unordlist(T)::in)
         is semidet.

         % `set_unordlist.superset(SetA, SetB)' is true iff `SetA' is a
         % superset of `SetB'.
         %
     :- pred set_unordlist.superset(set_unordlist(T)::in, set_unordlist(T)::in)
         is semidet.

         % `set_unordlist.member(X, Set)' is true iff `X' is a member of `Set'.
         %
     :- pred set_unordlist.member(T, set_unordlist(T)).
     :- mode set_unordlist.member(in, in) is semidet.
     :- mode set_unordlist.member(out, in) is nondet.

         % `set_unordlist.is_member(X, Set, Result)' returns
         % `Result = yes' iff `X' is a member of `Set'.
         %
     :- pred set_unordlist.is_member(T::in, set_unordlist(T)::in, bool::out)
         is det.

         % `set_unordlist.contains(Set, X)' is true iff
         % `X' is a member of `Set'.
         %
     :- pred set_unordlist.contains(set_unordlist(T)::in, T::in) is semidet.

         % `set_unordlist.insert(Set0, X, Set)' is true iff `Set' is the union
         % of `Set0' and the set containing only `X'.
         %
     :- pred set_unordlist.insert(set_unordlist(T), T, set_unordlist(T)).
     :- mode set_unordlist.insert(di, di, uo) is det.
     :- mode set_unordlist.insert(in, in, out) is det.

     :- func set_unordlist.insert(set_unordlist(T), T) = set_unordlist(T).

         % `set_unordlist.insert_list(Set0, Xs, Set)' is true iff `Set' is the
         % union of `Set0' and the set containing only the members of `Xs'.
         %
     :- pred set_unordlist.insert_list(set_unordlist(T)::in, list(T)::in,
         set_unordlist(T)::out) is det.

     :- func set_unordlist.insert_list(set_unordlist(T), list(T))
         = set_unordlist(T).

         % `set_unordlist.delete(Set0, X, Set)' is true iff `Set' is the
         % relative complement of `Set0' and the set containing only `X', i.e.
         % if `Set' is the set which contains all the elements of `Set0'
         % except `X'.
         %
     :- pred set_unordlist.delete(set_unordlist(T), T, set_unordlist(T)).
     :- mode set_unordlist.delete(di, in, uo) is det.
     :- mode set_unordlist.delete(in, in, out) is det.

     :- func set_unordlist.delete(set_unordlist(T), T) = set_unordlist(T).

         % `set_unordlist.delete_list(Set0, Xs, Set)' is true iff `Set' is the
         % relative complement of `Set0' and the set containing only the members
         % of `Xs'.
         %
     :- pred set_unordlist.delete_list(set_unordlist(T)::in, list(T)::in,
         set_unordlist(T)::out) is det.

     :- func set_unordlist.delete_list(set_unordlist(T), list(T))
         = set_unordlist(T).

         % `set_unordlist.remove(Set0, X, Set)' is true iff `Set0' contains `X',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only `X', i.e.  if `Set' is the set which contains
         % all the elements of `Set0' except `X'.
         %
     :- pred set_unordlist.remove(set_unordlist(T)::in, T::in,
         set_unordlist(T)::out) is semidet.

         % `set_unordlist.remove_list(Set0, Xs, Set)' is true iff Xs does not
         % contain any duplicates, `Set0' contains every member of `Xs',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only the members of `Xs'.
         %
     :- pred set_unordlist.remove_list(set_unordlist(T)::in, list(T)::in,
         set_unordlist(T)::out) is semidet.

         % `set_unordlist.remove_least(Set0, X, Set)' is true iff `X' is the
         % least element in `Set0', and `Set' is the set which contains all the
         % elements of `Set0' except `X'.
         %
     :- pred set_unordlist.remove_least(set_unordlist(T)::in, T::out,
         set_unordlist(T)::out) is semidet.

         % `set_unordlist_union(SetA, SetB, Set)' is true iff `Set' is the union
         % of `SetA' and `SetB'.  If the sets are known to be of different
         % sizes, then for efficiency make `SetA' the larger of the two.
         %
     :- pred set_unordlist.union(set_unordlist(T)::in, set_unordlist(T)::in,
         set_unordlist(T)::out) is det.

     :- func set_unordlist.union(set_unordlist(T), set_unordlist(T))
         = set_unordlist(T).

         % `set_unordlist.union_list(A) = B' is true iff `B' is the union of
         % all the sets in `A'
         %
     :- func set_unordlist.union_list(list(set_unordlist(T))) = set_unordlist(T).

         % `set_unordlist.power_union(A, B)' is true iff `B' is the union of
         % all the sets in `A'
         %
     :- pred set_unordlist.power_union(set_unordlist(set_unordlist(T))::in,
         set_unordlist(T)::out) is det.

     :- func set_unordlist.power_union(set_unordlist(set_unordlist(T)))
         = set_unordlist(T).

         % `set_unordlist.intersect(SetA, SetB, Set)' is true iff `Set' is the
         % intersection of `SetA' and `SetB'.
         %
     :- pred set_unordlist.intersect(set_unordlist(T)::in, set_unordlist(T)::in,
         set_unordlist(T)::out) is det.

     :- func set_unordlist.intersect(set_unordlist(T), set_unordlist(T))
         = set_unordlist(T).

         % `set_unordlist.power_intersect(A, B)' is true iff `B' is the
         % intersection of all the sets in `A'
         %
     :- pred set_unordlist.power_intersect(set_unordlist(set_unordlist(T))::in,
         set_unordlist(T)::out) is det.

     :- func set_unordlist.power_intersect(set_unordlist(set_unordlist(T)))
         = set_unordlist(T).

         % `set_unordlist.intersect_list(A, B)' is true iff `B' is the
         % intersection of all the sets in `A'
         %
     :- func set_unordlist.intersect_list(list(set_unordlist(T)))
         = set_unordlist(T).

         % `set_unordlist.difference(SetA, SetB, Set)' is true iff `Set' is the
         % set containing all the elements of `SetA' except those that
         % occur in `SetB'
         %
     :- pred set_unordlist.difference(set_unordlist(T)::in, set_unordlist(T)::in,
         set_unordlist(T)::out) is det.

     :- func set_unordlist.difference(set_unordlist(T), set_unordlist(T))
         = set_unordlist(T).

     :- func set_unordlist.map(func(T1) = T2, set_unordlist(T1))
         = set_unordlist(T2).

     :- func set_unordlist.filter_map(func(T1) = T2, set_unordlist(T1))
         = set_unordlist(T2).
     :- mode set_unordlist.filter_map(func(in) = out is semidet, in) = out is det.

     :- func set_unordlist.fold(func(T1, T2) = T2, set_unordlist(T1), T2) = T2.

         % set_unordlist.divide(Pred, Set, TruePart, FalsePart):
         % TruePart consists of those elements of Set for which Pred succeeds;
         % FalsePart consists of those elements of Set for which Pred fails.
         %
     :- pred set_unordlist.divide(pred(T1), set_unordlist(T1), set_unordlist(T1),
         set_unordlist(T1)).
     :- mode set_unordlist.divide(pred(in) is semidet, in, out, out) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: solutions,  Next: sparse_bitset,  Prev: set_unordlist,  Up: Top

65 solutions
************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1994-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: solutions.m.
     % Main author: fjh.
     % Stability: medium.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module solutions.
     :- interface.

     :- import_module bool.
     :- import_module list.
     :- import_module set.

     %--------------------------------------------------%

         % solutions/2 collects all the solutions to a predicate and returns
         % them as a list in sorted order, with duplicates removed.
         % solutions_set/2 returns them as a set.  unsorted_solutions/2 returns
         % them as an unsorted list with possible duplicates; since there are
         % an infinite number of such lists, this must be called from a context
         % in which only a single solution is required.
         %
     :- pred solutions(pred(T), list(T)).
     :- mode solutions(pred(out) is multi, out(non_empty_list)) is det.
     :- mode solutions(pred(out) is nondet, out) is det.

     :- func solutions(pred(T)) = list(T).
     :- mode solutions(pred(out) is multi) = out(non_empty_list) is det.
     :- mode solutions(pred(out) is nondet) = out is det.

     :- func solutions_set(pred(T)) = set(T).
     :- mode solutions_set(pred(out) is multi) = out is det.
     :- mode solutions_set(pred(out) is nondet) = out is det.

     :- pred solutions_set(pred(T), set(T)).
     :- mode solutions_set(pred(out) is multi, out) is det.
     :- mode solutions_set(pred(out) is nondet, out) is det.

     :- pred unsorted_solutions(pred(T), list(T)).
     :- mode unsorted_solutions(pred(out) is multi, out(non_empty_list))
         is cc_multi.
     :- mode unsorted_solutions(pred(out) is nondet, out) is cc_multi.

     :- func aggregate(pred(T), func(T, U) = U, U) = U.
     :- mode aggregate(pred(out) is multi, func(in, in) = out is det, in)
         = out is det.
     :- mode aggregate(pred(out) is nondet, func(in, in) = out is det, in)
         = out is det.

         % aggregate/4 generates all the solutions to a predicate,
         % sorts them and removes duplicates, then applies an accumulator
         % predicate to each solution in turn:
         %
         % aggregate(Generator, Accumulator, Acc0, Acc) <=>
         %   solutions(Generator, Solutions),
         %   list.foldl(Accumulator, Solutions, Acc0, Acc).
         %
     :- pred aggregate(pred(T), pred(T, U, U), U, U).
     :- mode aggregate(pred(out) is multi, pred(in, in, out) is det,
         in, out) is det.
     :- mode aggregate(pred(out) is multi, pred(in, di, uo) is det,
         di, uo) is det.
     :- mode aggregate(pred(out) is nondet, pred(in, di, uo) is det,
         di, uo) is det.
     :- mode aggregate(pred(out) is nondet, pred(in, in, out) is det,
         in, out) is det.

         % aggregate2/6 generates all the solutions to a predicate,
         % sorts them and removes duplicates, then applies an accumulator
         % predicate to each solution in turn:
         %
         % aggregate2(Generator, Accumulator, AccA0, AccA, AccB0, AccB) <=>
         %   solutions(Generator, Solutions),
         %   list.foldl2(Accumulator, Solutions, AccA0, AccA, AccB0, AccB).
         %
     :- pred aggregate2(pred(T), pred(T, U, U, V, V), U, U, V, V).
     :- mode aggregate2(pred(out) is multi, pred(in, in, out, in, out) is det,
         in, out, in, out) is det.
     :- mode aggregate2(pred(out) is multi, pred(in, in, out, di, uo) is det,
         in, out, di, uo) is det.
     :- mode aggregate2(pred(out) is nondet, pred(in, in, out, di, uo) is det,
         in, out, di, uo) is det.
     :- mode aggregate2(pred(out) is nondet, pred(in, in, out, in, out) is det,
         in, out, in, out) is det.

         % unsorted_aggregate/4 generates all the solutions to a predicate
         % and applies an accumulator predicate to each solution in turn.
         % Declaratively, the specification is as follows:
         %
         % unsorted_aggregate(Generator, Accumulator, Acc0, Acc) <=>
         %   unsorted_solutions(Generator, Solutions),
         %   list.foldl(Accumulator, Solutions, Acc0, Acc).
         %
         % Operationally, however, unsorted_aggregate/4 will call the
         % Accumulator for each solution as it is obtained, rather than
         % first building a list of all the solutions.
         %
     :- pred unsorted_aggregate(pred(T), pred(T, U, U), U, U).
     :- mode unsorted_aggregate(pred(out) is multi, pred(in, in, out) is det,
         in, out) is cc_multi.
     :- mode unsorted_aggregate(pred(out) is multi, pred(in, in, out) is cc_multi,
         in, out) is cc_multi.
     :- mode unsorted_aggregate(pred(out) is multi, pred(in, di, uo) is det,
         di, uo) is cc_multi.
     :- mode unsorted_aggregate(pred(out) is multi, pred(in, di, uo) is cc_multi,
         di, uo) is cc_multi.
     :- mode unsorted_aggregate(pred(muo) is multi, pred(mdi, di, uo) is det,
         di, uo) is cc_multi.
     :- mode unsorted_aggregate(pred(out) is nondet, pred(in, di, uo) is det,
         di, uo) is cc_multi.
     :- mode unsorted_aggregate(pred(out) is nondet, pred(in, di, uo) is cc_multi,
         di, uo) is cc_multi.
     :- mode unsorted_aggregate(pred(out) is nondet, pred(in, in, out) is det,
         in, out) is cc_multi.
     :- mode unsorted_aggregate(pred(out) is nondet, pred(in, in, out) is cc_multi,
         in, out) is cc_multi.
     :- mode unsorted_aggregate(pred(muo) is nondet, pred(mdi, di, uo) is det,
         di, uo) is cc_multi.

         % This is a generalization of unsorted_aggregate which allows the
         % iteration to stop before all solutions have been found.
         % Declaratively, the specification is as follows:
         %
         %   do_while(Generator, Filter, !Acc) :-
         %       unsorted_solutions(Generator, Solutions),
         %       do_while_2(Solutions, Filter, !Acc).
         %
         %   do_while_2([], _, !Acc).
         %   do_while_2([X | Xs], Filter, !Acc) :-
         %       Filter(X, More, !Acc),
         %       ( More = yes ->
         %           do_while_2(Xs, Filter, !Acc)
         %       ;
         %           true
         %       ).
         %
         % Operationally, however, do_while/4 will call the Filter
         % predicate for each solution as it is obtained, rather than
         % first building a list of all the solutions.
         %
     :- pred do_while(pred(T), pred(T, bool, T2, T2), T2, T2).
     :- mode do_while(pred(out) is multi, pred(in, out, in, out) is det, in, out)
         is cc_multi.
     :- mode do_while(pred(out) is multi, pred(in, out, di, uo) is det, di, uo)
         is cc_multi.
     :- mode do_while(pred(out) is multi, pred(in, out, di, uo) is cc_multi, di, uo)
         is cc_multi.
     :- mode do_while(pred(out) is nondet, pred(in, out, in, out) is det, in, out)
         is cc_multi.
     :- mode do_while(pred(out) is nondet, pred(in, out, di, uo) is det, di, uo)
         is cc_multi.
     :- mode do_while(pred(out) is nondet, pred(in, out, di, uo) is cc_multi, di, uo)
         is cc_multi.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: sparse_bitset,  Next: stack,  Prev: solutions,  Up: Top

66 sparse_bitset
****************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2000-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: sparse_bitset.m.
     % Author: stayl.
     % Stability: medium.
     %
     % This module provides an ADT for storing sets of integers.
     % If the integers stored are closely grouped, a sparse_bitset
     % is much more compact than the representation provided by set.m,
     % and the operations will be much faster.
     %
     % Efficiency notes:
     %
     % A sparse bitset is represented as a sorted list of pairs of integers.
     % For a pair `Offset - Bits', `Offset' is a multiple of `int.bits_per_int'.
     % The bits of `Bits' describe which of the elements of the range
     % `Offset' .. `Offset + bits_per_int - 1' are in the set.
     % Pairs with the same value of `Offset' are merged.
     % Pairs for which `Bits' is zero are removed.
     %
     % The values of `Offset' in the list need not be contiguous multiples
     % of `bits_per_int', hence the name _sparse_ bitset.
     %
     % A sparse_bitset is suitable for storing sets of integers which
     % can be represented using only a few `Offset - Bits' pairs.
     % In the worst case, where the integers stored are not closely
     % grouped, a sparse_bitset will take more memory than an
     % ordinary set, but the operations should not be too much slower.
     %
     % In the asymptotic complexities of the operations below,
     % `rep_size(Set)' is the number of pairs needed to represent `Set',
     % and `card(Set)' is the number of elements in `Set'.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module sparse_bitset.
     :- interface.

     :- import_module enum.
     :- import_module list.
     :- import_module term.

     :- use_module set.

     %--------------------------------------------------%

     :- type sparse_bitset(T). % <= enum(T).

         % Return an empty set.
         %
     :- func init = sparse_bitset(T).
     :- pred init(sparse_bitset(T)::out) is det.

     :- pred empty(sparse_bitset(T)).
     :- mode empty(in) is semidet.
     :- mode empty(out) is det.

         % `equal(SetA, SetB' is true iff `SetA' and `SetB' contain the same
         % elements. Takes O(min(rep_size(SetA), rep_size(SetB))) time.
         %
     :- pred equal(sparse_bitset(T)::in, sparse_bitset(T)::in) is semidet.

         % `list_to_set(List)' returns a set containing only the members of `List'.
         % In the worst case this will take O(length(List)^2) time and space.
         % If the elements of the list are closely grouped, it will be closer
         % to O(length(List)).
         %
     :- func list_to_set(list(T)) = sparse_bitset(T) <= enum(T).
     :- pred list_to_set(list(T)::in, sparse_bitset(T)::out) is det <= enum(T).

         % `sorted_list_to_set(List)' returns a set containing only the members
         % of `List'. `List' must be sorted. Takes O(length(List)) time and space.
         %
     :- func sorted_list_to_set(list(T)) = sparse_bitset(T) <= enum(T).
     :- pred sorted_list_to_set(list(T)::in, sparse_bitset(T)::out)
         is det <= enum(T).

         % `from_set(Set)' returns a bitset containing only the members of `Set'.
         % Takes O(card(Set)) time and space.
         %
     :- func from_set(set.set(T)) = sparse_bitset(T) <= enum(T).

         % `to_sorted_list(Set)' returns a list containing all the members of `Set',
         % in sorted order. Takes O(card(Set)) time and space.
         %
     :- func to_sorted_list(sparse_bitset(T)) = list(T) <= enum(T).
     :- pred to_sorted_list(sparse_bitset(T)::in, list(T)::out) is det <= enum(T).

         % `to_sorted_list(Set)' returns a set.set containing all the members
         % of `Set', in sorted order. Takes O(card(Set)) time and space.
         %
     :- func to_set(sparse_bitset(T)) = set.set(T) <= enum(T).

         % `make_singleton_set(Elem)' returns a set containing just the single
         % element `Elem'.
         %
     :- func make_singleton_set(T) = sparse_bitset(T) <= enum(T).

         % Note: set.m contains the reverse mode of this predicate, but it is
         % difficult to implement both modes using the representation in this
         % module.
         %
     :- pred singleton_set(sparse_bitset(T)::out, T::in) is det <= enum(T).

         % `subset(Subset, Set)' is true iff `Subset' is a subset of `Set'.
         % Same as `intersect(Set, Subset, Subset)', but may be more efficient.
         %
     :- pred subset(sparse_bitset(T)::in, sparse_bitset(T)::in) is semidet.

         % `superset(Superset, Set)' is true iff `Superset' is a superset of `Set'.
         % Same as `intersect(Superset, Set, Set)', but may be more efficient.
         %
     :- pred superset(sparse_bitset(T)::in, sparse_bitset(T)::in) is semidet.

         % `contains(Set, X)' is true iff `X' is a member of `Set'.
         % Takes O(rep_size(Set)) time.
         %
     :- pred contains(sparse_bitset(T)::in, T::in) is semidet <= enum(T).

         % `member(Set, X)' is true iff `X' is a member of `Set'.
         % Takes O(rep_size(Set)) time.
         %
     :- pred member(T, sparse_bitset(T)) <= enum(T).
     :- mode member(in, in) is semidet.
     :- mode member(out, in) is nondet.

         % `insert(Set, X)' returns the union of `Set' and the set containing
         % only `X'. Takes O(rep_size(Set)) time and space.
         %
     :- func insert(sparse_bitset(T), T) = sparse_bitset(T) <= enum(T).
     :- pred insert(sparse_bitset(T)::in, T::in, sparse_bitset(T)::out)
         is det <= enum(T).

         % `insert_list(Set, X)' returns the union of `Set' and the set containing
         % only the members of `X'. Same as `union(Set, list_to_set(X))', but may be
         % more efficient.
         %
     :- func insert_list(sparse_bitset(T), list(T)) = sparse_bitset(T) <= enum(T).
     :- pred insert_list(sparse_bitset(T)::in, list(T)::in, sparse_bitset(T)::out)
         is det <= enum(T).

         % `delete(Set, X)' returns the difference of `Set' and the set containing
         % only `X'. Takes O(rep_size(Set)) time and space.
         %
     :- func delete(sparse_bitset(T), T) = sparse_bitset(T) <= enum(T).
     :- pred delete(sparse_bitset(T)::in, T::in, sparse_bitset(T)::out)
         is det <= enum(T).

         % `delete_list(Set, X)' returns the difference of `Set' and the set
         % containing only the members of `X'. Same as
         % `difference(Set, list_to_set(X))', but may be more efficient.
         %
     :- func delete_list(sparse_bitset(T), list(T)) = sparse_bitset(T) <= enum(T).
     :- pred delete_list(sparse_bitset(T)::in, list(T)::in, sparse_bitset(T)::out)
         is det <= enum(T).

         % `remove(Set0, X, Set)' returns in `Set' the difference of `Set0'
         % and the set containing only `X', failing if `Set0' does not contain `X'.
         % Takes O(rep_size(Set)) time and space.
         %
     :- pred remove(sparse_bitset(T)::in, T::in, sparse_bitset(T)::out)
         is semidet <= enum(T).

         % `remove_list(Set0, X, Set)' returns in `Set' the difference of `Set0'
         % and the set containing all the elements of `X', failing if any element
         % of `X' is not in `Set0'. Same as `subset(list_to_set(X), Set0),
         % difference(Set0, list_to_set(X), Set)', but may be more efficient.
         %
     :- pred remove_list(sparse_bitset(T)::in, list(T)::in, sparse_bitset(T)::out)
         is semidet <= enum(T).

         % `remove_leq(Set, X)' returns `Set' with all elements less than or equal
         % to `X' removed. In other words, it returns the set containing all the
         % elements of `Set' which are greater than `X'.
         %
     :- func remove_leq(sparse_bitset(T), T) = sparse_bitset(T) <= enum(T).
     :- pred remove_leq(sparse_bitset(T)::in, T::in, sparse_bitset(T)::out)
         is det <= enum(T).

         % `remove_gt(Set, X)' returns `Set' with all elements greater than `X'
         % removed. In other words, it returns the set containing all the elements
         % of `Set' which are less than or equal to `X'.
         %
     :- func remove_gt(sparse_bitset(T), T) = sparse_bitset(T) <= enum(T).
     :- pred remove_gt(sparse_bitset(T)::in, T::in, sparse_bitset(T)::out)
         is det <= enum(T).

         % `remove_least(Set0, X, Set)' is true iff `X' is the least element in
         % `Set0', and `Set' is the set which contains all the elements of `Set0'
         % except `X'. Takes O(1) time and space.
         %
     :- pred remove_least(sparse_bitset(T)::in, T::out, sparse_bitset(T)::out)
         is semidet <= enum(T).

         % `union(SetA, SetB)' returns the union of `SetA' and `SetB'. The
         % efficiency of the union operation is not sensitive to the argument
         % ordering. Takes O(rep_size(SetA) + rep_size(SetB)) time and space.
         %
     :- func union(sparse_bitset(T), sparse_bitset(T)) = sparse_bitset(T).
     :- pred union(sparse_bitset(T)::in, sparse_bitset(T)::in,
         sparse_bitset(T)::out) is det.

         % `intersect(SetA, SetB)' returns the intersection of `SetA' and `SetB'.
         % The efficiency of the intersection operation is not sensitive to the
         % argument ordering. Takes O(rep_size(SetA) + rep_size(SetB)) time and
         % O(min(rep_size(SetA)), rep_size(SetB)) space.
         %
     :- func intersect(sparse_bitset(T), sparse_bitset(T)) = sparse_bitset(T).
     :- pred intersect(sparse_bitset(T)::in, sparse_bitset(T)::in,
         sparse_bitset(T)::out) is det.

         % `difference(SetA, SetB)' returns the set containing all the elements
         % of `SetA' except those that occur in `SetB'. Takes
         % O(rep_size(SetA) + rep_size(SetB)) time and O(rep_size(SetA)) space.
         %
     :- func difference(sparse_bitset(T), sparse_bitset(T)) = sparse_bitset(T).
     :- pred difference(sparse_bitset(T)::in, sparse_bitset(T)::in,
         sparse_bitset(T)::out) is det.

         % `count(Set)' returns the number of elements in `Set'.
         % Takes O(card(Set)) time.
         %
     :- func count(sparse_bitset(T)) = int <= enum(T).

         % `foldl(Func, Set, Start)' calls Func with each element of `Set'
         % (in sorted order) and an accumulator (with the initial value of `Start'),
         % and returns the final value. Takes O(card(Set)) time.
         %
     :- func foldl(func(T, U) = U, sparse_bitset(T), U) = U <= enum(T).

     :- pred foldl(pred(T, U, U), sparse_bitset(T), U, U) <= enum(T).
     :- mode foldl(pred(in, di, uo) is det, in, di, uo) is det.
     :- mode foldl(pred(in, in, out) is det, in, in, out) is det.
     :- mode foldl(pred(in, in, out) is semidet, in, in, out) is semidet.
     :- mode foldl(pred(in, in, out) is nondet, in, in, out) is nondet.
     :- mode foldl(pred(in, di, uo) is cc_multi, in, di, uo) is cc_multi.
     :- mode foldl(pred(in, in, out) is cc_multi, in, in, out) is cc_multi.

     :- pred foldl2(pred(T, U, U, V, V), sparse_bitset(T), U, U, V, V) <= enum(T).
     :- mode foldl2(pred(in, di, uo, di, uo) is det, in, di, uo, di, uo) is det.
     :- mode foldl2(pred(in, in, out, di, uo) is det, in, in, out, di, uo) is det.
     :- mode foldl2(pred(in, in, out, in, out) is det, in, in, out, in, out) is det.
     :- mode foldl2(pred(in, in, out, in, out) is semidet, in, in, out, in, out)
         is semidet.
     :- mode foldl2(pred(in, in, out, in, out) is nondet, in, in, out, in, out)
         is nondet.
     :- mode foldl2(pred(in, di, uo, di, uo) is cc_multi, in, di, uo, di, uo)
         is cc_multi.
     :- mode foldl2(pred(in, in, out, di, uo) is cc_multi, in, in, out, di, uo)
         is cc_multi.
     :- mode foldl2(pred(in, in, out, in, out) is cc_multi, in, in, out, in, out)
         is cc_multi.

         % `foldr(Func, Set, Start)' calls Func with each element of `Set'
         % (in reverse sorted order) and an accumulator (with the initial value
         % of `Start'), and returns the final value. Takes O(card(Set)) time.
         %
     :- func foldr(func(T, U) = U, sparse_bitset(T), U) = U <= enum(T).

     :- pred foldr(pred(T, U, U), sparse_bitset(T), U, U) <= enum(T).
     :- mode foldr(pred(in, di, uo) is det, in, di, uo) is det.
     :- mode foldr(pred(in, in, out) is det, in, in, out) is det.
     :- mode foldr(pred(in, in, out) is semidet, in, in, out) is semidet.
     :- mode foldr(pred(in, in, out) is nondet, in, in, out) is nondet.
     :- mode foldr(pred(in, di, uo) is cc_multi, in, di, uo) is cc_multi.
     :- mode foldr(pred(in, in, out) is cc_multi, in, in, out) is cc_multi.

     :- pred foldr2(pred(T, U, U, V, V), sparse_bitset(T), U, U, V, V) <= enum(T).
     :- mode foldr2(pred(in, di, uo, di, uo) is det, in, di, uo, di, uo) is det.
     :- mode foldr2(pred(in, in, out, di, uo) is det, in, in, out, di, uo) is det.
     :- mode foldr2(pred(in, in, out, in, out) is det, in, in, out, in, out) is det.
     :- mode foldr2(pred(in, in, out, in, out) is semidet, in, in, out, in, out)
         is semidet.
     :- mode foldr2(pred(in, in, out, in, out) is nondet, in, in, out, in, out)
         is nondet.
     :- mode foldr2(pred(in, di, uo, di, uo) is cc_multi, in, di, uo, di, uo)
         is cc_multi.
     :- mode foldr2(pred(in, in, out, di, uo) is cc_multi, in, in, out, di, uo)
         is cc_multi.
     :- mode foldr2(pred(in, in, out, in, out) is cc_multi, in, in, out, in, out)
         is cc_multi.

         % `filter(Pred, Set)' removes those elements from `Set' for which
         % `Pred' fails. In other words, it returns the set consisting of those
         % elements of `Set' for which `Pred' succeeds.
         %
     :- func filter(pred(T), sparse_bitset(T)) = sparse_bitset(T) <= enum(T).
     :- mode filter(pred(in) is semidet, in) = out is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: stack,  Next: std_util,  Prev: sparse_bitset,  Up: Top

67 stack
********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1994-1995, 1997-1999, 2005-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: stack.m.
     % Main author: fjh.
     % Stability: high.
     %
     % This file contains a `stack' ADT.
     % Stacks are implemented here using lists.
     %
     %--------------------------------------------------%

     :- module stack.
     :- interface.
     :- import_module list.

     %--------------------------------------------------%

     :- type stack(T).

     	% `stack.init(Stack)' is true iff `Stack' is an empty stack.
     	%
     :- pred stack.init(stack(T)::out) is det.
     :- func stack.init = stack(T).

     	% `stack.is_empty(Stack)' is true iff `Stack' is an empty stack.
     	%
     :- pred stack.is_empty(stack(T)::in) is semidet.

     	% `stack.is_full(Stack)' is intended to be true iff `Stack'
     	% is a stack whose capacity is exhausted.  This implementation
     	% allows arbitrary-sized stacks, so stack.is_full always fails.
     	%
     :- pred stack.is_full(stack(T)::in) is semidet.

     	% `stack.push(Stack0, Elem, Stack)' is true iff `Stack' is
     	% the stack which results from pushing `Elem' onto the top
     	% of `Stack0'.
     	%
     :- pred stack.push(stack(T)::in, T::in, stack(T)::out) is det.
     :- func stack.push(stack(T), T) = stack(T).

     	% `stack.push_list(Stack0, Elems, Stack)' is true iff `Stack'
     	% is the stack which results from pushing the elements of the
     	% list `Elems' onto the top of `Stack0'.
     	%
     :- pred stack.push_list(stack(T)::in, list(T)::in, stack(T)::out) is det.
     :- func stack.push_list(stack(T), list(T)) = stack(T).

     	% `stack.top(Stack, Elem)' is true iff `Stack' is a non-empty
     	% stack whose top element is `Elem'.
     	%
     :- pred stack.top(stack(T)::in, T::out) is semidet.

     	% `stack.top_det' is like `stack.top' except that it will
     	% call error/1 rather than failing if given an empty stack.
     	%
     :- pred stack.top_det(stack(T)::in, T::out) is det.
     :- func stack.top_det(stack(T)) = T.
     :- func stack.det_top(stack(T)) = T.

     	% `stack.pop(Stack0, Elem, Stack)' is true iff `Stack0' is
     	% a non-empty stack whose top element is `Elem', and `Stack'
     	% the stack which results from popping `Elem' off `Stack0'.
     	%
     :- pred stack.pop(stack(T)::in, T::out, stack(T)::out) is semidet.

     	% `stack.pop_det' is like `stack.pop' except that it will
     	% call error/1 rather than failing if given an empty stack.
     	%
     :- pred stack.pop_det(stack(T)::in, T::out, stack(T)::out) is det.
     :- pred stack.det_pop(stack(T)::in, T::out, stack(T)::out) is det.

     	% `stack.depth(Stack, Depth)' is true iff `Stack' is a stack
     	% containing `Depth' elements.
     	%
     :- pred stack.depth(stack(T)::in, int::out) is det.
     :- func stack.depth(stack(T)) = int.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: std_util,  Next: store,  Prev: stack,  Up: Top

68 std_util
***********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1994-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: std_util.m.
     % Main author: fjh.
     % Stability: high.
     %
     % This file contains higher-order programming constructs and other
     % useful standard utilities.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module std_util.
     :- interface.

     :- import_module maybe.

     %--------------------------------------------------%
     %
     % General purpose higher-order programming constructs
     %

         % compose(F, G, X) = F(G(X))
         %
         % Function composition.
         % XXX It would be nice to have infix `o' or somesuch for this.
         %
     :- func compose(func(T2) = T3, func(T1) = T2, T1) = T3.

         % converse(F, X, Y) = F(Y, X).
         %
     :- func converse(func(T1, T2) = T3, T2, T1) = T3.

         % pow(F, N, X) = F^N(X)
         %
         % Function exponentiation.
         %
     :- func pow(func(T) = T, int, T) = T.

         % The identity function.
         %
     :- func id(T) = T.

     %--------------------------------------------------%

         % maybe_pred(Pred, X, Y) takes a closure Pred which transforms an
         % input semideterministically. If calling the closure with the input
         % X succeeds, Y is bound to `yes(Z)' where Z is the output of the
         % call, or to `no' if the call fails.
         %
     :- pred maybe_pred(pred(T1, T2), T1, maybe(T2)).
     :- mode maybe_pred(pred(in, out) is semidet, in, out) is det.

     :- func maybe_func(func(T1) = T2, T1) = maybe(T2).
     :- mode maybe_func(func(in) = out is semidet, in) = out is det.

     %--------------------------------------------------%

         % isnt(Pred, X) <=> not Pred(X)
         %
         % This is useful in higher order programming, e.g.
         %   Odds  = list.filter(odd, Xs)
         %   Evens = list.filter(isnt(odd), Xs)
         %
     :- pred isnt(pred(T)::(pred(in) is semidet), T::in) is semidet.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: store,  Next: stream,  Prev: std_util,  Up: Top

69 store
********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1994-1997, 2000-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: store.m.
     % Main author: fjh.
     % Stability: low.
     %
     % This file provides facilities for manipulating mutable stores.
     % A store can be considered a mapping from abstract keys to their values.
     % A store holds a set of nodes, each of which may contain a value of any
     % type.
     %
     % Stores may be used to implement cyclic data structures such as circular
     % linked lists, etc.
     %
     % Stores can have two different sorts of keys:
     % mutable variables (mutvars) and references (refs).
     % The difference between mutvars and refs is that mutvars can only be updated
     % atomically, whereas it is possible to update individual fields of a
     % reference one at a time (presuming the reference refers to a structured
     % term).
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module store.
     :- interface.

     :- import_module io.

     %--------------------------------------------------%

         % Stores and keys are indexed by a type S of typeclass store(S) that
         % is used to distinguish between different stores.  By using an
         % existential type declaration for store.new (see below), we use the
         % type system to ensure at compile time that you never attempt to use
         % a key from one store to access a different store.
         %
     :- typeclass store(S).
     :- type store(S).

     :- instance store(io.state).
     :- instance store(store(S)).

         % Initialize a new store.
         %
     :- some [S] pred store.new(store(S)::uo) is det.

     %--------------------------------------------------%
     %
     % Mutvars
     %

         % generic_mutvar(T, S):
         % A mutable variable holding a value of type T in store S.
         %
     :- type generic_mutvar(T, S).
     :- type io_mutvar(T) == generic_mutvar(T, io.state).
     :- type store_mutvar(T, S) == generic_mutvar(T, store(S)).

         % Create a new mutable variable, initialized with the specified value.
         %
     :- pred store.new_mutvar(T::in, generic_mutvar(T, S)::out, S::di, S::uo)
         is det <= store(S).

         % copy_mutvar(OldMutvar, NewMutvar, S0, S) is equivalent to the sequence
         %   get_mutvar(OldMutvar, Value, S0, S1),
         %   new_mutvar(NewMutvar, Value, S1, S )
         %
     :- pred store.copy_mutvar(generic_mutvar(T, S)::in, generic_mutvar(T, S)::out,
         S::di, S::uo) is det <= store(S).

         % Lookup the value stored in a given mutable variable.
         %
     :- pred store.get_mutvar(generic_mutvar(T, S)::in, T::out,
         S::di, S::uo) is det <= store(S).

         % Replace the value stored in a given mutable variable.
         %
     :- pred store.set_mutvar(generic_mutvar(T, S)::in, T::in,
         S::di, S::uo) is det <= store(S).

         % new_cyclic_mutvar(Func, Mutvar):
         %
         % Create a new mutable variable, whose value is initialized
         % with the value returned from the specified function `Func'.
         % The argument passed to the function is the mutvar itself,
         % whose value has not yet been initialized (this is safe
         % because the function does not get passed the store, so
         % it can't examine the uninitialized value).
         %
         % This predicate is useful for creating self-referential values
         % such as circular linked lists.
         % For example:
         %
         %   :- type clist(T, S) ---> node(T, mutvar(clist(T, S))).
         %
         %   :- pred init_cl(T::in, clist(T, S)::out,
         %       store(S)::di, store(S)::uo) is det.
         %
         %   init_cl(X, CList, !Store) :-
         %       store.new_cyclic_mutvar(func(CL) = node(X, CL), CList,
         %       !Store).
         %
     :- pred store.new_cyclic_mutvar((func(generic_mutvar(T, S)) = T)::in,
         generic_mutvar(T, S)::out, S::di, S::uo) is det <= store(S).

     %--------------------------------------------------%
     %
     % References
     %

         % generic_ref(T, S):
         %
         % A reference to value of type T in store S.
         %
     :- type generic_ref(T, S).
     :- type io_ref(T, S) == generic_ref(T, io.state).
     :- type store_ref(T, S) == generic_ref(T, store(S)).

         % new_ref(Val, Ref):
         %   /* In C: Ref = malloc(...); *Ref = Val; */
         %
         % Given a value of any type `T', insert a copy of the term
         % into the store and return a new reference to that term.
         % (This does not actually perform a copy, it just returns a view
         % of the representation of that value.
         % It does however allocate one cell to hold the reference;
         % you can use new_arg_ref to avoid that.)
         %
     :- pred store.new_ref(T::di, generic_ref(T, S)::out,
         S::di, S::uo) is det <= store(S).

         % ref_functor(Ref, Functor, Arity):
         %
         % Given a reference to a term, return the functor and arity
         % of that term.
         %
     :- pred store.ref_functor(generic_ref(T, S)::in, string::out, int::out,
         S::di, S::uo) is det <= store(S).

         % arg_ref(Ref, ArgNum, ArgRef):
         %   /* Pseudo-C code: ArgRef = &Ref[ArgNum]; */
         %
         % Given a reference to a term, return a reference to
         % the specified argument (field) of that term
         % (argument numbers start from zero).
         % It is an error if the argument number is out of range,
         % or if the argument reference has the wrong type.
         %
     :- pred store.arg_ref(generic_ref(T, S)::in, int::in,
         generic_ref(ArgT, S)::out, S::di, S::uo) is det <= store(S).

         % new_arg_ref(Val, ArgNum, ArgRef):
         %   /* Pseudo-C code: ArgRef = &Val[ArgNum]; */
         %
         % Equivalent to `new_ref(Val, Ref), arg_ref(Ref, ArgNum, ArgRef)',
         % except that it is more efficient.
         % It is an error if the argument number is out of range,
         % or if the argument reference has the wrong type.
         %
     :- pred store.new_arg_ref(T::di, int::in, generic_ref(ArgT, S)::out,
         S::di, S::uo) is det <= store(S).

         % set_ref(Ref, ValueRef):
         %   /* Pseudo-C code: *Ref = *ValueRef; */
         %
         % Given a reference to a term (Ref),
         % a reference to another term (ValueRef),
         % update the store so that the term referred to by Ref
         % is replaced with the term referenced by ValueRef.
         %
     :- pred store.set_ref(generic_ref(T, S)::in, generic_ref(T, S)::in,
         S::di, S::uo) is det <= store(S).

         % set_ref_value(Ref, Value):
         %   /* Pseudo-C code: *Ref = Value; */
         %
         % Given a reference to a term (Ref), and a value (Value),
         % update the store so that the term referred to by Ref
         % is replaced with Value.
         %
     :- pred store.set_ref_value(generic_ref(T, S)::in, T::di,
         S::di, S::uo) is det <= store(S).

         % Given a reference to a term, return that term.
         % Note that this requires making a copy, so this pred may
         % be inefficient if used to return large terms; it
         % is most efficient with atomic terms.
         % XXX current implementation buggy (does shallow copy)
         %
     :- pred store.copy_ref_value(generic_ref(T, S)::in, T::uo,
         S::di, S::uo) is det <= store(S).

         % Same as above, but without making a copy. Destroys the store.
         %
     :- pred store.extract_ref_value(S::di, generic_ref(T, S)::in, T::out)
         is det <= store(S).

     %--------------------------------------------------%
     %
     % Nasty performance hacks
     %
     % WARNING: use of these procedures is dangerous!
     % Use them only as a last resort, only if performance is critical, and only if
     % profiling shows that using the safe versions is a bottleneck.
     %
     % These procedures may vanish in some future version of Mercury.

         % `unsafe_arg_ref' is the same as `arg_ref',
         % and `unsafe_new_arg_ref' is the same as `new_arg_ref'
         % except that they doesn't check for errors,
         % and they don't work for `no_tag' types (types with
         % exactly one functor which has exactly one argument),
         % and they don't work for types with >4 functors.
         % If the argument number is out of range,
         % or if the argument reference has the wrong type,
         % or if the argument is a `no_tag' type,
         % then the behaviour is undefined, and probably harmful.

     :- pred store.unsafe_arg_ref(generic_ref(T, S)::in, int::in,
         generic_ref(ArgT, S)::out, S::di, S::uo) is det <= store(S).

     :- pred store.unsafe_new_arg_ref(T::di, int::in, generic_ref(ArgT, S)::out,
         S::di, S::uo) is det <= store(S).

     %--------------------------------------------------%
     %
     % Interfaces retained only for backwards compatibility.
     % Some of these are unsafe.  All of them are deprecated.
     %

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: stream,  Next: stream.string_writer,  Prev: store,  Up: Top

70 stream
*********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et
     %--------------------------------------------------%
     % Copyright (C) 2006-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: stream.m.
     % Authors: juliensf, maclarty.
     % Stability: low
     %
     % This module provides a family of typeclasses for defining streams
     % in Mercury.  It also provides some generic predicates that operate
     % on instances of these typeclasses.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module stream.
     :- interface.

     :- import_module bool.
     :- import_module char.
     :- import_module list.
     :- import_module string.

     :- include_module string_writer.

     %--------------------------------------------------%
     %
     % Types used by streams
     %

     :- type stream.name == string.

     :- type stream.result(Error)
         --->    ok
         ;       eof
         ;       error(Error).

     :- type stream.result(T, Error)
         --->    ok(T)
         ;       eof
         ;       error(Error).

     :- type stream.res(Error)
         --->    ok
         ;       error(Error).

     :- type stream.res(T, Error)
         --->    ok(T)
         ;       error(Error).

         % stream.maybe_partial_res is used when it is possible to return
         % a partial result when an error occurs.
         %
     :- type stream.maybe_partial_res(T, Error)
         --->    ok(T)
         ;       error(T, Error).

     %--------------------------------------------------%
     %
     % Stream errors
     %

     :- typeclass stream.error(Error) where
     [

         % Convert a stream error into a human-readable format.
         % e.g. for use in error messages.
         %
         func error_message(Error) = string
     ].

     %--------------------------------------------------%
     %
     % Streams
     %

         % A stream consists of a handle type and a state type.
         % The state type is threaded through, and destructively updated by,
         % the stream operations.
         %
     :- typeclass stream.stream(Stream, State) <= (Stream -> State) where
     [
             % Returns a descriptive name for the stream.
             % Intended for use in error messages.
             %
             pred name(Stream::in, stream.name::out, State::di, State::uo) is det
     ].

     %--------------------------------------------------%
     %
     % Input streams
     %

         % An input stream is a source of data.
         %
     :- typeclass stream.input(Stream, State) <= stream(Stream, State) where [].

         % A reader stream is a subclass of specific input stream that can be
         % used to read data of a specific type from that input stream.
         % A single input stream can support multiple reader subclasses.
         %
     :- typeclass stream.reader(Stream, Unit, State, Error)
         <= (stream.input(Stream, State), stream.error(Error),
             (Stream, Unit -> Error)) where
     [
         % Get the next unit from the given stream.
         %
         % The get operation should block until the next unit is available,
         % or the end of the stream or an error is detected.
         %
         % If a call to get/4 returns `eof', all further calls to get/4 or
         % bulk_get/9 for that stream return `eof'.  If a call to get/4
         % returns `error(...)', all further calls to get/4 or bulk_get/4 for
         % that stream return an error, although not necessarily the same one.
         %
         % XXX We should provide an interface to allow the user to reset the
         % error status to try again if an error is transient.
         %
         pred get(Stream::in, stream.result(Unit, Error)::out,
             State::di, State::uo) is det
     ].

         % A bulk_reader stream is a subclass of specific input stream that can
         % be used to read multiple items of data of a specific type from that
         % input stream into a specified container.  For example, binary input
         % streams may be able to efficiently read bytes into a bitmap.
         % A single input stream can support multiple bulk_reader subclasses.
         %
     :- typeclass stream.bulk_reader(Stream, Index, Store, State, Error)
         <= (stream.input(Stream, State), stream.error(Error),
             (Stream, Index, Store -> Error)) where
     [
         % bulk_get(Stream, Index, NumItems, !Store, NumItemsRead, Result, !State).
         %
         % Read at most NumItems items into the given Store starting at the
         % given index, returning the number of items read.
         %
         % If the read succeeds, Result is `ok' and NumItemsRead equals NumItems.
         %
         % On end-of-stream, bulk_get/9 puts as many items as it can into !Store.
         % NumItemsRead is less than NumItems, and Result is `ok'.
         %
         % If an error is detected, bulk_get/9 puts as many items as it can into
         % !Store.  NumItemsRead is less than NumItems, and Result is `error(Err)'.
         %
         % Blocks until NumItems items are available or the end of the stream
         % is reached or an error is detected.
         %
         % Throws an exception if Index given is out of range or NumItems units
         % starting at Index will not fit in !Store.
         %
         % If a call to bulk_get/4 returns less than NumItems items, all further
         % calls to get/4 or bulk_get/4 for that stream return no items.  If a
         % call to bulk_get/9 returns `error(...)', all further calls to get/4
         % or bulk_get/9 for that stream return an error, although not necessarily
         % the same one.
         %
         pred bulk_get(Stream::in, Index::in, int::in,
             Store::bulk_get_di, Store::bulk_get_uo,
             int::out, stream.res(Error)::out, State::di, State::uo) is det
     ].

         % XXX These should be di and uo, but with the current state of the mode
         % system an unsafe_promise_unique call would be required at each call
         % to bulk_get.
     :- mode bulk_get_di == in.
     :- mode bulk_get_uo == out.

     %--------------------------------------------------%
     %
     % Output streams
     %

         % An output stream is a destination for data.
         % Note that unlike input streams, output streams do not include
         % an explicit error type.  They should handle errors by throwing
         % exceptions.
         %
     :- typeclass stream.output(Stream, State)
         <= stream(Stream, State) where
     [
         % For buffered output streams completely write out any data in the
         % buffer.  For unbuffered streams this operation is a no-op.
         %
         pred flush(Stream::in, State::di, State::uo) is det
     ].

         % A writer stream is a subclass of specific output stream that can be
         % used to write data of a specific type to that output stream.
         % A single output stream can support multiple writer subclasses.
         %
     :- typeclass stream.writer(Stream, Unit, State)
         <= stream.output(Stream, State) where
     [
         % Write the next unit to the given stream.
         % Blocks if the whole unit can't be written to the stream at the time
         % of the call (for example because a buffer is full).
         %
         pred put(Stream::in, Unit::in, State::di, State::uo) is det
     ].

     %--------------------------------------------------%
     %
     % Duplex streams
     %

         % A duplex stream is a stream that can act as both a source
         % and destination of data, i.e. it is a both an input and
         % an output stream.
         %
     :- typeclass stream.duplex(Stream, State)
         <= (stream.input(Stream, State), stream.output(Stream, State))
             where [].

     %--------------------------------------------------%
     %
     % Putback streams
     %

         % A putback stream is an input stream that allows data to be
         % pushed back onto the stream.  As with reader subclasses it is
         % possible to define multiple putback subclasses for a
         % single input stream.
         %
     :- typeclass stream.putback(Stream, Unit, State, Error)
         <= stream.reader(Stream, Unit, State, Error) where
     [
         % Un-gets a unit from the specified input stream.
         % Only one unit of putback is guaranteed to be successful.
         %
         pred unget(Stream::in, Unit::in, State::di, State::uo) is det
     ].

         % As above but guarantees that an unlimited number of units may
         % be pushed back onto the stream.
         %
     :- typeclass stream.unbounded_putback(Stream, Unit, State, Error)
         <= stream.putback(Stream, Unit, State, Error) where [].

     %--------------------------------------------------%
     %
     % Seekable streams
     %

         % stream.whence denotes the base for a seek operation.
         %   set - seek relative to the start of the file
         %   cur - seek relative to the current position in the file
         %   end - seek relative to the end of the file.
         %
     :- type stream.whence
         --->    set
         ;       cur
         ;       end.

     :- typeclass stream.seekable(Stream, State) <= stream(Stream, State)
         where
     [
         % Seek to an offset relative to whence on the specified stream.
         % The offset is measured in bytes.
         %
         pred seek(Stream::in, stream.whence::in, int::in, State::di, State::uo)
             is det
     ].

     %--------------------------------------------------%
     %
     % Line oriented streams
     %

         % A line oriented stream is a stream that keeps track of line numbers.
         %
     :- typeclass stream.line_oriented(Stream, State) <= stream(Stream, State)
         where
     [
         % Get the current line number for the specified stream.
         %
         pred get_line(Stream::in, int::out, State::di, State::uo) is det,

         % Set the current line number of the specified stream.
         %
         pred set_line(Stream::in, int::in,  State::di, State::uo) is det
     ].

     %--------------------------------------------------%
     %
     % Generic folds over input streams
     %

         % Applies the given closure to each Unit read from the input stream
         % in turn, until eof or error.
         %
     :- pred stream.input_stream_fold(Stream, pred(Unit, T, T), T,
         stream.maybe_partial_res(T, Error), State, State)
         <= stream.reader(Stream, Unit, State, Error).
     :- mode stream.input_stream_fold(in, in(pred(in, in, out) is det),
         in, out, di, uo) is det.
     :- mode stream.input_stream_fold(in, in(pred(in, in, out) is cc_multi),
         in, out, di, uo) is cc_multi.

         % Applies the given closure to each Unit read from the input stream
         % in turn, until eof or error.
         %
     :- pred stream.input_stream_fold_state(Stream, pred(Unit, State, State),
         stream.res(Error), State, State)
         <= stream.reader(Stream, Unit, State, Error).
     :- mode stream.input_stream_fold_state(in, in(pred(in, di, uo) is det),
         out, di, uo) is det.
     :- mode stream.input_stream_fold_state(in, in(pred(in, di, uo) is cc_multi),
         out, di, uo) is cc_multi.

         % Applies the given closure to each Unit read from the input stream
         % in turn, until eof or error.
         %
     :- pred stream.input_stream_fold2_state(Stream,
         pred(Unit, T, T, State, State), T, stream.maybe_partial_res(T, Error),
         State, State) <= stream.reader(Stream, Unit, State, Error).
     :- mode stream.input_stream_fold2_state(in,
         in(pred(in, in, out, di, uo) is det),
         in, out, di, uo) is det.
     :- mode stream.input_stream_fold2_state(in,
         in(pred(in, in, out, di, uo) is cc_multi),
         in, out, di, uo) is cc_multi.

         % Applies the given closure to each Unit read from the input stream
         % in turn, until eof or error, or the closure returns `no' as its
         % second argument.
         %
     :- pred stream.input_stream_fold2_state_maybe_stop(Stream,
         pred(Unit, bool, T, T, State, State),
         T, stream.maybe_partial_res(T, Error), State, State)
         <= stream.reader(Stream, Unit, State, Error).
     :- mode stream.input_stream_fold2_state_maybe_stop(in,
         in(pred(in, out, in, out, di, uo) is det), in, out, di, uo) is det.
     :- mode stream.input_stream_fold2_state_maybe_stop(in,
         in(pred(in, out, in, out, di, uo) is cc_multi), in, out, di, uo)
         is cc_multi.

     %--------------------------------------------------%
     %
     % Misc. operations on input streams
     %

         % Discard all the whitespace from the specified stream.
         %
     :- pred stream.ignore_whitespace(Stream::in, stream.result(Error)::out,
         State::di, State::uo)
         is det <= stream.putback(Stream, char, State, Error).

     %--------------------------------------------------%
     %
     % Misc. operations on output streams
     %

         % put_list(Stream, Write, Sep, List, !State).
         %
         % Write all the elements List to Stream separated by Sep.
         %
     :- pred put_list(Stream, pred(Stream, T, State, State),
         pred(Stream, State, State), list(T), State, State)
         <= stream.output(Stream, State).
     :- mode put_list(in, pred(in, in, di, uo) is det, pred(in, di, uo) is det,
         in, di, uo) is det.
     :- mode put_list(in, pred(in, in, di, uo) is cc_multi,
         pred(in, di, uo) is cc_multi, in, di, uo) is cc_multi.
     :- mode put_list(in, pred(in, in, di, uo) is cc_multi,
         pred(in, di, uo) is det, in, di, uo) is cc_multi.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: stream.string_writer,  Next: string.builder,  Prev: stream,  Up: Top

71 stream.string_writer
***********************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et
     %--------------------------------------------------%
     % Copyright (C) 2006-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: stream.string_writer.m.
     % Authors: trd, fjh, stayl
     %
     % Predicates to write to streams that accept strings.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module stream.string_writer.
     :- interface.

     :- import_module char.
     :- import_module deconstruct.
     :- import_module io.
     :- import_module list.
     :- import_module string.
     :- import_module univ.

     %--------------------------------------------------%

     :- pred put_int(Stream::in, int::in, State::di, State::uo) is det
         <= stream.writer(Stream, string, State).

     :- pred put_float(Stream::in, float::in, State::di, State::uo) is det
         <= stream.writer(Stream, string, State).

     :- pred put_char(Stream::in, char::in, State::di, State::uo) is det
         <= stream.writer(Stream, string, State).

         % A version of io.format that works for arbitrary string writers.
         %
     :- pred format(Stream::in, string::in, list(string.poly_type)::in,
         State::di, State::uo) is det <= stream.writer(Stream, string, State).

     :- pred nl(Stream::in, State::di, State::uo) is det
         <= stream.writer(Stream, string, State).

         % print/3 writes its argument to the standard output stream.
         % print/4 writes its second argument to the output stream specified
         % in its first argument. In all cases, the argument to output can be
         % of any type. It is output in a format that is intended to be human
         % readable.
         %
         % If the argument is just a single string or character, it will be printed
         % out exactly as is (unquoted). If the argument is of type univ, then
         % it will print out the value stored in the univ, but not the type.
         %
         % print/5 is the same as print/4 except that it allows the caller
         % to specify how non-canonical types should be handled. print/3 and
         % print/4 implicitly specify `canonicalize' as the method for handling
         % non-canonical types. This means that for higher-order types, or types
         % with user-defined equality axioms, or types defined using the foreign
         % language interface (i.e. pragma foreign_type), the text output will
         % only describe the type that is being printed, not the value.
         %
         % print_cc/3 is the same as print/3 except that it specifies
         % `include_details_cc' rather than `canonicalize'. This means that it will
         % print the details of non-canonical types. However, it has determinism
         % `cc_multi'.
         %
         % Note that even if `include_details_cc' is specified, some implementations
         % may not be able to print all the details for higher-order types or types
         % defined using the foreign language interface.
         %
     :- pred print(Stream::in, T::in, State::di, State::uo) is det
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).

     :- pred print(Stream, deconstruct.noncanon_handling, T, State, State)
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).
     :- mode print(in, in(do_not_allow), in, di, uo) is det.
     :- mode print(in, in(canonicalize), in, di, uo) is det.
     :- mode print(in, in(include_details_cc), in, di, uo) is cc_multi.
     :- mode print(in, in, in, di, uo) is cc_multi.

     :- pred print_cc(Stream::in, T::in, State::di, State::uo) is cc_multi
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).

         % write/4 writes its second argument to the output stream specified
         % in its first argument. In all cases, the argument to output may be
         % of any type. The argument is written in a format that is intended to
         % be valid Mercury syntax whenever possible.
         %
         % Strings and characters are always printed out in quotes, using backslash
         % escapes if necessary. For higher-order types, or for types defined
         % using the foreign language interface (pragma foreign_code), the text
         % output will only describe the type that is being printed, not the value,
         % and the result may not be parsable by `read'. For the types
         % containing existential quantifiers, the type `type_desc' and closure
         % types, the result may not be parsable by `read', either. But in all
         % other cases the format used is standard Mercury syntax, and if you append
         % a period and newline (".\n"), then the results can be read in again
         % using `read'.
         %
         % write/5 is the same as write/4 except that it allows the caller
         % to specify how non-canonical types should be handled. write_cc/4
         % is the same as write/4 except that it specifies `include_details_cc'
         % rather than `canonicalize'.
         %
     :- pred write(Stream::in, T::in, State::di, State::uo) is det
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).

     :- pred write(Stream, deconstruct.noncanon_handling, T, State, State) is det
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).
     :- mode write(in, in(do_not_allow), in, di, uo) is det.
     :- mode write(in, in(canonicalize), in, di, uo) is det.
     :- mode write(in, in(include_details_cc), in, di, uo) is cc_multi.
     :- mode write(in, in, in, di, uo) is cc_multi.

     :- pred write_cc(Stream::in, T::in, State::di, State::uo) is cc_multi
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: string.builder,  Next: string,  Prev: stream.string_writer,  Up: Top

72 string.builder
*****************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et
     %--------------------------------------------------%
     % Copyright (C) 2006-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: string.builder.m.
     % Main author: maclarty.
     %
     % This module implements a string builder stream.  It can be used to
     % build up a string using string or character writers.
     %
     % To build up a string using this module, you first construct an initial
     % string builder state by calling the init function.  You can then use
     % any instances of stream.writer that write strings or characters to update the
     % string builder state, using string.builder.handle as the stream argument.
     % Once you've finished writing to the string builder you can get the final
     % string by calling string.builder.to_string/1.
     %
     % For example:
     %
     %     State0 = string.builder.init,
     %     stream.string_writer.put_int(string.builder.handle, 5, State0, State),
     %     Str = string.builder.to_string(State),  % Str = "5".
     %
     %--------------------------------------------------%

     :- module string.builder.
     :- interface.

     :- import_module char.
     :- import_module stream.

     %--------------------------------------------------%

     :- type handle
         --->    handle.

     :- type state.

     :- func init = (string.builder.state::uo) is det.

     :- instance stream.stream(string.builder.handle, string.builder.state).

     :- instance stream.output(string.builder.handle, string.builder.state).

     :- instance stream.writer(string.builder.handle, string, string.builder.state).
     :- instance stream.writer(string.builder.handle, char, string.builder.state).

     :- func to_string(string.builder.state::di) = (string::uo) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: string,  Next: svarray,  Prev: string.builder,  Up: Top

73 string
*********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1993-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: string.m.
     % Main authors: fjh, petdr.
     % Stability: medium to high.
     %
     % This modules provides basic string handling facilities.
     %
     % Unexpected null characters embedded in the middle of strings can be a source
     % of security vulnerabilities, so the Mercury library predicates and functions
     % which create strings from (lists of) characters throw an exception if a null
     % character is detected.  Programmers must not create strings that might
     % contain null characters using the foreign language interface.
     %
     % The representation of strings is implementation dependent and subject to
     % change. In the current implementation, when Mercury is compiled to C, strings
     % are represented as in C, using a null character as the string terminator.
     % When Mercury is compiled to Java, strings are represented as Java `String's.
     % When Mercury is compiled to .NET IL code, strings are represented as .NET
     % `System.String's.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module string.
     :- interface.

     :- include_module builder.

     :- import_module assoc_list.
     :- import_module char.
     :- import_module deconstruct.
     :- import_module list.
     :- import_module maybe.
     :- import_module ops.
     :- import_module pretty_printer.

     %--------------------------------------------------%

         % This type is used for defining stream typeclass instances where the raw
         % string type would be ambiguous. A line is:
         %
         % - a possibly empty sequence of non-newline characters terminated by a
         %   newline character; or
         % - a non-empty sequence of non-newline characters terminated by the end
         %   of the file.
         %
     :- type line
         --->    line(string).

         % This type is used for defining stream typeclass instances where the raw
         % string type would be ambiguous. A text file is a possibly empty sequence
         % of characters terminated by the end of file.
         %
     :- type text_file
         --->    text_file(string).

         % Determine the length of a string.
         % An empty string has length zero.
         %
     :- func string.length(string::in) = (int::uo) is det.
     :- pred string.length(string, int).
     :- mode string.length(in, uo) is det.
     :- mode string.length(ui, uo) is det.

         % Append two strings together.
         %
     :- func string.append(string::in, string::in) = (string::uo) is det.

     :- pred string.append(string, string, string).
     :- mode string.append(in, in, in) is semidet.  % implied
     :- mode string.append(in, uo, in) is semidet.
     :- mode string.append(in, in, uo) is det.
     :- mode string.append(out, out, in) is multi.
     % The following mode is semidet in the sense that it doesn't succeed more
     % than once - but it does create a choice-point, which means it's inefficient
     % and that the compiler can't deduce that it is semidet.
     % Use string.remove_suffix instead.
     % :- mode string.append(out, in, in) is semidet.

         % S1 ++ S2 = S :- string.append(S1, S2, S).
         %
         % Nicer syntax.
     :- func string ++ string = string.
     :- mode in ++ in = uo is det.

         % string.remove_suffix(String, Suffix, Prefix):
         % The same as string.append(Prefix, Suffix, String) except that
         % this is semidet whereas string.append(out, in, in) is nondet.
         %
     :- pred string.remove_suffix(string::in, string::in, string::out) is semidet.

         % string.remove_suffix_if_present(Suffix, String) returns `String' minus
         % `Suffix' if `String' ends with `Suffix', `String' otherwise
         %
     :- func string.remove_suffix_if_present(string, string) = string.

         % string.prefix(String, Prefix) is true iff Prefix is a prefix of String.
         % Same as string.append(Prefix, _, String).
         %
     :- pred string.prefix(string, string).
     :- mode string.prefix(in, in) is semidet.
     :- mode string.prefix(in, out) is multi.

         % string.suffix(String, Suffix) is true iff Suffix is a suffix of String.
         % Same as string.append(_, Suffix, String).
         %
     :- pred string.suffix(string, string).
     :- mode string.suffix(in, in) is semidet.
     :- mode string.suffix(in, out) is multi.

         % string.string(X): Returns a canonicalized string representation
         % of the value X using the standard Mercury operators.
         %
     :- func string.string(T) = string.

         % As above, but using the supplied table of operators.
         %
     :- func string.string_ops(ops.table, T) = string.

         % string.string_ops_noncanon(NonCanon, OpsTable, X, String)
         %
         % As above, but the caller specifies what behaviour should occur for
         % non-canonical terms (i.e. terms where multiple representations
         % may compare as equal):
         %
         % - `do_not_allow' will throw an exception if (any subterm of) the argument
         %    is not canonical;
         % - `canonicalize' will substitute a string indicating the presence
         %    of a non-canonical subterm;
         % - `include_details_cc' will show the structure of any non-canonical
         %   subterms, but can only be called from a committed choice context.
         %
     :- pred string.string_ops_noncanon(noncanon_handling, ops.table, T, string).
     :- mode string.string_ops_noncanon(in(do_not_allow), in, in, out) is det.
     :- mode string.string_ops_noncanon(in(canonicalize), in, in, out) is det.
     :- mode string.string_ops_noncanon(in(include_details_cc), in, in, out)
         is cc_multi.
     :- mode string.string_ops_noncanon(in, in, in, out) is cc_multi.

         % string.char_to_string(Char, String).
         % Converts a character (single-character atom) to a string or vice versa.
         %
     :- func string.char_to_string(char::in) = (string::uo) is det.
     :- pred string.char_to_string(char, string).
     :- mode string.char_to_string(in, uo) is det.
     :- mode string.char_to_string(out, in) is semidet.

         % A synonym for string.char_to_string/1.
         %
     :- func string.from_char(char::in) = (string::uo) is det.

         % Convert an integer to a string.
         %
     :- func string.int_to_string(int::in) = (string::uo) is det.
     :- pred string.int_to_string(int::in, string::uo) is det.

         % A synonym for string.int_to_string/1.
         %
     :- func string.from_int(int::in) = (string::uo) is det.

         % Convert an integer to a string with commas as thousand separators.
         %
     :- func string.int_to_string_thousands(int::in) = (string::uo) is det.

         % string.int_to_base_string(Int, Base, String):
         % Convert an integer to a string in a given Base.
         % An exception is thrown if Base is not between 2 and 36.
         %
     :- func string.int_to_base_string(int::in, int::in) = (string::uo) is det.
     :- pred string.int_to_base_string(int::in, int::in, string::uo) is det.

         % string.int_to_base_string_group(Int, Base, GroupLength, Separator,
         %   String):
         % Convert an integer to a string in a given Base (between 2 and 36)
         % and insert Separator between every GroupLength digits.
         % If GroupLength is less than one then no separators will appear in the
         % output.  An exception is thrown if Base is not between 2 and 36.
         % Useful for formatting numbers like "1,300,000".
         %
     :- func string.int_to_base_string_group(int, int, int, string) = string.
     :- mode string.int_to_base_string_group(in, in, in, in) = uo is det.

         % Convert a float to a string.
         % In the current implementation the resulting float will be in the form
         % that it was printed using the format string "%#.<prec>g".
         % <prec> will be in the range p to (p+2)
         % where p = floor(mantissa_digits * log2(base_radix) / log2(10)).
         % The precision chosen from this range will be such to allow a successful
         % decimal -> binary conversion of the float.
         %
     :- func string.float_to_string(float::in) = (string::uo) is det.
     :- pred string.float_to_string(float::in, string::uo) is det.

         % A synonym for string.float_to_string/1.
         %
     :- func string.from_float(float::in) = (string::uo) is det.

         % Convert a c_pointer to a string.  The format is "c_pointer(0xXXXX)"
         % where XXXX is the hexadecimal representation of the pointer.
         %
     :- func string.c_pointer_to_string(c_pointer::in) = (string::uo) is det.
     :- pred string.c_pointer_to_string(c_pointer::in, string::uo) is det.

         % A synonym for string.c_pointer_to_string/1.
         %
     :- func string.from_c_pointer(c_pointer::in) = (string::uo) is det.

         % string.first_char(String, Char, Rest) is true iff Char is the first
         % character of String, and Rest is the remainder.
         %
         % WARNING: string.first_char makes a copy of Rest because the garbage
         % collector doesn't handle references into the middle of an object,
         % at least not the way we use it. Repeated use of string.first_char
         % to iterate over a string will result in very poor performance.
         % Use string.foldl or string.to_char_list instead.
         %
     :- pred string.first_char(string, char, string).
     :- mode string.first_char(in, in, in) is semidet.  % implied
     :- mode string.first_char(in, uo, in) is semidet.  % implied
     :- mode string.first_char(in, in, uo) is semidet.  % implied
     :- mode string.first_char(in, uo, uo) is semidet.
     :- mode string.first_char(uo, in, in) is det.

         % string.replace(String0, Search, Replace, String):
         % string.replace replaces the first occurrence of Search in String0
         % with Replace to give String. It fails if Search does not occur
         % in String0.
         %
     :- pred string.replace(string::in, string::in, string::in, string::uo)
         is semidet.

         % string.replace_all(String0, Search, Replace, String):
         % string.replace_all replaces any occurrences of Search in String0
         % with Replace to give String.
         %
     :- func string.replace_all(string::in, string::in, string::in) = (string::uo)
         is det.
     :- pred string.replace_all(string::in, string::in, string::in, string::uo)
         is det.

         % Converts a string to lowercase.
         % Note that this only converts unaccented Latin letters.
         %
     :- func string.to_lower(string::in) = (string::uo) is det.
     :- pred string.to_lower(string, string).
     :- mode string.to_lower(in, uo) is det.
     :- mode string.to_lower(in, in) is semidet.        % implied

         % Converts a string to uppercase.
         % Note that this only converts unaccented Latin letters.
         %
     :- func string.to_upper(string::in) = (string::uo) is det.
     :- pred string.to_upper(string, string).
     :- mode string.to_upper(in, uo) is det.
     :- mode string.to_upper(in, in) is semidet.        % implied

         % Convert the first character (if any) of a string to uppercase.
         % Note that this only converts unaccented Latin letters.
         %
     :- func string.capitalize_first(string) = string.
     :- pred string.capitalize_first(string::in, string::out) is det.

         % Convert the first character (if any) of a string to lowercase.
         % Note that this only converts unaccented Latin letters.
         %
     :- func string.uncapitalize_first(string) = string.
     :- pred string.uncapitalize_first(string::in, string::out) is det.

         % Convert the string to a list of characters.
         % Throws an exception if the list of characters contains a null character.
         %
     :- func string.to_char_list(string) = list(char).
     :- pred string.to_char_list(string, list(char)).
     :- mode string.to_char_list(in, out) is det.
     :- mode string.to_char_list(uo, in) is det.

         % Convert a list of characters to a string.
         % Throws an exception if the list of characters contains a null character.
         %
     :- func string.from_char_list(list(char)::in) = (string::uo) is det.
     :- pred string.from_char_list(list(char), string).
     :- mode string.from_char_list(in, uo) is det.
     :- mode string.from_char_list(out, in) is det.

         % As above, but fail instead of throwing an exception if the
         % list contains a null character.
     :- pred string.semidet_from_char_list(list(char)::in, string::uo) is semidet.

         % Same as string.from_char_list, except that it reverses the order
         % of the characters.
         % Throws an exception if the list of characters contains a null character.
         %
     :- func string.from_rev_char_list(list(char)::in) = (string::uo) is det.
     :- pred string.from_rev_char_list(list(char)::in, string::uo) is det.

         % As above, but fail instead of throwing an exception if the
         % list contains a null character.
     :- pred string.semidet_from_rev_char_list(list(char)::in, string::uo)
         is semidet.

         % Converts a signed base 10 string to an int; throws an exception
         % if the string argument does not match the regexp [+-]?[0-9]+
         %
     :- func string.det_to_int(string) = int.

         % Convert a string to an int. The string must contain only digits,
         % optionally preceded by a plus or minus sign. If the string does
         % not match this syntax, string.to_int fails.
     :- pred string.to_int(string::in, int::out) is semidet.

         % Convert a string in the specified base (2-36) to an int. The string
         % must contain one or more digits in the specified base, optionally
         % preceded by a plus or minus sign. For bases > 10, digits 10 to 35
         % are represented by the letters A-Z or a-z. If the string does not match
         % this syntax, the predicate fails.
         %
     :- pred string.base_string_to_int(int::in, string::in, int::out) is semidet.

         % Converts a signed base N string to an int; throws an exception
         % if the string argument is not precisely an optional sign followed by
         % a non-empty string of base N digits.
         %
     :- func string.det_base_string_to_int(int, string) = int.

         % Convert a string to a float. Throws an exception if the string is not
         % a syntactically correct float literal.
         %
     :- func string.det_to_float(string) = float.

         % Convert a string to a float. If the string is not a syntactically correct
         % float literal, string.to_float fails.
         %
     :- pred string.to_float(string::in, float::out) is semidet.

         % True if string contains only alphabetic characters (letters).
         %
     :- pred string.is_all_alpha(string::in) is semidet.

         % True if string contains only alphabetic characters and underscores.
         %
     :- pred string.is_all_alpha_or_underscore(string::in) is semidet.

         % True if string contains only letters, digits, and underscores.
         %
     :- pred string.is_all_alnum_or_underscore(string::in) is semidet.

         % string.pad_left(String0, PadChar, Width, String):
         % Insert `PadChar's at the left of `String0' until it is at least as long
         % as `Width', giving `String'.
         %
     :- func string.pad_left(string, char, int) = string.
     :- pred string.pad_left(string::in, char::in, int::in, string::out) is det.

         % string.pad_right(String0, PadChar, Width, String):
         % Insert `PadChar's at the right of `String0' until it is at least as long
         % as `Width', giving `String'.
         %
     :- func string.pad_right(string, char, int) = string.
     :- pred string.pad_right(string::in, char::in, int::in, string::out) is det.

         % string.duplicate_char(Char, Count, String):
         % Construct a string consisting of `Count' occurrences of `Char'
         % in sequence.
         %
     :- func string.duplicate_char(char::in, int::in) = (string::uo) is det.
     :- pred string.duplicate_char(char::in, int::in, string::uo) is det.

         % string.contains_char(String, Char):
         % Succeed if `Char' occurs in `String'.
         %
     :- pred string.contains_char(string::in, char::in) is semidet.

         % string.index(String, Index, Char):
         % `Char' is the (`Index' + 1)-th character of `String'.
         % Fails if `Index' is out of range (negative, or greater than or equal to
         % the length of `String').
         %
     :- pred string.index(string::in, int::in, char::uo) is semidet.

         % string.index_det(String, Index, Char):
         % `Char' is the (`Index' + 1)-th character of `String'.
         % Calls error/1 if `Index' is out of range (negative, or greater than
         % or equal to the length of `String').
         %
     :- func string.index_det(string, int) = char.
     :- pred string.index_det(string::in, int::in, char::uo) is det.

         % A synonym for index_det/2:
         % String ^ elem(Index) = string.index_det(String, Index).
         %
     :- func string ^ elem(int) = char.

         % string.unsafe_index(String, Index, Char):
         % `Char' is the (`Index' + 1)-th character of `String'.
         % WARNING: behavior is UNDEFINED if `Index' is out of range
         % (negative, or greater than or equal to the length of `String').
         % This version is constant time, whereas string.index_det
         % may be linear in the length of the string. Use with care!
         %
     :- func string.unsafe_index(string, int) = char.
     :- pred string.unsafe_index(string::in, int::in, char::uo) is det.

         % A synonym for unsafe_index/2:
         % String ^ unsafe_elem(Index) = string.unsafe_index(String, Index).
         %
     :- func string ^ unsafe_elem(int) = char.

         % string.chomp(String):
         % `String' minus any single trailing newline character.
         %
     :- func string.chomp(string) = string.

         % string.lstrip(String):
         % `String' minus any initial whitespace characters.
         %
     :- func string.lstrip(string) = string.

         % string.rstrip(String):
         % `String' minus any trailing whitespace characters.
         %
     :- func string.rstrip(string) = string.

         % string.strip(String):
         % `String' minus any initial and trailing whitespace characters.
         %
     :- func string.strip(string) = string.

         % string.lstrip_pred(Pred, String):
         % `String' minus the maximal prefix consisting entirely of chars
         % satisfying `Pred'.
         %
     :- func string.lstrip_pred(pred(char)::in(pred(in) is semidet), string::in)
         = (string::out) is det.

         % string.rstrip_pred(Pred, String):
         % `String' minus the maximal suffix consisting entirely of chars
         % satisfying `Pred'.
         %
     :- func string.rstrip_pred(pred(char)::in(pred(in) is semidet), string::in)
         = (string::out) is det.

         % string.prefix_length(Pred, String):
         % The length of the maximal prefix of `String' consisting entirely of
         % chars satisfying Pred.
         %
     :- func string.prefix_length(pred(char)::in(pred(in) is semidet), string::in)
         = (int::out) is det.

         % string.suffix_length(Pred, String):
         % The length of the maximal suffix of `String' consisting entirely of chars
         % satisfying Pred.
         %
     :- func suffix_length(pred(char)::in(pred(in) is semidet), string::in)
         = (int::out) is det.

         % string.set_char(Char, Index, String0, String):
         % `String' is `String0' with the (`Index' + 1)-th character set to `Char'.
         % Fails if `Index' is out of range (negative, or greater than or equal to
         % the length of `String0').
         %
     :- pred string.set_char(char, int, string, string).
     :- mode string.set_char(in, in, in, out) is semidet.
     % XXX This mode is disabled because the compiler puts constant
     % strings into static data even when they might be updated.
     %:- mode string.set_char(in, in, di, uo) is semidet.

         % string.set_char_det(Char, Index, String0, String):
         % `String' is `String0' with the (`Index' + 1)-th character set to `Char'.
         % Calls error/1 if `Index' is out of range (negative, or greater than
         % or equal to the length of `String0').
         %
     :- func string.set_char_det(char, int, string) = string.
     :- pred string.set_char_det(char, int, string, string).
     :- mode string.set_char_det(in, in, in, out) is det.
     % XXX This mode is disabled because the compiler puts constant
     % strings into static data even when they might be updated.
     %:- mode string.set_char_det(in, in, di, uo) is det.

         % string.unsafe_set_char(Char, Index, String0, String):
         % `String' is `String0' with the (`Index' + 1)-th character set to `Char'.
         % WARNING: behavior is UNDEFINED if `Index' is out of range
         % (negative, or greater than or equal to the length of `String0').
         % This version is constant time, whereas string.set_char_det
         % may be linear in the length of the string. Use with care!
         %
     :- func string.unsafe_set_char(char, int, string) = string.
     :- mode string.unsafe_set_char(in, in, in) = out is det.
     % XXX This mode is disabled because the compiler puts constant
     % strings into static data even when they might be updated.
     %:- mode string.unsafe_set_char(in, in, di) = uo is det.
     :- pred string.unsafe_set_char(char, int, string, string).
     :- mode string.unsafe_set_char(in, in, in, out) is det.
     % XXX This mode is disabled because the compiler puts constant
     % strings into static data even when they might be updated.
     %:- mode string.unsafe_set_char(in, in, di, uo) is det.

         % string.foldl(Closure, String, !Acc):
         % `Closure' is an accumulator predicate which is to be called for each
         % character of the string `String' in turn. The initial value of the
         % accumulator is `!.Acc' and the final value is `!:Acc'.
         % (string.foldl is equivalent to
         %   string.to_char_list(String, Chars),
         %   list.foldl(Closure, Chars, !Acc)
         % but is implemented more efficiently.)
         %
     :- func string.foldl(func(char, A) = A, string, A) = A.
     :- pred string.foldl(pred(char, A, A), string, A, A).
     :- mode string.foldl(pred(in, di, uo) is det, in, di, uo) is det.
     :- mode string.foldl(pred(in, in, out) is det, in, in, out) is det.
     :- mode string.foldl(pred(in, in, out) is semidet, in, in, out) is semidet.
     :- mode string.foldl(pred(in, in, out) is nondet, in, in, out) is nondet.
     :- mode string.foldl(pred(in, in, out) is multi, in, in, out) is multi.

         % string.foldl2(Closure, String, !Acc1, !Acc2):
         % A variant of string.foldl with two accumulators.
         %
     :- pred string.foldl2(pred(char, A, A, B, B), string, A, A, B, B).
     :- mode string.foldl2(pred(in, di, uo, di, uo) is det,
         in, di, uo, di, uo) is det.
     :- mode string.foldl2(pred(in, in, out, di, uo) is det,
         in, in, out, di, uo) is det.
     :- mode string.foldl2(pred(in, in, out, in, out) is det,
         in, in, out, in, out) is det.
     :- mode string.foldl2(pred(in, in, out, in, out) is semidet,
         in, in, out, in, out) is semidet.
     :- mode string.foldl2(pred(in, in, out, in, out) is nondet,
         in, in, out, in, out) is nondet.
     :- mode string.foldl2(pred(in, in, out, in, out) is multi,
         in, in, out, in, out) is multi.

         % string.foldl_substring(Closure, String, Start, Count, !Acc)
         % is equivalent to string.foldl(Closure, SubString, !Acc)
         % where SubString = string.substring(String, Start, Count).
         %
     :- func string.foldl_substring(func(char, A) = A, string, int, int, A) = A.
     :- pred string.foldl_substring(pred(char, A, A), string, int, int, A, A).
     :- mode string.foldl_substring(pred(in, in, out) is det, in, in, in,
         in, out) is det.
     :- mode string.foldl_substring(pred(in, di, uo) is det, in, in, in,
         di, uo) is det.
     :- mode string.foldl_substring(pred(in, in, out) is semidet, in, in, in,
         in, out) is semidet.
     :- mode string.foldl_substring(pred(in, in, out) is nondet, in, in, in,
         in, out) is nondet.
     :- mode string.foldl_substring(pred(in, in, out) is multi, in, in, in,
         in, out) is multi.

         % string.foldl_substring2(Closure, String, Start, Count, !Acc1, !Acc2)
         % A variant of string.foldl_substring with two accumulators.
         %
     :- pred string.foldl2_substring(pred(char, A, A, B, B),
         string, int, int, A, A, B, B).
     :- mode string.foldl2_substring(pred(in, di, uo, di, uo) is det,
         in, in, in, di, uo, di, uo) is det.
     :- mode string.foldl2_substring(pred(in, in, out, di, uo) is det,
         in, in, in, in, out, di, uo) is det.
     :- mode string.foldl2_substring(pred(in, in, out, in, out) is det,
         in, in, in, in, out, in, out) is det.
     :- mode string.foldl2_substring(pred(in, in, out, in, out) is semidet,
         in, in, in, in, out, in, out) is semidet.
     :- mode string.foldl2_substring(pred(in, in, out, in, out) is nondet,
         in, in, in, in, out, in, out) is nondet.
     :- mode string.foldl2_substring(pred(in, in, out, in, out) is multi,
         in, in, in, in, out, in, out) is multi.

         % string.foldr(Closure, String, !Acc):
         % As string.foldl/4, except that processing proceeds right-to-left.
         %
     :- func string.foldr(func(char, T) = T, string, T) = T.
     :- pred string.foldr(pred(char, T, T), string, T, T).
     :- mode string.foldr(pred(in, in, out) is det, in, in, out) is det.
     :- mode string.foldr(pred(in, di, uo) is det, in, di, uo) is det.
     :- mode string.foldr(pred(in, in, out) is semidet, in, in, out) is semidet.
     :- mode string.foldr(pred(in, in, out) is nondet, in, in, out) is nondet.
     :- mode string.foldr(pred(in, in, out) is multi, in, in, out) is multi.

         % string.foldr_substring(Closure, String, Start, Count, !Acc)
         % is equivalent to string.foldr(Closure, SubString, !Acc)
         % where SubString = string.substring(String, Start, Count).
         %
     :- func string.foldr_substring(func(char, T) = T, string, int, int, T) = T.
     :- pred string.foldr_substring(pred(char, T, T), string, int, int, T, T).
     :- mode string.foldr_substring(pred(in, in, out) is det, in, in, in,
         in, out) is det.
     :- mode string.foldr_substring(pred(in, di, uo) is det, in, in, in,
         di, uo) is det.
     :- mode string.foldr_substring(pred(in, in, out) is semidet, in, in, in,
         in, out) is semidet.
     :- mode string.foldr_substring(pred(in, in, out) is nondet, in, in, in,
         in, out) is nondet.
     :- mode string.foldr_substring(pred(in, in, out) is multi, in, in, in,
         in, out) is multi.

         % string.words_separator(SepP, String) returns the list of non-empty
         % substrings of String (in first to last order) that are delimited
         % by non-empty sequences of chars matched by SepP. For example,
         %
         % string.words_separator(char.is_whitespace, " the cat  sat on the  mat") =
         %   ["the", "cat", "sat", "on", "the", "mat"]
         %
         % Note the difference to string.split_at_separator.
         %
     :- func string.words_separator(pred(char), string) = list(string).
     :- mode string.words_separator(pred(in) is semidet, in) = out is det.

         % string.words(String) =
         %   string.words_separator(char.is_whitespace, String).
         %
     :- func string.words(string) = list(string).

         % string.split_at_separator(SepP, String) returns the list of
         % substrings of String (in first to last order) that are delimited
         % by chars matched by SepP. For example,
         %
         % string.split_at_separator(char.is_whitespace, " a cat  sat on the  mat")
         %   = ["", "a", "cat", "", "sat", "on", "the", "", "mat"]
         %
         % Note the difference to string.words_separator.
         %
     :- func string.split_at_separator(pred(char), string) = list(string).
     :- mode string.split_at_separator(pred(in) is semidet, in) = out is det.

         % string.split_at_char(Char, String) =
         %     string.split_at_separator(unify(Char), String)
         %
     :- func string.split_at_char(char, string) = list(string).

         % string.split_at_string(Separator, String) returns the list of substrings
         % of String that are delimited by Separator. For example,
         %
         % string.split_at_string("|||", "|||fld2|||fld3") = ["", "fld2", [fld3"]
         %
         % Always the first match of Separator is used to break the String, for
         % example: string.split_at_string("aa", "xaaayaaaz") = ["x", "ay", "az"]
         %
     :- func string.split_at_string(string, string) = list(string).

         % string.split(String, Count, LeftSubstring, RightSubstring):
         % `LeftSubstring' is the left-most `Count' characters of `String',
         % and `RightSubstring' is the remainder of `String'.
         % (If `Count' is out of the range [0, length of `String'], it is treated
         % as if it were the nearest end-point of that range.)
         %
     :- pred string.split(string::in, int::in, string::uo, string::uo) is det.

         % string.left(String, Count, LeftSubstring):
         % `LeftSubstring' is the left-most `Count' characters of `String'.
         % (If `Count' is out of the range [0, length of `String'], it is treated
         % as if it were the nearest end-point of that range.)
         %
     :- func string.left(string::in, int::in) = (string::uo) is det.
     :- pred string.left(string::in, int::in, string::uo) is det.

         % string.right(String, Count, RightSubstring):
         % `RightSubstring' is the right-most `Count' characters of `String'.
         % (If `Count' is out of the range [0, length of `String'], it is treated
         % as if it were the nearest end-point of that range.)
         %
     :- func string.right(string::in, int::in) = (string::uo) is det.
     :- pred string.right(string::in, int::in, string::uo) is det.

         % string.substring(String, Start, Count, Substring):
         % `Substring' is first the `Count' characters in what would remain
         % of `String' after the first `Start' characters were removed.
         % (If `Start' is out of the range [0, length of `String'], it is treated
         % as if it were the nearest end-point of that range.
         % If `Count' is out of the range [0, length of `String' - `Start'],
         % it is treated as if it were the nearest end-point of that range.)
         %
     :- func string.substring(string::in, int::in, int::in) = (string::uo) is det.
     :- pred string.substring(string::in, int::in, int::in, string::uo) is det.

         % string.unsafe_substring(String, Start, Count, Substring):
         % `Substring' is first the `Count' characters in what would remain
         % of `String' after the first `Start' characters were removed.
         % WARNING: if `Start' is out of the range [0, length of `String'],
         % or if `Count' is out of the range [0, length of `String' - `Start'],
         % then the behaviour is UNDEFINED. Use with care!
         % This version takes time proportional to the length of the substring,
         % whereas string.substring may take time proportional to the length
         %% of the whole string.
         %
     :- func string.unsafe_substring(string::in, int::in, int::in) = (string::uo)
         is det.
     :- pred string.unsafe_substring(string::in, int::in, int::in, string::uo)
         is det.

         % Append a list of strings together.
         %
     :- func string.append_list(list(string)::in) = (string::uo) is det.
     :- pred string.append_list(list(string)::in, string::uo) is det.

         % string.join_list(Separator, Strings) = JoinedString:
         % Appends together the strings in Strings, putting Separator between
         % adjacent strings. If Strings is the empty list, returns the empty string.
         %
     :- func string.join_list(string::in, list(string)::in) = (string::uo) is det.

         % Compute a hash value for a string.
         %
     :- func string.hash(string) = int.
     :- pred string.hash(string::in, int::out) is det.

         % string.sub_string_search(String, SubString, Index).
         % `Index' is the position in `String' where the first occurrence of
         % `SubString' begins. Indices start at zero, so if `SubString' is a prefix
         % of `String', this will return Index = 0.
         %
     :- pred string.sub_string_search(string::in, string::in, int::out) is semidet.

         % string.sub_string_search_start(String, SubString, BeginAt, Index).
         % `Index' is the position in `String' where the first occurrence of
         % `SubString' occurs such that 'Index' is greater than or equal to
         % `BeginAt'.  Indices start at zero,
         %
     :- pred string.sub_string_search_start(string::in, string::in, int::in,
         int::out)
         is semidet.

         % A function similar to sprintf() in C.
         %
         % For example,
         %   string.format("%s %i %c %f\n",
         %       [s("Square-root of"), i(2), c('='), f(1.41)], String)
         % will return
         %   String = "Square-root of 2 = 1.41\n".
         %
         % The following options available in C are supported: flags [0+-# ],
         % a field width (or *), and a precision (could be a ".*").
         %
         % Valid conversion character types are {dioxXucsfeEgGp%}. %n is not
         % supported. string.format will not return the length of the string.
         %
         % conv  var     output form.        effect of '#'.
         % char. type.
         %
         % d     int     signed integer
         % i     int     signed integer
         % o     int     signed octal        with '0' prefix
         % x,X   int     signed hex          with '0x', '0X' prefix
         % u     int     unsigned integer
         % c     char    character
         % s     string  string
         % f     float   rational number     with '.', if precision 0
         % e,E   float   [-]m.dddddE+-xx     with '.', if precision 0
         % g,G   float   either e or f       with trailing zeros.
         % p     int     integer
         %
         % An option of zero will cause any padding to be zeros rather than spaces.
         % A '-' will cause the output to be left-justified in its % 'space'.
         % (With a `-', the default is for fields to be right-justified.)
         % A '+' forces a sign to be printed. This is not sensible for string
         % and character output. A ' ' causes a space to be printed before a thing
         % if there is no sign there. The other option is the '#', which modifies
         % the output string's format. These options are normally put directly
         % after the '%'.
         %
         % Notes:
         %
         % %#.0e, %#.0E now prints a '.' before the 'e'.
         %
         % Asking for more precision than a float actually has will result in
         % potentially misleading output.
         %
         % Numbers are now rounded by precision value, not truncated as previously.
         %
         % The implementation uses the sprintf() function, so the actual output
         % will depend on the C standard library.
         %
     :- func string.format(string, list(string.poly_type)) = string.
     :- pred string.format(string::in, list(string.poly_type)::in, string::out)
         is det.

     :- type string.poly_type
         --->    f(float)
         ;       i(int)
         ;       s(string)
         ;       c(char).

         % format_table(Columns, Separator) = Table
         % format_table/2 takes a list of columns and a column separator and returns
         % a formatted table, where each field in each column has been aligned
         % and fields are separated with Separator. A newline character is inserted
         % between each row. If the columns are not all the same length then
         % an exception is thrown.
         %
         % For example:
         %
         % format_table([right(["a", "bb", "ccc"]), left(["1", "22", "333"])],
         %   " * ")
         % would return the table:
         %   a * 1
         %  bb * 22
         % ccc * 333
         %
     :- func string.format_table(list(justified_column), string) = string.

         % format_table_max(Columns, Separator) does the same job as format_table,
         % but allows the caller to associate an maximum width with each column.
         %
     :- func string.format_table_max(assoc_list(justified_column, maybe(int)),
         string) = string.

     :- type justified_column
         --->    left(list(string))
         ;       right(list(string)).

         % word_wrap(Str, N) = Wrapped.
         % Wrapped is Str with newlines inserted between words so that at most
         % N characters appear on a line and each line contains as many whole words
         % as possible. If any one word exceeds N characters in length then it will
         % be broken over two (or more) lines. Sequences of whitespace characters
         % are replaced by a single space.
         %
     :- func string.word_wrap(string, int) = string.

         % word_wrap_separator(Str, N, WordSeparator) = Wrapped.
         % word_wrap_separator/3 is like word_wrap/2, except that words that
         % need to be broken up over multiple lines have WordSeparator inserted
         % between each piece. If the length of WordSeparator is greater than
         % or equal to N, then no separator is used.
         %
     :- func string.word_wrap_separator(string, int, string) = string.

         % Convert a string to a pretty_printer.doc for formatting.
         %
     :- func string.string_to_doc(string) = pretty_printer.doc.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: svarray,  Next: svbag,  Prev: string,  Up: Top

74 svarray
**********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2004-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: svarray.m
     %
     % This file provides an interface to the 'array' ADT that is conducive to the
     % use of state variable notation. The predicates here do the same thing as
     % their counterparts in the array module; the only difference is the order
     % of the arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module svarray.
     :- interface.

     :- import_module array.

     %--------------------------------------------------%

         % svarray.set sets the nth element of an array, and returns the
         % resulting array (good opportunity for destructive update ;-).
         % Throws an exception if the index is out of bounds.
         %
     :- pred svarray.set(int::in, T::in, array(T)::array_di, array(T)::array_uo)
         is det.

         % svarray.semidet_set sets the nth element of an array,
         % and returns the resulting array.
         % It fails if the index is out of bounds.
         %
     :- pred svarray.semidet_set(int::in, T::in,
         array(T)::array_di, array(T)::array_uo) is semidet.

         % svarray.slow_set sets the nth element of an array,
         % and returns the resulting array.  The initial array is not
         % required to be unique, so the implementation may not be able to use
         % destructive update.
         % It is an error if the index is out of bounds.
         %
     :- pred svarray.slow_set(int, T, array(T), array(T)).
     %:- mode svarray.slow_set(in, in, array_ui, array_uo) is det.
     :- mode svarray.slow_set(in, in, in, array_uo) is det.

         % svarray.semidet_slow_set sets the nth element of an array,
         % and returns the resulting array.  The initial array is not
         % required to be unique, so the implementation may not be able to use
         % destructive update.
         % It fails if the index is out of bounds.
         %
     :- pred svarray.semidet_slow_set(int, T, array(T), array(T)).
     %:- mode svarray.semidet_slow_set(in, in, array_ui, array_uo) is semidet.
     :- mode svarray.semidet_slow_set(in, in, in, array_uo) is semidet.

         % svarray.resize(Size, Init, Array0, Array):
         % The array is expanded or shrunk to make it fit
         % the new size `Size'.  Any new entries are filled
         % with `Init'.
         %
     :- pred svarray.resize(int::in, T::in, array(T)::array_di, array(T)::array_uo)
         is det.

         % svarray.shrink(Size, Array0, Array):
         % The array is shrunk to make it fit the new size `Size'.
         % Throws an exception if `Size' is larger than the size of `Array0'.
         %
     :- pred svarray.shrink(int::in, array(T)::array_di, array(T)::array_uo)
         is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: svbag,  Next: svbimap,  Prev: svarray,  Up: Top

75 svbag
********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2004-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: svbag.m
     %
     % This file provides an interface to the 'bag' ADT that is conducive to the
     % use of state variable notation. The predicates here do the same thing as
     % their counterparts in the bag module; the only difference is the order of the
     % arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module svbag.
     :- interface.

     :- import_module bag.
     :- import_module list.
     :- import_module set.

     %--------------------------------------------------%

         % Insert a particular value in a bag.
         %
     :- pred svbag.insert(T::in, bag(T)::in, bag(T)::out) is det.

         % Insert a list of values into a bag.
         %
     :- pred svbag.insert_list(list(T)::in, bag(T)::in, bag(T)::out) is det.

         % Insert a set of values into a bag.
         %
     :- pred svbag.insert_set(set(T)::in, bag(T)::in, bag(T)::out) is det.

         % Remove one occurrence of a particular value from a bag.
         % Fail if the item does not exist in the bag.
         %
     :- pred svbag.remove(T::in, bag(T)::in, bag(T)::out) is semidet.

         % Remove one occurrence of a particular value from a bag.
         % Abort if the item does not exist in the bag.
         %
     :- pred svbag.det_remove(T::in, bag(T)::in, bag(T)::out) is det.

         % Remove a list of values from a bag.  Duplicates are removed
         % from the bag the appropriate number of times.  Fail if any
         % of the items in the list do not exist in the bag.
         %
         % This call is logically equivalent to:
         %
         %   svbag.remove_list(RemoveList, Bag0, Bag) :-
         %       bag.from_list(RemoveList, RemoveBag),
         %       bag.is_subbag(RemoveBag, Bag0),
         %       svbag.subtract(RemoveBag, Bag0, Bag).
         %
     :- pred svbag.remove_list(list(T)::in, bag(T)::in, bag(T)::out) is semidet.

         % Remove a list of values from a bag.  Duplicates are removed
         % from the bag the appropriate number of times.  Abort if any
         % of the items in the list do not exist in the bag.
         %
     :- pred svbag.det_remove_list(list(T)::in, bag(T)::in, bag(T)::out) is det.

         % Remove a set of values from a bag. Each value is removed once.
         % Fail if any of the items in the set do not exist in the bag.
         %
     :- pred svbag.remove_set(set(T)::in, bag(T)::in, bag(T)::out) is semidet.

         % Remove a set of values from a bag. Each value is removed once.
         % Abort if any of the items in the set do not exist in the bag.
         %
     :- pred svbag.det_remove_set(set(T)::in, bag(T)::in, bag(T)::out) is det.

         % Delete one occurrence of a particular value from a bag.
         % If the key is not present, leave the bag unchanged.
         %
     :- pred svbag.delete(T::in, bag(T)::in, bag(T)::out) is det.

         % Remove all occurrences of a particular value from a bag.
         % Fail if the item does not exist in the bag.
         %
     :- pred svbag.remove_all(T::in, bag(T)::in, bag(T)::out) is semidet.

         % Delete all occurrences of a particular value from a bag.
         %
     :- pred svbag.delete_all(T::in, bag(T)::in, bag(T)::out) is det.

         % svbag.subtract(Bag0, SubBag, Bag):
         %
         % Subtracts SubBag from Bag0 to produce Bag.
         % Each element in SubBag is removed from Bag0 to produce Bag.
         % If an element exists in SubBag, but not in Bag, then that
         % element is not removed.
         % e.g. svbag.subtract({1, 1, 2, 2, 3 }, {1, 1, 2, 3, 3, 3}, {2}).
         %
     :- pred svbag.subtract(bag(T)::in, bag(T)::in, bag(T)::out) is det.

         % Fails if the bag is empty.
         %
     :- pred svbag.remove_smallest(T::out, bag(T)::in, bag(T)::out) is semidet.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: svbimap,  Next: sveqvclass,  Prev: svbag,  Up: Top

76 svbimap
**********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2004-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: svbimap.m.
     %
     % This file provides an interface to the 'bimap' ADT that is conducive to the
     % use of state variable notation. The predicates here do the same thing as
     % their counterparts in the bimap module; the only difference is the order
     % of the arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module svbimap.
     :- interface.

     :- import_module bimap.

     %--------------------------------------------------%

     :- pred svbimap.insert(K::in, V::in, bimap(K, V)::in, bimap(K, V)::out)
         is semidet.

     :- pred svbimap.det_insert(K::in, V::in, bimap(K, V)::in, bimap(K, V)::out)
         is det.

     :- pred svbimap.set(K::in, V::in, bimap(K, V)::in, bimap(K, V)::out) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: sveqvclass,  Next: svmap,  Prev: svbimap,  Up: Top

77 sveqvclass
*************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2005-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: sveqvclass.m.
     % Author: zs.
     % Stability: high.
     %
     % This file provides an interface to the 'eqvclass' ADT that is conducive
     % to the use of state variable notation. The predicates here do the same thing
     % as their counterparts in the eqvclass module; the only difference is the
     % order of the arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module sveqvclass.
     :- interface.

     :- import_module eqvclass.

     %--------------------------------------------------%

         % Make an element known to the equivalence class.
         % The element may already be known to the class;
         % if it isn't, it is created without any equivalence relationships.
         %
     :- pred sveqvclass.ensure_element(T::in, eqvclass(T)::in, eqvclass(T)::out)
         is det.

         % Make an element known to the equivalence class.
         % The element must not already be known to the class;
         % it is created without any equivalence relationships.
         %
     :- pred sveqvclass.new_element(T::in, eqvclass(T)::in, eqvclass(T)::out)
         is det.

         % Make two elements of the equivalence class equivalent.
         % It is ok if they already are.
         %
     :- pred sveqvclass.ensure_equivalence(T::in, T::in,
         eqvclass(T)::in, eqvclass(T)::out) is det.

         % Make two elements of the equivalence class equivalent.
         % It is an error if they are already equivalent.
         %
     :- pred sveqvclass.new_equivalence(T::in, T::in,
         eqvclass(T)::in, eqvclass(T)::out) is det.

         % Remove the given element and all other elements equivalent to it
         % from the given equivalence class.
         %
     :- pred sveqvclass.remove_equivalent_elements(T::in,
         eqvclass(T)::in, eqvclass(T)::out) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: svmap,  Next: svmulti_map,  Prev: sveqvclass,  Up: Top

78 svmap
********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2004-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: svmap.m.
     % Author: zs.
     % Stability: high.
     %
     % This file provides an interface to the 'map' ADT that is conducive to the
     % use of state variable notation. The predicates here do the same thing as
     % their counterparts in the map module; the only difference is the order of the
     % arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module svmap.
     :- interface.

     :- import_module assoc_list.
     :- import_module list.
     :- import_module map.

     %--------------------------------------------------%

         % Insert a new key and corresponding value into a map.
         % Fail if the key already exists.
         %
     :- pred svmap.insert(K::in, V::in, map(K, V)::in, map(K, V)::out) is semidet.

         % Insert a new key and corresponding value into a map.
         % Abort if the key already exists.
         %
     :- pred svmap.det_insert(K::in, V::in, map(K, V)::in, map(K, V)::out) is det.

         % Apply map.det_insert to key - value pairs from corresponding lists.
         %
     :- pred svmap.det_insert_from_corresponding_lists(list(K)::in, list(V)::in,
         map(K, V)::in, map(K, V)::out) is det.

         % Apply map.det_insert to key - value pairs from the assoc_lists.
         %
     :- pred svmap.det_insert_from_assoc_list(assoc_list(K, V)::in,
         map(K, V)::in, map(K, V)::out) is det.

         % Apply map.set to key - value pairs from corresponding lists.
         %
     :- pred svmap.set_from_corresponding_lists(list(K)::in, list(V)::in,
         map(K, V)::in, map(K, V)::out) is det.

     :- pred svmap.set_from_assoc_list(assoc_list(K, V)::in,
         map(K, V)::in, map(K, V)::out) is det.

         % Update the value corresponding to a given key
         % Fail if the key doesn't already exist.
         %
     :- pred svmap.update(K::in, V::in, map(K, V)::in, map(K, V)::out) is semidet.

         % Update the value corresponding to a given key
         % Abort if the key doesn't already exist.
         %
     :- pred svmap.det_update(K::in, V::in, map(K, V)::in, map(K, V)::out) is det.

         % Update value if the key is already present, otherwise
         % insert new key and value.
         %
     :- pred svmap.set(K::in, V::in, map(K, V)::in, map(K, V)::out) is det.

         % Delete a key-value pair from a map.
         % If the key is not present, leave the map unchanged.
         %
     :- pred svmap.delete(K::in, map(K, V)::in, map(K, V)::out) is det.

         % Apply map.delete/3 to a list of keys.
         %
     :- pred svmap.delete_list(list(K)::in, map(K, V)::in, map(K, V)::out) is det.

         % Delete a key-value pair from a map and return the value.
         % Fail if the key is not present.
         %
     :- pred svmap.remove(K::in, V::out, map(K, V)::in, map(K, V)::out) is semidet.

         % Delete a key-value pair from a map and return the value.
         % Abort if the key is not present.
         %
     :- pred svmap.det_remove(K::in, V::out, map(K, V)::in, map(K, V)::out) is det.

         % Remove the smallest item from the map, fail if
         % the map is empty.
         %
     :- pred svmap.remove_smallest(K::out, V::out, map(K, V)::in, map(K, V)::out)
         is semidet.

     %--------------------------------------------------%

     % Everything below here is not intended to be part of the public interface,
     % and will not be included in the Mercury library reference manual.

     :- interface.

     :- import_module term. % for var/1.

     :- pragma type_spec(svmap.insert(in, in, in, out), K = var(_)).
     :- pragma type_spec(svmap.insert(in, in, in, out), K = int).

     :- pragma type_spec(svmap.det_insert(in, in, in, out), K = var(_)).
     :- pragma type_spec(svmap.det_insert(in, in, in, out), K = int).

     :- pragma type_spec(svmap.set(in, in, in, out), K = var(_)).
     :- pragma type_spec(svmap.set(in, in, in, out), K = var(_)).

     :- pragma type_spec(svmap.update(in, in, in, out), K = var(_)).
     :- pragma type_spec(svmap.update(in, in, in, out), K = int).

     :- pragma type_spec(svmap.det_update(in, in, in, out), K = var(_)).
     :- pragma type_spec(svmap.det_update(in, in, in, out), K = int).


File: mercury_library.info,  Node: svmulti_map,  Next: svqueue,  Prev: svmap,  Up: Top

79 svmulti_map
**************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2005-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: svmulti_map.m.
     % Author: dylan.
     % Stability: low.
     %
     % This file provides an interface to the 'multi_map' ADT that is conducive to
     % the use of state variable notation. The predicates here do the same thing as
     % their counterparts in the multi_map module; the only difference is the order
     % of the arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module svmulti_map.
     :- interface.

     :- import_module list.
     :- import_module multi_map.

     %--------------------------------------------------%

         % Insert a new key and corresponding value into a multi_map.
         % Fail if the key already exists.
         %
     :- pred svmulti_map.insert(K::in, V::in,
         multi_map(K, V)::in, multi_map(K, V)::out) is semidet.

         % Insert a new key and corresponding value into a multi_map.
         % Abort if the key already exists.
         %
     :- pred svmulti_map.det_insert(K::in, V::in,
         multi_map(K, V)::in, multi_map(K, V)::out) is det.

         % Update (add) the value corresponding to a given key.
         % Fail if the key does not already exist.
         %
     :- pred svmulti_map.update(K::in, V::in,
         multi_map(K, V)::in, multi_map(K, V)::out) is semidet.

         % Update (add) the value corresponding to a given key.
         % Abort if the key doesn't already exist.
         %
     :- pred svmulti_map.det_update(K::in, V::in,
         multi_map(K, V)::in, multi_map(K, V)::out) is det.

         % Update (replace) the value corresponding to a given key.
         % Abort if the key does not already exist.
         %
     :- pred svmulti_map.det_replace(K::in, list(V)::in,
         multi_map(K, V)::in, multi_map(K, V)::out) is det.

         % Update (add) value if the key is already present, otherwise
         % insert the new key and value.
         %
     :- pred svmulti_map.set(K::in, V::in,
         multi_map(K, V)::in, multi_map(K, V)::out) is det.

     :- pred svmulti_map.add(K::in, V::in,
         multi_map(K, V)::in, multi_map(K, V)::out) is det.

         % Delete a key and data from a multi_map
         % If the key is not present, leave the multi_map unchanged.
         %
     :- pred svmulti_map.delete(K::in, multi_map(K, V)::in, multi_map(K, V)::out)
         is det.

         % Delete a data value from a key in a multi_map
         % If the key is not present, leave the multi_map unchanged.
         %
     :- pred svmulti_map.delete(K::in, V::in,
         multi_map(K, V)::in, multi_map(K, V)::out) is det.

         % Delete a key-value pair from a multi_map and return the value.
         % Fail if the key is not present.
         %
     :- pred svmulti_map.remove(K::in, list(V)::out,
         multi_map(K, V)::in, multi_map(K, V)::out) is semidet.

         % Delete a key-value pair from a multi_map and return the value.
         % Abort if the key is not present.
         %
     :- pred svmulti_map.det_remove(K::in, list(V)::out,
         multi_map(K, V)::in, multi_map(K, V)::out) is det.

         % Remove the smallest item from the multi_map, fail if
         % the multi_map is empty.
         %
     :- pred svmulti_map.remove_smallest(K::out, list(V)::out,
         multi_map(K, V)::in, multi_map(K, V)::out) is semidet.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: svqueue,  Next: svrelation,  Prev: svmulti_map,  Up: Top

80 svqueue
**********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2004-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: svqueue.m.
     % Author: zs.
     % Stability: high.
     %
     % This file provides an interface to the 'queue' ADT that is conducive to the
     % use of state variable notation. The predicates here do the same thing as
     % their counterparts in the queue module; the only difference is the order
     % of the arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module svqueue.
     :- interface.

     :- import_module list.
     :- import_module queue.

     %--------------------------------------------------%

         % `svqueue.put(Elem, Queue0, Queue)' is true iff `Queue' is
         % the queue which results from appending `Elem' onto the end
         % of `Queue0'.
         %
     :- pred svqueue.put(T::in, queue(T)::in, queue(T)::out) is det.

         % `svqueue.put_list(Elems, Queue0, Queue)' is true iff `Queue'
         % is the queue which results from inserting the items in the
         % list `Elems' into `Queue0'.
         %
     :- pred svqueue.put_list(list(T)::in, queue(T)::in, queue(T)::out) is det.

         % `svqueue.get(Elem, Queue0, Queue)' is true iff `Queue0' is
         % a non-empty queue whose first element is `Elem', and `Queue'
         % the queue which results from removing that element from
         % the front of `Queue0'.
         %
     :- pred svqueue.get(T::out, queue(T)::in, queue(T)::out) is semidet.

         % `svqueue.delete_all(Elem, Queue0, Queue)' is true iff `Queue' is
         % the same queue as `Queue0' with all occurences of `Elem' removed
         % from it.
         %
     :- pred svqueue.delete_all(T::in, queue(T)::in, queue(T)::out) is det.

         % `svqueue.put_on_front(Elem, Queue0, Queue)' pushes `Elem' on to
         % the front of `Queue0', giving `Queue'.
         %
     :- pred svqueue.put_on_front(T::in, queue(T)::in, queue(T)::out) is det.

         % `svqueue.put_list_on_front(Queue0, Elems, Queue)' pushes `Elems'
         % on to the front of `Queue0', giving `Queue' (the Nth member
         % of `Elems' becomes the Nth member from the front of `Queue').
         %
     :- pred svqueue.put_list_on_front(list(T)::in, queue(T)::in, queue(T)::out)
         is det.

         % `queue.get_from_back(Elem, Queue0, Queue)' removes `Elem' from
         % the back of `Queue0', giving `Queue'.
         %
     :- pred svqueue.get_from_back(T::out, queue(T)::in, queue(T)::out) is semidet.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: svrelation,  Next: svset,  Prev: svqueue,  Up: Top

81 svrelation
*************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2005-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: set.m.
     % Authors: zs.
     % Stability: high.
     %
     % This file provides an interface to the 'relation' ADT that is conducive to
     % the use of state variable notation. The predicates here do the same thing as
     % their counterparts in the relation module; the only difference is the order
     % of the arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module svrelation.
     :- interface.

     :- import_module assoc_list.
     :- import_module relation.

         % svrelation.add_element adds an element to the domain of a
         % relation.  Return the old relation_key if one already exists.
         %
     :- pred svrelation.add_element(T::in, relation_key::out,
         relation(T)::in, relation(T)::out) is det.

         % svrelation.add adds an element to the relation.
         %
     :- pred svrelation.add(relation_key::in, relation_key::in,
         relation(T)::in, relation(T)::out) is det.

         % svrelation.add_values adds an pair of values to the relation's
         % domain and adds an element to the relation.
         %
         % svrelation.add_values(X, Y, !R) :-
         %    svrelation.add_element(X, XKey, !R),
         %    svrelation.add_element(Y, YKey, !R),
         %    svrelation.add(XKey, YKey, !R).
         %
     :- pred svrelation.add_values(T::in, T::in, relation(T)::in, relation(T)::out)
         is det.

         % svrelation.add_assoc_list adds a list of elements to a
         % relation.
         %
     :- pred svrelation.add_assoc_list(assoc_list(relation_key, relation_key)::in,
         relation(T)::in, relation(T)::out) is det.

         % svrelation.remove removes an element from the relation.
         %
     :- pred svrelation.remove(relation_key::in, relation_key::in,
         relation(T)::in, relation(T)::out) is det.

         % svrelation.remove_assoc_list removes a list of elements
         % from a relation.
         %
     :- pred svrelation.remove_assoc_list(
         assoc_list(relation_key, relation_key)::in,
         relation(T)::in, relation(T)::out) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: svset,  Next: svvarset,  Prev: svrelation,  Up: Top

82 svset
********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2004-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: set.m.
     % Authors: zs.
     % Stability: high.
     %
     % This file provides an interface to the 'set' ADT that is conducive to the
     % use of state variable notation. The predicates here do the same thing as
     % their counterparts in the set module; the only difference is the order of
     % the arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module svset.
     :- interface.

     :- import_module list.
     :- import_module set.

         % `svset.insert(X, Set0, Set)' is true iff `Set' is the union of
         % `Set0' and the set containing only `X'.
         %
     :- pred svset.insert(T::in, set(T)::in, set(T)::out) is det.

         % `svset.insert_list(Xs, Set0, Set)' is true iff `Set' is the union of
         % `Set0' and the set containing only the members of `Xs'.
         %
     :- pred svset.insert_list(list(T)::in, set(T)::in, set(T)::out) is det.

         % `svset.delete(X, Set0, Set)' is true iff `Set' is the relative
         % complement of `Set0' and the set containing only `X', i.e.
         % if `Set' is the set which contains all the elements of `Set0'
         % except `X'.
         %
     :- pred svset.delete(T::in, set(T)::in, set(T)::out) is det.

         % `svset.delete_list(Xs, Set0, Set)' is true iff `Set' is the relative
         % complement of `Set0' and the set containing only the members of
         % `Xs'.
         %
     :- pred svset.delete_list(list(T)::in, set(T)::in, set(T)::out) is det.

         % `svset.remove(X, Set0, Set)' is true iff `Set0' contains `X',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only `X', i.e.  if `Set' is the set which contains
         % all the elements of `Set0' except `X'.
         %
     :- pred svset.remove(T::in, set(T)::in, set(T)::out) is semidet.

         % `svset.remove_list(Xs, Set0, Set)' is true iff `Xs' does not
         % contain any duplicates, `Set0' contains every member of `Xs',
         % and `Set' is the relative complement of `Set0' and the set
         % containing only the members of `Xs'.
         %
     :- pred svset.remove_list(list(T)::in, set(T)::in, set(T)::out) is semidet.

         % `svset.remove_least(Elem, Set0, Set)' is true iff
         % `Set0' is not empty, `Elem' is the smallest element in `Set0'
         % (with elements ordered using the standard ordering given
         % by compare/3), and `Set' is the set containing all the
         % elements of `Set0' except `Elem'.
         %
     :- pred svset.remove_least(T::out, set(T)::in, set(T)::out) is semidet.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: svvarset,  Next: term_io,  Prev: svset,  Up: Top

83 svvarset
***********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2005-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: svvarset.m.
     % Author: fjh.
     % Stability: low.
     %
     % This file provides an interface to the 'varset' ADT that is conducive to the
     % user of state variable notation.  The predicates here do the same thing as
     % their counterparts in the varset module; the only difference is the order of
     % the arguments.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module svvarset.
     :- interface.

     :- import_module list.
     :- import_module maybe.
     :- import_module set.
     :- import_module term.
     :- import_module varset.

     %--------------------------------------------------%

         % Create a new variable.
         %
     :- pred svvarset.new_var(var(T)::out, varset(T)::in, varset(T)::out) is det.

         % Create a new named variable.
         %
     :- pred svvarset.new_named_var(string::in, var(T)::out,
         varset(T)::in, varset(T)::out) is det.

         % Create a new variable, and maybe give it a name.
         %
     :- pred svvarset.new_maybe_named_var(maybe(string)::in, var(T)::out,
         varset(T)::in, varset(T)::out) is det.

         % Create a new named variable with a unique (w.r.t. the
         % varset) number appended to the name.
         %
     :- pred svvarset.new_uniquely_named_var(string::in, var(T)::out,
         varset(T)::in, varset(T)::out) is det.

         % Create multiple new variables.
         %
     :- pred svvarset.new_vars(int::in, list(var(T))::out, varset(T)::in,
         varset(T)::out) is det.

         % Delete the name and value for a variable.
         %
     :- pred svvarset.delete_var(var(T)::in, varset(T)::in, varset(T)::out) is det.

         % Delete the names and values for a list of variables.
         %
     :- pred svvarset.delete_vars(list(var(T))::in, varset(T)::in, varset(T)::out)
         is det.

         % Set the name of a variable.
         %
     :- pred svvarset.name_var(var(T)::in, string::in, varset(T)::in,
         varset(T)::out) is det.

         % Bind a value to a variable.
         % This will overwrite any existing binding.
         %
     :- pred svvarset.bind_var(var(T)::in, term(T)::in, varset(T)::in,
         varset(T)::out) is det.

         % Bind a set of terms to a set of variables.
         %
     :- pred svvarset.bind_vars(substitution(T)::in, varset(T)::in, varset(T)::out)
         is det.

         % Given a varset and a set of variables, remove the names
         % and values of any other variables stored in the varset.
         %
     :- pred svvarset.select(set(var(T))::in, varset(T)::in, varset(T)::out) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: term_io,  Next: term,  Prev: svvarset,  Up: Top

84 term_io
**********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1994-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: term_io.m.
     % Main author: fjh.
     % Stability: medium to high.
     %
     % This file encapsulates all the term I/O.
     % This exports predicates to read and write terms in the
     % nice ground representation provided in term.m.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module term_io.
     :- interface.

     :- import_module char.
     :- import_module io.
     :- import_module ops.
     :- import_module stream.
     :- import_module term.
     :- import_module varset.

     %--------------------------------------------------%

     % External interface: exported predicates

     % The following are not yet implemented.
     %
     % :- type op_type ---> fx; fy; xf; yf; xfx; xfy; yfx; fxx; fxy; fyx; fyy.
     %
     %   % term_io.op(Prec, Type, OpName, !IO):
     %   % Define an operator as per Prolog op/3 for future calls
     %   % to term_io.read_term.
     % :- pred term_io.op(int::in, op_type::in, string::in, io::di, io::uo) is det.
     %
     % :- type op_details ---> op(int, op_type, string).
     %
     %   % Return a list containing all the current operator definitions.
     %   % Does not modify the io.state.
     % :- pred term_io.current_ops(list(op_details)::out, io::di, io::uo) is det.

     :- type read_term(T)
         --->    eof
         ;       error(string, int)
         ;       term(varset(T), term(T)).

     :- type read_term   == read_term(generic).

         % term_io.read_term(Result, !IO):
         %
         % Read a term from standard input. Similar to NU-Prolog read_term/2,
         % except that resulting term is in the ground representation.
         % Binds Result to either `eof', `term(VarSet, Term)', or
         % `error(Message, LineNumber)'.
         %
     :- pred term_io.read_term(read_term(T)::out, io::di, io::uo) is det.

         % As above, except uses the given operator table instead of
         % the standard Mercury operators.
         %
     :- pred term_io.read_term_with_op_table(Ops::in, read_term(T)::out,
         io::di, io::uo) is det <= op_table(Ops).

         % Writes a term to standard output. Uses the variable names specified
         % by the varset. Writes _N for all unnamed variables, with N starting at 0.
         %
     :- pred term_io.write_term(varset(T)::in, term(T)::in, io::di, io::uo) is det.

         % As above, except uses the given operator table instead of the
         % standard Mercury operators.
         %
     :- pred term_io.write_term_with_op_table(Ops::in, varset(T)::in, term(T)::in,
         io::di, io::uo) is det <= op_table(Ops).

         % As above, except it appends a period and new-line.
         %
     :- pred term_io.write_term_nl(varset(T)::in, term(T)::in, io::di, io::uo)
         is det.

         % As above, except it appends a period and new-line.
         %
     :- pred term_io.write_term_nl_with_op_table(Ops::in, varset(T)::in,
         term(T)::in, io::di, io::uo) is det <= op_table(Ops).

         % Writes a constant (integer, float, string, or atom) to stdout.
         %
     :- pred term_io.write_constant(const::in, io::di, io::uo) is det.

         % Like term_io.write_constant, but return the result in a string.
         %
     :- func term_io.format_constant(const) = string.

         % Writes a variable to stdout.
         %
     :- pred term_io.write_variable(var(T)::in, varset(T)::in, io::di, io::uo)
         is det.

         % As above, except uses the given operator table instead of the
         % standard Mercury operators.
         %
     :- pred term_io.write_variable_with_op_table(Ops::in, var(T)::in,
         varset(T)::in, io::di, io::uo) is det <= op_table(Ops).

         % Given a string S, write S in double-quotes, with characters
         % escaped if necessary, to stdout.
         %
     :- pred term_io.quote_string(string::in, io::di, io::uo) is det.

     :- pred term_io.quote_string(Stream::in, string::in,
         State::di, State::uo) is det
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).

         % Like term_io.quote_string, but return the result in a string.
         %
     :- func term_io.quoted_string(string) = string.

         % Given an atom-name A, write A, enclosed in single-quotes if necessary,
         % with characters escaped if necessary, to stdout.
         %
     :- pred term_io.quote_atom(string::in, io::di, io::uo) is det.

     :- pred term_io.quote_atom(Stream::in, string::in,
         State::di, State::uo) is det
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).

         % Like term_io.quote_atom, but return the result in a string.
         %
     :- func term_io.quoted_atom(string) = string.

         % Given a character C, write C in single-quotes,
         % escaped if necessary, to stdout.
         %
     :- pred term_io.quote_char(char::in, io::di, io::uo) is det.

     :- pred term_io.quote_char(Stream::in, char::in,
         State::di, State::uo) is det
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).

         % Like term_io.quote_char, but return the result in a string.
         %
     :- func term_io.quoted_char(char) = string.

         % Given a character C, write C, escaped if necessary, to stdout.
         % The character is not enclosed in quotes.
         %
     :- pred term_io.write_escaped_char(char::in, io::di, io::uo) is det.

     :- pred term_io.write_escaped_char(Stream::in, char::in,
         State::di, State::uo) is det
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).

         % Like term_io.write_escaped_char, but return the result in a string.
         %
     :- func term_io.escaped_char(char) = string.

         % Given a string S, write S, with characters escaped if necessary,
         % to stdout. The string is not enclosed in quotes.
         %
     :- pred term_io.write_escaped_string(string::in, io::di, io::uo) is det.

     :- pred term_io.write_escaped_string(Stream::in, string::in,
         State::di, State::uo) is det
         <= (stream.writer(Stream, string, State),
         stream.writer(Stream, char, State)).

         % Like term_io.write_escaped_char, but return the result in a string.
         %
     :- func term_io.escaped_string(string) = string.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: term,  Next: term_to_xml,  Prev: term_io,  Up: Top

85 term
*******

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1993-2000, 2003-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: term.m.
     % Main author: fjh.
     % Stability: medium.
     %
     % This file provides a type `term' used to represent Prolog terms,
     % and various predicates to manipulate terms and substitutions.
     % Terms are polymorphic so that terms representing different kinds of
     % thing can be made to be of different types so they don't get mixed up.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module term.
     :- interface.

     :- import_module enum.
     :- import_module list.
     :- import_module map.
     :- import_module type_desc.
     :- import_module univ.

     %--------------------------------------------------%

     :- type term(T)
         --->    functor(
                     const,
                     list(term(T)),
                     term.context
                 )
         ;       variable(
                     var(T),
                     term.context
                 ).

     :- type const
         --->    atom(string)
         ;       integer(int)
         ;       string(string)
         ;       float(float).

     :- type term.context
         --->    context(string, int).
                 % file name, line number.

     :- type var(T).
     :- type var_supply(T).

     :- type generic
         --->    generic.

     :- type term    ==  term(generic).
     :- type var     ==  var(generic).

     %--------------------------------------------------%

         % The following predicates can convert values of (almost) any type
         % to the type `term' and back again.

     :- type term_to_type_result(T, U)
         --->    ok(T)
         ;       error(term_to_type_error(U)).

     :- type term_to_type_result(T) == term_to_type_result(T, generic).

         % term.try_term_to_type(Term, Result):
         % Try to convert the given term to a ground value of type T.
         % If successful, return `ok(X)' where X is the converted value.
         % If Term is not ground, return `mode_error(Var, Context)',
         % where Var is a variable occurring in Term.
         % If Term is not a valid term of the specified type, return
         % `type_error(SubTerm, ExpectedType, Context, ArgContexts)',
         % where SubTerm is a sub-term of Term and ExpectedType is the type
         % expected for that part of Term.
         % Context specifies the file and line number where the
         % offending part of the term was read in from, if available.
         % ArgContexts specifies the path from the root of the term
         % to the offending subterm.
         %
     :- func try_term_to_type(term(U)) = term_to_type_result(T, U).
     :- pred try_term_to_type(term(U)::in, term_to_type_result(T, U)::out) is det.

     :- type term_to_type_error(T)
         --->    type_error(
                     term(T),
                     type_desc.type_desc,
                     context,
                     term_to_type_context
                 )
         ;       mode_error(
                     var(T),
                     term_to_type_context
                 ).

     :- type term_to_type_context == list(term_to_type_arg_context).

     :- type term_to_type_arg_context
         --->    arg_context(
                     const,      % functor
                     int,        % argument number (starting from 1)
                     context     % filename & line number
                 ).

         % term_to_type(Term, Type) :- try_term_to_type(Term, ok(Type)).
         %
     :- pred term_to_type(term(U)::in, T::out) is semidet.

         % Like term_to_type, but calls error/1 rather than failing.
         %
     :- func det_term_to_type(term(_)) = T.
     :- pred det_term_to_type(term(_)::in, T::out) is det.

         % Converts a value to a term representation of that value.
         %
     :- func type_to_term(T) = term(_).
     :- pred type_to_term(T::in, term(_)::out) is det.

         % Convert the value stored in the univ (as distinct from the univ itself)
         % to a term.
         %
     :- func univ_to_term(univ) = term(_).
     :- pred univ_to_term(univ::in, term(_)::out) is det.

     %--------------------------------------------------%

         % vars(Term, Vars):
         %
         % Vars is the list of variables contained in Term, in the order
         % obtained by traversing the term depth first, left-to-right.
         %
     :- func vars(term(T)) = list(var(T)).
     :- pred vars(term(T)::in, list(var(T))::out) is det.

         % As above, but with an accumulator.
         %
     :- func vars_2(term(T), list(var(T))) = list(var(T)).
     :- pred vars_2(term(T)::in, list(var(T))::in, list(var(T))::out) is det.

         % vars_list(TermList, Vars):
         %
         % Vars is the list of variables contained in TermList, in the order
         % obtained by traversing the list of terms depth-first, left-to-right.
         %
     :- func vars_list(list(term(T))) = list(var(T)).
     :- pred vars_list(list(term(T))::in, list(var(T))::out) is det.

         % contains_var(Term, Var):
         %
         % True if Term contains Var. On backtracking returns all the variables
         % contained in Term.
         %
     :- pred contains_var(term(T), var(T)).
     :- mode contains_var(in, in) is semidet.
     :- mode contains_var(in, out) is nondet.

         % contains_var_list(TermList, Var):
         %
         % True if TermList contains Var. On backtracking returns all the variables
         % contained in Term.
         %
     :- pred contains_var_list(list(term(T)), var(T)).
     :- mode contains_var_list(in, in) is semidet.
     :- mode contains_var_list(in, out) is nondet.

     :- type substitution(T) == map(var(T), term(T)).
     :- type substitution    == substitution(generic).

         % unify_term(Term1, Term2, Bindings0, Bindings):
         %
         % Unify (with occur check) two terms with respect to a set of bindings
         % and possibly update the set of bindings.
         %
     :- pred unify_term(term(T)::in, term(T)::in, substitution(T)::in,
         substitution(T)::out) is semidet.

         % As above, but unify the corresponding elements of two lists of terms.
         % Fails if the lists are not of equal length.
         %
     :- pred unify_term_list(list(term(T))::in, list(term(T))::in,
         substitution(T)::in, substitution(T)::out) is semidet.

         % unify_term_dont_bind(Term1, Term2, BoundVars, !Bindings):
         %
         % Unify (with occur check) two terms with respect to a set of bindings
         % and possibly update the set of bindings. Fails if any of the variables
         % in BoundVars would become bound by the unification.
         %
     :- pred unify_term_dont_bind(term(T)::in, term(T)::in, list(var(T))::in,
         substitution(T)::in, substitution(T)::out) is semidet.

         % As above, but unify the corresponding elements of two lists of terms.
         % Fails if the lists are not of equal length.
         %
     :- pred unify_term_list_dont_bind(list(term(T))::in, list(term(T))::in,
         list(var(T))::in, substitution(T)::in, substitution(T)::out) is semidet.

         % list_subsumes(Terms1, Terms2, Subst) succeeds iff the list
         % Terms1 subsumes (is more general than) Terms2, producing a substitution
         % which when applied to Terms1 will give Terms2.
         %
     :- pred list_subsumes(list(term(T))::in, list(term(T))::in,
         substitution(T)::out) is semidet.

         % substitute(Term0, Var, Replacement, Term):
         %
         % Replace all occurrences of Var in Term0 with Replacement,
         % and return the result in Term.
         %
     :- func substitute(term(T), var(T), term(T)) = term(T).
     :- pred substitute(term(T)::in, var(T)::in, term(T)::in, term(T)::out)
         is det.

         % As above, except for a list of terms rather than a single
         %
     :- func substitute_list(list(term(T)), var(T), term(T)) = list(term(T)).
     :- pred substitute_list(list(term(T))::in, var(T)::in, term(T)::in,
         list(term(T))::out) is det.

         % substitute_corresponding(Vars, Repls, Term0, Term):
         %
         % Replace all occurrences of variables in Vars with the corresponding
         % term in Repls, and return the result in Term. If Vars contains
         % duplicates, or if Vars is not the same length as Repls, the behaviour
         % is undefined and probably harmful.
         %
     :- func substitute_corresponding(list(var(T)), list(term(T)),
         term(T)) = term(T).
     :- pred substitute_corresponding(list(var(T))::in, list(term(T))::in,
         term(T)::in, term(T)::out) is det.

         % As above, except applies to a list of terms rather than a single term.
         %
     :- func substitute_corresponding_list(list(var(T)),
         list(term(T)), list(term(T))) = list(term(T)).
     :- pred substitute_corresponding_list(list(var(T))::in,
         list(term(T))::in, list(term(T))::in, list(term(T))::out) is det.

         % apply_rec_substitution(Term0, Substitution, Term):
         %
         % Recursively apply substitution to Term0 until no more substitutions
         % can be applied, and then return the result in Term.
         %
     :- func apply_rec_substitution(term(T), substitution(T)) = term(T).
     :- pred apply_rec_substitution(term(T)::in, substitution(T)::in,
         term(T)::out) is det.

         % As above, except applies to a list of terms rather than a single term.
         %
     :- func apply_rec_substitution_to_list(list(term(T)),
         substitution(T)) = list(term(T)).
     :- pred apply_rec_substitution_to_list(list(term(T))::in,
         substitution(T)::in, list(term(T))::out) is det.

         % apply_substitution(Term0, Substitution, Term):
         %
         % Apply substitution to Term0 and return the result in Term.
         %
     :- func apply_substitution(term(T), substitution(T)) = term(T).
     :- pred apply_substitution(term(T)::in, substitution(T)::in,
         term(T)::out) is det.

         % As above, except applies to a list of terms rather than a single term.
         %
     :- func apply_substitution_to_list(list(term(T)),
         substitution(T)) = list(term(T)).
     :- pred apply_substitution_to_list(list(term(T))::in,
         substitution(T)::in, list(term(T))::out) is det.

         % occurs(Term0, Var, Substitution):
         % True iff Var occurs in the term resulting after applying Substitution
         % to Term0. Var variable must not be mapped by Substitution.
         %
     :- pred occurs(term(T)::in, var(T)::in, substitution(T)::in) is semidet.

         % As above, except for a list of terms rather than a single term.
         %
     :- pred occurs_list(list(term(T))::in, var(T)::in, substitution(T)::in)
         is semidet.

         % relabel_variable(Term0, OldVar, NewVar, Term):
         %
         % Replace all occurrences of OldVar in Term0 with NewVar and put the result
         % in Term.
         %
     :- func relabel_variable(term(T), var(T), var(T)) = term(T).
     :- pred relabel_variable(term(T)::in, var(T)::in, var(T)::in, term(T)::out)
         is det.

         % As above, except applies to a list of terms rather than a single term.
         % XXX the name of the predicate is misleading.
         %
     :- func relabel_variables(list(term(T)), var(T), var(T)) = list(term(T)).
     :- pred relabel_variables(list(term(T))::in, var(T)::in, var(T)::in,
         list(term(T))::out) is det.

         % Same as relabel_variable, except relabels multiple variables.
         % If a variable is not in the map, it is not replaced.
         %
     :- func apply_variable_renaming(term(T), map(var(T), var(T))) = term(T).
     :- pred apply_variable_renaming(term(T)::in, map(var(T), var(T))::in,
         term(T)::out) is det.

         % Applies apply_variable_renaming to a list of terms.
         %
     :- func apply_variable_renaming_to_list(list(term(T)),
         map(var(T), var(T))) = list(term(T)).
     :- pred apply_variable_renaming_to_list(list(term(T))::in,
         map(var(T), var(T))::in, list(term(T))::out) is det.

         % Applies apply_variable_renaming to a var.
         %
     :- func apply_variable_renaming_to_var(map(var(T), var(T)),
         var(T)) = var(T).
     :- pred apply_variable_renaming_to_var(map(var(T), var(T))::in,
         var(T)::in, var(T)::out) is det.

         % Applies apply_variable_renaming to a list of vars.
         %
     :- func apply_variable_renaming_to_vars(map(var(T), var(T)),
         list(var(T))) = list(var(T)).
     :- pred apply_variable_renaming_to_vars(map(var(T), var(T))::in,
         list(var(T))::in, list(var(T))::out) is det.

         % is_ground_in_bindings(Term, Bindings) is true iff no variables contained
         % in Term are non-ground in Bindings.
         %
     :- pred is_ground_in_bindings(term(T)::in, substitution(T)::in) is semidet.

         % is_ground(Term) is true iff Term contains no variables.
         %
     :- pred is_ground(term(T)::in) is semidet.

     %--------------------------------------------------%

         % To manage a supply of variables, use the following 2 predicates.
         % (We might want to give these a unique mode later.)

         % init_var_supply(VarSupply):
         %
         % Returns a fresh var_supply for producing fresh variables.
         %
     :- func init_var_supply = var_supply(T).
     :- pred init_var_supply(var_supply(T)).
     :- mode init_var_supply(out) is det.
     :- mode init_var_supply(in) is semidet. % implied

         % create_var(VarSupply0, Variable, VarSupply):
         % Create a fresh variable (var) and return the updated var_supply.
         %
     :- pred create_var(var_supply(T), var(T), var_supply(T)).
     :- mode create_var(in, out, out) is det.

         % var_id(Variable):
         % Returns a unique number associated with this variable w.r.t.
         % its originating var_supply.
         %
     :- func var_id(var(T)) = int.

     %--------------------------------------------------%

         % from_int/1 should only be applied to integers returned by to_int/1.
         % This instance declaration is needed to allow sets of variables to be
         % represented using sparse_bitset.m.
     :- instance enum(var(_)).

         % Convert a variable to an int. Different variables map to different ints.
         % Other than that, the mapping is unspecified.
         %
     :- func var_to_int(var(T)) = int.
     :- pred var_to_int(var(T)::in, int::out) is det.

     %--------------------------------------------------%

         % Given a term context, return the source line number.
         %
     :- func context_line(context) = int.
     :- pred context_line(context::in, int::out) is det.

         % Given a term context, return the source file.
         %
     :- func context_file(context) = string.
     :- pred context_file(context::in, string::out) is det.

         % Used to initialize the term context when reading in
         % (or otherwise constructing) a
         %
     :- func context_init = context.
     :- pred context_init(context::out) is det.
     :- func context_init(string, int) = context.
     :- pred context_init(string::in, int::in, context::out) is det.

         % Convert a list of terms which are all vars into a list of vars.
         % Abort (call error/1) if the list contains any non-variables.
         %
     :- func term_list_to_var_list(list(term(T))) = list(var(T)).

         % Convert a list of terms which are all vars into a list of vars.
         %
     :- pred term_list_to_var_list(list(term(T))::in, list(var(T))::out) is semidet.

         % Convert a list of terms which are all vars into a list of vars
         % (or vice versa).
         %
     :- func var_list_to_term_list(list(var(T))) = list(term(T)).
     :- pred var_list_to_term_list(list(var(T))::in, list(term(T))::out) is det.

     %--------------------------------------------------%

         % generic_term(Term) is true iff `Term' is a term of type
         % `term' ie `term(generic)'. It is useful because in some instances
         % it doesn't matter what the type of a term is, and passing it to this
         % predicate will ground the type avoiding unbound type variable warnings.
         %
     :- pred generic_term(term::in) is det.

         % Coerce a term of type `T' into a term of type `U'.
         %
     :- func coerce(term(T)) = term(U).
     :- pred coerce(term(T)::in, term(U)::out) is det.

         % Coerce a var of type `T' into a var of type `U'.
         %
     :- func coerce_var(var(T)) = var(U).
     :- pred coerce_var(var(T)::in, var(U)::out) is det.

         % Coerce a var_supply of type `T' into a var_supply of type `U'.
         %
     :- func coerce_var_supply(var_supply(T)) = var_supply(U).
     :- pred coerce_var_supply(var_supply(T)::in, var_supply(U)::out) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: term_to_xml,  Next: thread.channel,  Prev: term,  Up: Top

86 term_to_xml
**************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et
     %--------------------------------------------------%
     % Copyright (C) 1993-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: term_to_xml.m.
     % Main author: maclarty.
     % Stability: low.
     %
     % This module provides two mechanisms for converting Mercury terms
     % to XML documents.
     %
     % Method 1
     % --------
     % The first method requires a type to be an instance of the xmlable typeclass
     % before values of the type can be written as XML.
     % Members of the xmlable typeclass must implement a to_xml method which
     % maps values of the type to XML elements.
     % The XML elements may contain arbitrary children, comments and data.
     %
     % Method 2
     % --------
     % The second method is less flexible than the first, but it allows for the
     % automatic generation of a DTD.
     % Each functor in a term is given a corresponding well-formed element name in
     % the XML document according to a mapping.  Some predefined mappings are
     % provided, but user defined mappings may also be used.
     %
     % Method 1 vs. Method 2
     % ---------------------
     %
     % Method 1 allows values of a specific type to be mapped to arbitrary XML
     % elements with arbitrary children and arbitrary attributes.
     % In method 2 each functor in a term can be mapped to only one XML element.
     % Method 2 also only allows a selected set of attributes.
     % In method 2 a DTD can be automatically generated.  In method 1 DTDs cannot
     % be automatically generated.
     %
     % Method 1 is useful for mapping a specific type to XML,
     % for example mapping terms which represent mathematical expressions to
     % MathML.
     % Method 2 is useful for mapping arbitrary terms of any type to XML.
     %
     % In both methods the XML document can be annotated with a stylesheet
     % reference.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module term_to_xml.
     :- interface.

     :- import_module deconstruct.
     :- import_module list.
     :- import_module maybe.
     :- import_module stream.
     :- import_module type_desc.

     %--------------------------------------------------%
     %
     % Method 1 interface
     %

         % Instances of this typeclass can be converted to XML.
         %
     :- typeclass xmlable(T) where [
         func to_xml(T::in) = (xml::out(xml_doc)) is det
     ].

         % Values of this type represent an XML document or a portion of
         % an XML document.
         %
     :- type xml
         --->    elem(
                     % An XML element with a name, list of attributes
                     % and a list of children.
                     element_name    :: string,
                     attributes      :: list(attr),
                     children        :: list(xml)
                 )

         ;       data(string)
                 % Textual data.  `<', `>', `&', `'' and `"' characters
                 % will be replaced by `&lt;', `&gt;', `&amp;', `&apos;'
                 % and `&quot;' respectively.

         ;       cdata(string)
                 % Data to be enclosed in `<![CDATA[' and `]]>' tags.
                 % The string may not contain the substring "]]>".
                 % If it does then invalid XML will be generated.

         ;       comment(string)
                 % An XML comment.  The comment should not
                 % include the `<!--' and `-->'.  Any occurrences of
                 % the substring "--" will be replaced by " - ",
                 % since "--" is not allowed in XML comments.

         ;       entity(string)
                 % An entity reference.  The string will
                 % have `&' prepended and `;' appended before being
                 % output.

         ;       raw(string).
                 % Raw XML data.  The data will be written out verbatim.

         % An XML document must have an element at the top-level.
         % The following inst is used to enforce this restriction.
         %
     :- inst xml_doc
         --->    elem(
                     ground, % element_name
                     ground, % attributes
                     ground  % children
                 ).

         % An element attribute, mapping a name to a value.
         %
     :- type attr
         --->    attr(string, string).

         % Values of this type specify the DOCTYPE of an XML document when
         % the DOCTYPE is defined by an external DTD.
         %
     :- type doctype
         --->    public(string)                  % Formal Public Identifier (FPI)
         ;       public_system(string, string)   % FPI, URL
         ;       system(string).                 % URL

         % Values of this type specify whether a DTD should be included in
         % a generated XML document and if so how.
         %
     :- type maybe_dtd
         --->    embed_dtd
                 % Generate and embed the entire DTD in the document
                 % (only available for method 2).

         ;       external_dtd(doctype)
                 % Included a reference to an external DTD.

         ;       no_dtd.
                 % Do not include any DOCTYPE information.

     :- inst non_embedded_dtd
         --->    external_dtd(ground)
         ;       no_dtd.

         % Values of this type indicate whether a stylesheet reference should be
         % included in a generated XML document.
         %
     :- type maybe_stylesheet
         --->    with_stylesheet(
                     stylesheet_type :: string, % For example "text/xsl"
                     stylesheet_href :: string
                 )
         ;       no_stylesheet.

         % write_xml_doc(Stream, Term, !State):
         %
         % Output Term as an XML document to the given stream.
         % Term must be an instance of the xmlable typeclass.
         %
     :- pred write_xml_doc(Stream::in, T::in, State::di, State::uo)
         is det <= (xmlable(T), stream.writer(Stream, string, State)).

         % write_xml_doc_style_dtd(Stream, Term, MaybeStyleSheet, MaybeDTD,
         %   !State):
         %
         % Write Term to the given stream as an XML document.
         % MaybeStyleSheet and MaybeDTD specify whether or not a stylesheet
         % reference and/or a DTD should be included.
         % Using this predicate, only external DTDs can be included, i.e.
         % a DTD cannot be automatically generated and embedded
         % (that feature is available only for method 2 -- see below).
         %
     :- pred write_xml_doc_style_dtd(Stream::in, T::in,
         maybe_stylesheet::in, maybe_dtd::in(non_embedded_dtd),
         State::di, State::uo) is det
         <= (xmlable(T), stream.writer(Stream, string, State)).

         % write_xml_element(Stream, Indent, Term, !State):
         %
         % Write Term out as XML to the given stream, using Indent as the
         % indentation level (each indentation level is one tab character).
         % No `<?xml ... ?>' header will be written.
         % This is useful for generating large XML documents piecemeal.
         %
     :- pred write_xml_element(Stream::in, int::in, T::in,
         State::di, State::uo) is det
         <= (xmlable(T), stream.writer(Stream, string, State)).

         % write_xml_header(Stream, MaybeEncoding, !State):
         %
         % Write an XML header (i.e. `<?xml version="1.0"?>) to the
         % current file output stream.
         % If MaybeEncoding is yes(Encoding), then include `encoding="Encoding"'
         % in the header.
         %
     :- pred write_xml_header(Stream::in, maybe(string)::in,
         State::di, State::uo) is det <= stream.writer(Stream, string, State).

     %--------------------------------------------------%
     %
     % Method 2 interface
     %

         % Values of this type specify which mapping from functors to elements
         % to use when generating XML.  The role of a mapping is twofold:
         %   1. To map functors to elements, and
         %   2. To map functors to a set of attributes that should be
         %      generated for the corresponding element.
         %
         % We provide two predefined mappings:
         %
         %   1. simple: The functors `[]', `[|]' and `{}' are mapped to the
         %   elements `List', `Nil' and `Tuple' respectively.  Arrays are
         %   assigned the `Array' element.  The builtin types are assigned
         %   the elements `Int', `String', `Float' and `Char'.  All other
         %   functors are assigned elements with the same name as the
         %   functor provided the functor name is well formed and does
         %   not start with a capital letter.  Otherwise a mangled
         %   version of the functor name is used.
         %
         %   All elements except `Int', `String', `Float' and `Char'
         %   will have their `functor', `arity', `type' and `field' (if
         %   there is a field name) attributes set.  `Int', `String',
         %   `Float' and `Char' elements will just have their `type' and
         %   possibly their `field' attributes set.
         %
         %   The `simple' mapping is designed to be easy to read and use,
         %   but may result in the same element being assigned to different
         %   functors.
         %
         %   2. unique: Here we use the same mapping as `simple' except
         %   we append the functor arity for discriminated unions and
         %   a mangled version of the type name for every element.  The same
         %   attributes as the `simple' scheme are provided.  The advantage
         %   of this scheme is that it maps each functor to a unique
         %   element.  This means that it will always be possible to
         %   generate a DTD using this mapping so long as there is only
         %   one top level functor and no unsupported types can appear in
         %   terms of the type.
         %
         % A custom mapping can be provided using the `custom' functor.  See the
         % documentation for the element_pred type below for more information.
         %
     :- type element_mapping
         --->    simple
         ;       unique
         ;       custom(element_pred).

     :- inst element_mapping
         --->    simple
         ;       unique
         ;       custom(element_pred).

         % Deterministic procedures with the following signature can be used as
         % custom functor to element mappings.  The inputs to the procedure are
         % a type and some information about a functor for that type
         % if the type is a discriminated union.  The output should be a well
         % formed XML element name and a list of attributes that should be set
         % for that element.  See the types `maybe_functor_info' and
         % `attr_from_source' below.
         %
     :- type element_pred == (pred(type_desc, maybe_functor_info, string,
         list(attr_from_source))).

     :- inst element_pred == (pred(in, in, out, out) is det).

         % Values of this type are passed to custom functor-to-element
         % mapping predicates to tell the predicate which functor to generate
         % an element name for if the type is a discriminated union.  If the
         % type is not a discriminated union, then non_du is passed to
         % the predicate when requesting an element for the type.
         %
     :- type maybe_functor_info
         --->    du_functor(
                     % The functor's name and arity.
                     functor_name    :: string,
                     functor_arity   :: int
                 )

         ;       non_du.
                 % The type is not a discriminated union.

         % Values of this type specify attributes that should be set from
         % a particular source.  The attribute_name field specifies the name
         % of the attribute in the generated XML and the attribute_source
         % field indicates where the attribute's value should come from.
         %
     :- type attr_from_source
         --->    attr_from_source(
                     attr_name   :: string,
                     attr_source :: attr_source
                 ).

         % Possible attribute sources.
         %
     :- type attr_source
         --->    functor
                 % The original functor name as returned by
                 % deconstruct.deconstruct/5.

         ;       field_name
                 % The field name if the functor appears in a
                 % named field (If the field is not named then this
                 % attribute is omitted).

         ;       type_name
                 % The fully qualified type name the functor is for.

         ;       arity.
                 % The arity of the functor as returned by
                 % deconstruct.deconstruct/5.

         % To support third parties generating XML which is compatible with the
         % XML generated using method 2, a DTD for a Mercury type can also be
         % generated.  A DTD for a given type and functor-to-element mapping may
         % be generated provided the following conditions hold:
         %
         %   1. If the type is a discriminated union then there must be only
         %   one top-level functor for the type.  This is because the top
         %   level functor will be used to generate the document type name.
         %
         %   2. The functor to element mapping must map each functor to a
         %   unique element name for every functor that could appear in
         %   terms of the type.
         %
         %   3. Only types whose terms consist of discriminated unions,
         %   arrays and the builtin types `int', `string', `character' and
         %   `float' can be used to automatically generate DTDs.
         %   Existential types are also not supported.
         %
         % The generated DTD is also a good reference when creating a stylesheet
         % as it contains comments describing the mapping from functors to
         % elements.
         %
         % Values of the following type indicate whether a DTD was successfully
         % generated or not.
         %
     :- type dtd_generation_result
         --->    ok

         ;       multiple_functors_for_root
                 % The root type is a discriminated union with
                 % multiple functors.

         ;       duplicate_elements(
                     % The functor-to-element mapping maps different
                     % functors to the same element.  The duplicate element
                     % and a list of types whose functors map to that
                     % element is given.
                     duplicate_element   :: string,
                     duplicate_types     :: list(type_desc)
                 )

         ;       unsupported_dtd_type(type_desc)
                 % At the moment we only support generation of DTDs for types
                 % made up of discriminated unions, arrays, strings, ints,
                 % characters and floats. If a type is not supported, then it is
                 % returned as the argument of this functor.

         ;       type_not_ground(pseudo_type_desc).
                 % If one of the arguments of a functor is existentially typed,
                 % then the pseudo_type_desc for the existentially quantified
                 % argument is returned as the argument of this functor.
                 % Since the values of existentially typed arguments can be of
                 % any type (provided any typeclass constraints are satisfied)
                 % it is not generally possible to generate DTD rules for functors
                 % with existentially typed arguments.

         % write_xml_doc_general(Stream, Term, ElementMapping,
         %   MaybeStyleSheet, MaybeDTD, DTDResult, !State):
         %
         % Write Term to the given stream as an XML document using
         % ElementMapping as the scheme to map functors to elements.
         % MaybeStyleSheet and MaybeDTD specify whether or not a stylesheet
         % reference and/or a DTD should be included.  Any non-canonical terms
         % will be canonicalized.  If an embedded DTD is requested, but it is
         % not possible to generate a DTD for Term using ElementMapping, then a
         % value other than `ok' is returned in DTDResult and nothing is written
         % out.  See the dtd_generation_result type for a list of the other
         % possible values of DTDResult and their meanings.
         %
     :- pred write_xml_doc_general(Stream::in, T::in,
         element_mapping::in(element_mapping), maybe_stylesheet::in,
         maybe_dtd::in, dtd_generation_result::out, State::di, State::uo) is det
         <= stream.writer(Stream, string, State).

         % write_xml_doc_general_cc(Stream, Term, ElementMapping, MaybeStyleSheet,
         %    MaybeDTD, DTDResult, !State):
         %
         % Write Term to the current file output stream as an XML document using
         % ElementMapping as the scheme to map functors to elements.
         % MaybeStyleSheet and MaybeDTD specify whether or not a stylesheet
         % reference and/or a DTD should be included.  Any non-canonical terms
         % will be written out in full.  If an embedded DTD is requested, but
         % it is not possible to generate a DTD for Term using ElementMapping,
         % then a value other than `ok' is returned in DTDResult and nothing is
         % written out.  See the dtd_generation_result type for a list of the
         % other possible values of DTDResult and their meanings.
         %
     :- pred write_xml_doc_general_cc(Stream::in, T::in,
         element_mapping::in(element_mapping), maybe_stylesheet::in,
         maybe_dtd::in, dtd_generation_result::out, State::di, State::uo)
         is cc_multi <= stream.writer(Stream, string, State).

         % can_generate_dtd(ElementMapping, Type) = Result:
         %
         % Check if a DTD can be generated for the given Type using the
         % functor-to-element mapping scheme ElementMapping.  Return `ok' if it
         % is possible to generate a DTD.  See the documentation of the
         % dtd_generation_result type for the meaning of the return value when
         % it is not `ok'.
         %
     :- func can_generate_dtd(element_mapping::in(element_mapping),
         type_desc::in) = (dtd_generation_result::out) is det.

         % write_dtd(Stream, Term, ElementMapping, DTDResult, !State):
         %
         % Write a DTD for the given term to the current file output stream using
         % ElementMapping to map functors to elements.  If a DTD
         % cannot be generated for Term using ElementMapping then a value
         % other than `ok' is returned in DTDResult and nothing is written.
         % See the dtd_generation_result type for a list of the other
         % possible values of DTDResult and their meanings.
         %
     :- pred write_dtd(Stream::in, T::unused,
         element_mapping::in(element_mapping), dtd_generation_result::out,
         State::di, State::uo) is det
         <= stream.writer(Stream, string, State).

         % write_dtd_for_type(Stream, Type, ElementMapping, DTDResult,
         %   !State):
         %
         % Write a DTD for the given type to the given stream. If a
         % DTD cannot be generated for Type using ElementMapping then a value
         % other than `ok' is returned in DTDResult and nothing is written.
         % See the dtd_generation_result type for a list of the other
         % possible values of DTDResult and their meanings.
         %
     :- pred write_dtd_from_type(Stream::in, type_desc::in,
         element_mapping::in(element_mapping), dtd_generation_result::out,
         State::di, State::uo) is det
         <= stream.writer(Stream, string, State).

         % write_xml_element_general(Stream, NonCanon, MakeElement, IndentLevel,
         %   Term, !State):
         %
         % Write XML elements for the given term and all its descendents,
         % using IndentLevel as the initial indentation level (each
         % indentation level is one tab character) and using the MakeElement
         % predicate to map functors to elements.  No <?xml ... ?>
         % header will be written.  Non-canonical terms will be handled
         % according to the value of NonCanon.  See the deconstruct
         % module in the standard library for more information on this argument.
         %
     :- pred write_xml_element_general(Stream, deconstruct.noncanon_handling,
         element_mapping, int, T, State, State)
         <= stream.writer(Stream, string, State).
     :- mode write_xml_element_general(in, in(do_not_allow), in(element_mapping),
         in, in, di, uo) is det.
     :- mode write_xml_element_general(in, in(canonicalize), in(element_mapping),
         in, in, di, uo) is det.
     :- mode write_xml_element_general(in, in(include_details_cc),
         in(element_mapping), in, in, di, uo) is cc_multi.
     :- mode write_xml_element_general(in, in, in(element_mapping),
         in, in, di, uo) is cc_multi.

     %--------------------------------------------------%
     % The following predicates are all deprecated.  They will be removed
     % after the next official release.
     %

     :- import_module io.

     :- pragma obsolete(write_xml_doc/3).
     :- pred write_xml_doc(T::in, io::di, io::uo) is det <= xmlable(T).

     :- pragma obsolete(write_xml_doc_to_stream/4).
     :- pred write_xml_doc_to_stream(io.output_stream::in, T::in, io::di, io::uo)
         is det <= xmlable(T).

     :- pragma obsolete(write_xml_doc_style_dtd/5).
     :- pred write_xml_doc_style_dtd(T::in, maybe_stylesheet::in,
         maybe_dtd::in(non_embedded_dtd), io::di, io::uo) is det <= xmlable(T).

     :- pragma obsolete(write_xml_doc_style_dtd_stream/6).
     :- pred write_xml_doc_style_dtd_stream(io.output_stream::in, T::in,
         maybe_stylesheet::in, maybe_dtd::in(non_embedded_dtd), io::di, io::uo)
         is det <= xmlable(T).

     :- pragma obsolete(write_xml_element/4).
     :- pred write_xml_element(int::in, T::in, io::di, io::uo) is det <= xmlable(T).

     :- pragma obsolete(write_xml_element_to_stream/5).
     :- pred write_xml_element_to_stream(io.output_stream::in, int::in, T::in,
         io::di, io::uo) is det <= xmlable(T).

     :- pragma obsolete(write_xml_header/3).
     :- pred write_xml_header(maybe(string)::in, io::di, io::uo) is det.

     :- pragma obsolete(write_xml_doc_general/7).
     :- pred write_xml_doc_general(T::in, element_mapping::in(element_mapping),
         maybe_stylesheet::in, maybe_dtd::in, dtd_generation_result::out,
         io::di, io::uo) is det.

     :- pragma obsolete(write_xml_doc_general_to_stream/8).
     :- pred write_xml_doc_general_to_stream(io.output_stream::in, T::in,
         element_mapping::in(element_mapping), maybe_stylesheet::in,
         maybe_dtd::in, dtd_generation_result::out, io::di, io::uo) is det.

     :- pragma obsolete(write_xml_doc_general_cc/7).
     :- pred write_xml_doc_general_cc(T::in, element_mapping::in(element_mapping),
         maybe_stylesheet::in, maybe_dtd::in, dtd_generation_result::out,
         io::di, io::uo) is cc_multi.

     :- pragma obsolete(write_xml_doc_general_cc_to_stream/8).
     :- pred write_xml_doc_general_cc_to_stream(io.output_stream::in, T::in,
         element_mapping::in(element_mapping), maybe_stylesheet::in,
         maybe_dtd::in, dtd_generation_result::out, io::di, io::uo) is cc_multi.

     :- pragma obsolete(write_dtd/5).
     :- pred write_dtd(T::unused, element_mapping::in(element_mapping),
         dtd_generation_result::out, io::di, io::uo) is det.

     :- pragma obsolete(write_dtd_to_stream/6).
     :- pred write_dtd_to_stream(io.output_stream::in, T::unused,
         element_mapping::in(element_mapping), dtd_generation_result::out,
         io::di, io::uo) is det.

     :- pragma obsolete(write_dtd_from_type/5).
     :- pred write_dtd_from_type(type_desc::in,
         element_mapping::in(element_mapping), dtd_generation_result::out,
         io::di, io::uo) is det.

     :- pragma obsolete(write_dtd_from_type_to_stream/6).
     :- pred write_dtd_from_type_to_stream(io.output_stream::in, type_desc::in,
         element_mapping::in(element_mapping), dtd_generation_result::out,
         io::di, io::uo) is det.

     :- pragma obsolete(write_xml_element_general/6).
     :- pred write_xml_element_general(deconstruct.noncanon_handling,
         element_mapping, int, T, io, io).
     :- mode write_xml_element_general(in(do_not_allow), in(element_mapping),
         in, in, di, uo) is det.
     :- mode write_xml_element_general(in(canonicalize), in(element_mapping),
         in, in, di, uo) is det.
     :- mode write_xml_element_general(in(include_details_cc), in(element_mapping),
         in, in, di, uo) is cc_multi.
     :- mode write_xml_element_general(in, in(element_mapping),
         in, in, di, uo) is cc_multi.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: thread.channel,  Next: thread,  Prev: term_to_xml,  Up: Top

87 thread.channel
*****************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et
     %--------------------------------------------------%
     % Copyright (C) 2000-2001, 2006-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: thread.channel.m.
     % Main author: petdr.
     % Stability: low.
     %
     % A mvar can only contain a single value, a channel on the other hand provides
     % unbounded buffering.
     %
     % For example a program could consist of 2 worker threads and one logging
     % thread.  The worker threads can place messages into the channel, and they
     % will be buffered for processing by the logging thread.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module thread.channel.
     :- interface.

     :- import_module io.
     :- import_module maybe.

     %--------------------------------------------------%

     :- type channel(T).

         % Initialise a channel.
         %
     :- pred channel.init(channel(T)::out, io::di, io::uo) is det.

         % Put an item at the end of the channel.
         %
     :- pred channel.put(channel(T)::in, T::in, io::di, io::uo) is det.

         % Take an item from the start of the channel, block if there is
         % nothing in the channel.
         %
     :- pred channel.take(channel(T)::in, T::out, io::di, io::uo) is det.

         % Take an item from the start of the channel.
         % Returns immediately with no if the channel was empty.
         %
     :- pred channel.try_take(channel(T)::in, maybe(T)::out, io::di, io::uo) is det.

         % Duplicate a channel.  The new channel sees all (and only) the
         % data written to the channel after the channel.duplicate call.
         %
     :- pred channel.duplicate(channel(T)::in, channel(T)::out, io::di, io::uo)
         is det.

         % Place an item back at the start of the channel.
         %
     :- pred channel.untake(channel(T)::in, T::in, io::di, io::uo) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: thread,  Next: thread.mvar,  Prev: thread.channel,  Up: Top

88 thread
*********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et
     %--------------------------------------------------%
     % Copyright (C) 2000-2001,2003-2004, 2006-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: thread.m.
     % Main author: conway.
     % Stability: medium.
     %
     % This module defines the Mercury concurrency interface.
     %
     % The term `concurrency' here refers to threads, not necessarily to parallel
     % execution.  (The latter is also possible if you are using one of the .par
     % grades and the lowlevel C backend, e.g. grade asm_fast.par.gc).
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module thread.
     :- interface.

     :- import_module io.

     :- include_module channel.
     :- include_module mvar.
     :- include_module semaphore.

     %--------------------------------------------------%

         % can_spawn succeeds if spawn/3 is supported in the current grade.
         %
     :- pred can_spawn is semidet.

         % spawn(Closure, IO0, IO) is true iff `IO0' denotes a list of I/O
         % transactions that is an interleaving of those performed by `Closure'
         % and those contained in `IO' - the list of transactions performed by
         % the continuation of spawn/3.
         %
     :- pred spawn(pred(io, io)::in(pred(di, uo) is cc_multi),
         io::di, io::uo) is cc_multi.

         % yield(IO0, IO) is logically equivalent to (IO = IO0) but
         % operationally, yields the Mercury engine to some other thread
         % if one exists.
         %
         % NOTE: this is not yet implemented in the hl*.par.gc grades; currently
         % it is a no-op in those grades.
         %
     :- pred yield(io::di, io::uo) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: thread.mvar,  Next: thread.semaphore,  Prev: thread,  Up: Top

89 thread.mvar
**************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et
     %--------------------------------------------------%
     % Copyright (C) 2000-2003, 2006-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: thread.mvar.m.
     % Main author: petdr, fjh.
     % Stability: low.
     %
     % This module provides a Mercury version of Haskell mutable variables.  A
     % mutable variable (mvar) is a reference to a mutable location which can
     % either contain a value of type T or be empty.
     %
     % Access to a mvar is thread-safe and can be used to synchronize between
     % different threads.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module thread.mvar.
     :- interface.

     :- import_module io.
     :- import_module maybe.

     %--------------------------------------------------%

     :- type mvar(T).

         % Create an empty mvar.
         %
     :- pred mvar.init(mvar(T)::out, io::di, io::uo) is det.

         % Take the contents of the mvar out leaving the mvar empty.
         % If the mvar is empty, block until some thread fills the mvar.
         %
     :- pred mvar.take(mvar(T)::in, T::out, io::di, io::uo) is det.

         % Take the contents of the mvar out leaving the mvar empty.
         % Returns immediately with no if the mvar was empty, or yes(X) if
         % the mvar contained X.
         %
     :- pred mvar.try_take(mvar(T)::in, maybe(T)::out, io::di, io::uo) is det.

         % Place the value of type T into an empty mvar.
         % If the mvar is full block until it becomes empty.
         %
     :- pred mvar.put(mvar(T)::in, T::in, io::di, io::uo) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: thread.semaphore,  Next: time,  Prev: thread.mvar,  Up: Top

90 thread.semaphore
*******************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et
     %--------------------------------------------------%
     % Copyright (C) 2000-2001,2003-2004, 2006-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: thread.semaphore.m.
     % Main author: conway.
     % Stability: medium.
     %
     % This module implements a simple semaphore data type for allowing
     % coroutines to synchronise with one another.
     %
     % The operations in this module are no-ops in the hlc grades that do not
     % contain a .par component.
     %
     %--------------------------------------------------%

     :- module thread.semaphore.
     :- interface.

     :- import_module bool.
     :- import_module io.

     %--------------------------------------------------%

     :- type semaphore.

         % new(Sem, !IO) creates a new semaphore `Sem' with its counter
         % initialized to 0.
         %
     :- pred semaphore.new(semaphore::out, io::di, io::uo) is det.

         % new(Count, Sem) creates a new semaphore `Sem' with its counter
         % initialized to Count.
         %
     :- func semaphore.new(int::in) = (semaphore::uo) is det.

         % wait(Sem, !IO) blocks until the counter associated with `Sem'
         % becomes greater than 0, whereupon it wakes, decrements the
         % counter and returns.
         %
     :- pred semaphore.wait(semaphore::in, io::di, io::uo) is det.

         % try_wait(Sem, Succ, !IO) is the same as wait/3, except that
         % instead of blocking, it binds `Succ' to a boolean indicating
         % whether the call succeeded in obtaining the semaphore or not.
         %
     :- pred semaphore.try_wait(semaphore::in, bool::out, io::di, io::uo) is det.

         % signal(Sem, !IO) increments the counter associated with `Sem'
         % and if the resulting counter has a value greater than 0, it wakes
         % one or more coroutines that are waiting on this semaphore (if
         % any).
         %
     :- pred semaphore.signal(semaphore::in, io::di, io::uo) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: time,  Next: tree234,  Prev: thread.semaphore,  Up: Top

91 time
*******

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Originally written in 1999 by Tomas By <T.By@dcs.shef.ac.uk>
     % "Feel free to use this code or parts of it any way you want."
     %
     % Some portions are Copyright (C) 1999-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: time.m.
     % Main authors: Tomas By <T.By@dcs.shef.ac.uk>, fjh.
     % Stability: medium.
     %
     % Time functions.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module time.
     :- interface.

     :- import_module io.
     :- import_module maybe.

     %--------------------------------------------------%

         % The `clock_t' type represents times measured in clock ticks.
         % NOTE: the unit used for a value of this type depends on whether it was
         % returned by `time.clock' or `time.times'.  See the comments on these
         % predicates below.
         %
     :- type clock_t == int.

         % The `tms' type holds information about the amount of processor
         % time that a process and its child processes have consumed.
         %
     :- type tms
         --->    tms(
                     clock_t,    % tms_utime: user time
                     clock_t,    % tms_stime: system time
                     clock_t,    % tms_cutime: user time of children
                     clock_t     % tms_cstime: system time of children
                 ).

         % The `time_t' type is an abstract type that represents
         % calendar times.
         %
     :- type time_t.

         % The `tm' type is a concrete type that represents calendar
         % times, broken down into their constituent components.
         % Comparison (via compare/3) of `tm' values whose `tm_dst'
         % components are identical is equivalent to comparison of
         % the times those `tm' values represent.
         %
     :- type tm
         --->    tm(
                     tm_year :: int,         % Year (number since 1900)
                     tm_mon  :: int,         % Month (number since January, 0-11)
                     tm_mday :: int,         % MonthDay (1-31)
                     tm_hour :: int,         % Hours (after midnight, 0-23)
                     tm_min  :: int,         % Minutes (0-59)
                     tm_sec  :: int,         % Seconds (0-61)
                                             % (60 and 61 are for leap seconds)
                     tm_yday :: int,         % YearDay (number since Jan 1st, 0-365)
                     tm_wday :: int,         % WeekDay (number since Sunday, 0-6)
                     tm_dst  :: maybe(dst)   % IsDST (is DST in effect?)
                 ).

     :- type dst
         --->    standard_time   % no, DST is not in effect
         ;       daylight_time.  % yes, DST is in effect

         % Some of the procedures in this module throw this type
         % as an exception if they can't obtain a result.
         %
     :- type time_error
         --->    time_error(string). % Error message

     %--------------------------------------------------%

         % time.clock(Result, !IO):
         %
         % Returns the elapsed processor time (number of clock ticks). The base time
         % is arbitrary but doesn't change within a single process. If the time
         % cannot be obtained, this procedure will throw a time_error exception.
         % To obtain a time in seconds, divide Result by `time.clocks_per_sec'.
         %
     :- pred time.clock(clock_t::out, io::di, io::uo) is det.

         % time.clocks_per_sec:
         %
         % Returns the number of "clocks" per second as defined by CLOCKS_PER_SEC.
         % A `clock_t' value returned by `time.clock' can be divided by this value
         % to obtain a time in seconds. Note that the value of this function does
         % not necessarily reflect the actual clock precision; it just indicates the
         % scaling factor for the results of time.clock.
         %
     :- func time.clocks_per_sec = int.

     %--------------------------------------------------%

         % time.time(Result, !IO):
         %
         % Returns the current (simple) calendar time. If the time cannot be
         % obtained, this procedure will throw a time_error exception.
         %
     :- pred time.time(time_t::out, io::di, io::uo) is det.

     %--------------------------------------------------%

         % time.times(ProcessorTime, ElapsedRealTime, !IO):
         %
         % (POSIX)
         %
         % Returns the processor time information in the `tms' value, and the
         % elapsed real time relative to an arbitrary base in the `clock_t' value.
         % To obtain a time in seconds, divide the result by `time.clk_tck'.
         % If the time cannot be obtained, this procedure will throw a time_error
         % exception.
         %
         % On non-POSIX systems that do not support this functionality,
         % this procedure may simply always throw an exception.
         %
     :- pred time.times(tms::out, clock_t::out, io::di, io::uo) is det.

         % time.clk_tck:
         %
         % Returns the number of "clock ticks" per second as defined by
         % sysconf(_SC_CLK_TCK). A `clock_t' value returned by `time.times'
         % can be divided by this value to obtain a time in seconds.
         %
         % On non-POSIX systems that do not support this functionality,
         % this procedure may simply always throw an exception.
         %
     :- func time.clk_tck = int.

     %--------------------------------------------------%

         % time.difftime(Time1, Time0) = Diff:
         %
         % Computes the number of seconds elapsed between `Time1' and `Time0'.
         %
     :- func time.difftime(time_t, time_t) = float.

         % time.localtime(Time) = TM:
         %
         % Converts the calendar time `Time' to a broken-down representation,
         % expressed relative to the user's specified time zone.
         %
     :- func time.localtime(time_t) = tm.

         % time.gmtime(Time) = TM:
         %
         % Converts the calendar time `Time' to a broken-down representation,
         % expressed as UTC (Universal Coordinated Time).
         %
     :- func time.gmtime(time_t) = tm.

         % time.mktime(TM) = Time:
         %
         % Converts the broken-down local time value to calendar time.
         % It also normalises the value by filling in day of week and day of year
         % based on the other components.
         %
     :- func time.mktime(tm) = time_t.

     %--------------------------------------------------%

         % time.asctime(TM) = String:
         %
         % Converts the broken-down time value `TM' to a string in a standard
         % format.
         %
     :- func time.asctime(tm) = string.

         % time.ctime(Time) = String:
         %
         % Converts the calendar time value `Time' to a string in a standard format
         % (i.e. same as "asctime (localtime (<time>))").
         %
     :- func time.ctime(time_t) = string.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: tree234,  Next: tree_bitset,  Prev: time,  Up: Top

92 tree234
**********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1994-1997,1999-2000,2002-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: tree234.m.
     % Main author: conway.
     % Stability: medium.
     %
     % This module implements a map (dictionary) using 2-3-4 trees - see
     % map.m for futher documentation.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module tree234.
     :- interface.

     :- import_module assoc_list.
     :- import_module list.
     :- import_module pretty_printer.
     :- import_module term.

     %--------------------------------------------------%

     :- type tree234(K, V).

     :- func tree234.init = tree234(K, V).
     :- pred tree234.init(tree234(K, V)::uo) is det.

     :- pred tree234.is_empty(tree234(K, V)::in) is semidet.

     :- pred tree234.member(tree234(K, V)::in, K::out, V::out) is nondet.

     :- pred tree234.search(tree234(K, V)::in, K::in, V::out) is semidet.

     :- func tree234.lookup(tree234(K, V), K) = V.
     :- pred tree234.lookup(tree234(K, V)::in, K::in, V::out) is det.

         % Search for a key-value pair using the key.  If there is no entry
         % for the given key, returns the pair for the next lower key instead.
         % Fails if there is no key with the given or lower value.
         %
     :- pred tree234.lower_bound_search(tree234(K, V)::in, K::in, K::out, V::out)
         is semidet.

         % Search for a key-value pair using the key.  If there is no entry
         % for the given key, returns the pair for the next lower key instead.
         % Aborts if there is no key with the given or lower value.
         %
     :- pred tree234.lower_bound_lookup(tree234(K, V)::in, K::in, K::out, V::out)
         is det.

         % Search for a key-value pair using the key.  If there is no entry
         % for the given key, returns the pair for the next higher key instead.
         % Fails if there is no key with the given or higher value.
         %
     :- pred tree234.upper_bound_search(tree234(K, V)::in, K::in, K::out, V::out)
         is semidet.

         % Search for a key-value pair using the key.  If there is no entry
         % for the given key, returns the pair for the next higher key instead.
         % Aborts if there is no key with the given or higher value.
         %
     :- pred tree234.upper_bound_lookup(tree234(K, V)::in, K::in, K::out, V::out)
         is det.

     :- func tree234.max_key(tree234(K, V)) = K is semidet.

     :- func tree234.min_key(tree234(K, V)) = K is semidet.

     :- pred tree234.insert(tree234(K, V)::in, K::in, V::in, tree234(K, V)::out)
         is semidet.

     :- func tree234.set(tree234(K, V), K, V) = tree234(K, V).
     :- pred tree234.set(tree234(K, V)::in, K::in, V::in, tree234(K, V)::out)
         is det.

     :- func tree234.delete(tree234(K, V), K) = tree234(K, V).
     :- pred tree234.delete(tree234(K, V)::in, K::in, tree234(K, V)::out) is det.

     :- pred tree234.remove(tree234(K, V), K, V, tree234(K, V)).
     :- mode tree234.remove(in, in, out, out) is semidet.

     :- pred tree234.remove_smallest(tree234(K, V), K, V, tree234(K, V)).
     :- mode tree234.remove_smallest(in, out, out, out) is semidet.

         % Given a tree234, return a list of all the keys in the tree.
         % The list that is returned is in sorted order.
         %
     :- func tree234.keys(tree234(K, V)) = list(K).
     :- pred tree234.keys(tree234(K, V)::in, list(K)::out) is det.

     :- func tree234.values(tree234(K, V)) = list(V).
     :- pred tree234.values(tree234(K, V)::in, list(V)::out) is det.

     :- pred tree234.update(tree234(K, V)::in, K::in, V::in, tree234(K, V)::out)
         is semidet.

         % Update the value at the given key by applying the supplied
         % transformation to it.  This is faster than first searching for
         % the value and then updating it.
         %
     :- pred tree234.transform_value(pred(V, V)::in(pred(in, out) is det), K::in,
         tree234(K, V)::in, tree234(K, V)::out) is semidet.

         % Count the number of elements in a tree.
         %
     :- func tree234.count(tree234(K, V)) = int.
     :- pred tree234.count(tree234(K, V)::in, int::out) is det.

     :- func tree234.assoc_list_to_tree234(assoc_list(K, V)) = tree234(K, V).
     :- pred tree234.assoc_list_to_tree234(assoc_list(K, V)::in,
         tree234(K, V)::out) is det.

         % Given a tree234, return an association list of all the
         % keys and values in the tree.  The association list that
         % is returned is sorted on the keys.
         %
     :- func tree234.tree234_to_assoc_list(tree234(K, V)) = assoc_list(K, V).
     :- pred tree234.tree234_to_assoc_list(tree234(K, V)::in,
         assoc_list(K, V)::out) is det.

     :- func tree234.foldl(func(K, V, A) = A, tree234(K, V), A) = A.

     :- pred tree234.foldl(pred(K, V, A, A), tree234(K, V), A, A).
     :- mode tree234.foldl(pred(in, in, in, out) is det, in, in, out) is det.
     :- mode tree234.foldl(pred(in, in, in, out) is semidet, in, in, out)
         is semidet.
     :- mode tree234.foldl(pred(in, in, di, uo) is det, in, di, uo) is det.

     :- pred tree234.foldl2(pred(K, V, A, A, B, B), tree234(K, V), A, A, B, B).
     :- mode tree234.foldl2(pred(in, in, in, out, in, out) is det,
         in, in, out, in, out) is det.
     :- mode tree234.foldl2(pred(in, in, in, out, in, out) is semidet,
         in, in, out, in, out) is semidet.
     :- mode tree234.foldl2(pred(in, in, in, out, di, uo) is det,
         in, in, out, di, uo) is det.
     :- mode tree234.foldl2(pred(in, in, di, uo, di, uo) is det,
         in, di, uo, di, uo) is det.

     :- pred tree234.foldl3(pred(K, V, A, A, B, B, C, C), tree234(K, V),
     	A, A, B, B, C, C).
     :- mode tree234.foldl3(pred(in, in, in, out, in, out, in, out) is det,
         in, in, out, in, out, in, out) is det.
     :- mode tree234.foldl3(pred(in, in, in, out, in, out, in, out) is semidet,
         in, in, out, in, out, in, out) is semidet.
     :- mode tree234.foldl3(pred(in, in, in, out, in, out, di, uo) is det,
         in, in, out, in, out, di, uo) is det.
     :- mode tree234.foldl3(pred(in, in, in, out, di, uo, di, uo) is det,
         in, in, out, di, uo, di, uo) is det.
     :- mode tree234.foldl3(pred(in, in, di, uo, di, uo, di, uo) is det,
         in, di, uo, di, uo, di, uo) is det.

     :- pred tree234.foldl4(pred(K, V, A, A, B, B, C, C, D, D), tree234(K, V),
     	A, A, B, B, C, C, D, D).
     :- mode tree234.foldl4(pred(in, in, in, out, in, out, in, out, in, out)
     	is det,
     	in, in, out, in, out, in, out, in, out) is det.
     :- mode tree234.foldl4(pred(in, in, in, out, in, out, in, out, in, out)
     	is semidet,
     	in, in, out, in, out, in, out, in, out) is semidet.
     :- mode tree234.foldl4(pred(in, in, in, out, in, out, in, out, di, uo) is det,
     	in, in, out, in, out, in, out, di, uo) is det.
     :- mode tree234.foldl4(pred(in, in, in, out, in, out, di, uo, di, uo) is det,
     	in, in, out, in, out, di, uo, di, uo) is det.
     :- mode tree234.foldl4(pred(in, in, in, out, di, uo, di, uo, di, uo) is det,
     	in, in, out, di, uo, di, uo, di, uo) is det.
     :- mode tree234.foldl4(pred(in, in, di, uo, di, uo, di, uo, di, uo) is det,
     	in, di, uo, di, uo, di, uo, di, uo) is det.

     :- func tree234.foldr(func(K, V, A) = A, tree234(K, V), A) = A.

     :- pred tree234.foldr(pred(K, V, A, A), tree234(K, V), A, A).
     :- mode tree234.foldr(pred(in, in, in, out) is det, in, in, out) is det.
     :- mode tree234.foldr(pred(in, in, in, out) is semidet, in, in, out)
         is semidet.
     :- mode tree234.foldr(pred(in, in, di, uo) is det, in, di, uo) is det.

     :- pred tree234.foldr2(pred(K, V, A, A, B, B), tree234(K, V), A, A, B, B).
     :- mode tree234.foldr2(pred(in, in, in, out, in, out) is det,
         in, in, out, in, out) is det.
     :- mode tree234.foldr2(pred(in, in, in, out, in, out) is semidet,
         in, in, out, in, out) is semidet.
     :- mode tree234.foldr2(pred(in, in, in, out, di, uo) is det,
         in, in, out, di, uo) is det.
     :- mode tree234.foldr2(pred(in, in, di, uo, di, uo) is det,
         in, di, uo, di, uo) is det.

     :- pred tree234.foldr3(pred(K, V, A, A, B, B, C, C), tree234(K, V),
     	A, A, B, B, C, C).
     :- mode tree234.foldr3(pred(in, in, in, out, in, out, in, out) is det,
         in, in, out, in, out, in, out) is det.
     :- mode tree234.foldr3(pred(in, in, in, out, in, out, in, out) is semidet,
         in, in, out, in, out, in, out) is semidet.
     :- mode tree234.foldr3(pred(in, in, in, out, in, out, di, uo) is det,
         in, in, out, in, out, di, uo) is det.
     :- mode tree234.foldr3(pred(in, in, in, out, di, uo, di, uo) is det,
         in, in, out, di, uo, di, uo) is det.
     :- mode tree234.foldr3(pred(in, in, di, uo, di, uo, di, uo) is det,
         in, di, uo, di, uo, di, uo) is det.

     :- pred tree234.foldr4(pred(K, V, A, A, B, B, C, C, D, D), tree234(K, V),
     	A, A, B, B, C, C, D, D).
     :- mode tree234.foldr4(pred(in, in, in, out, in, out, in, out, in, out)
     	is det,
     	in, in, out, in, out, in, out, in, out) is det.
     :- mode tree234.foldr4(pred(in, in, in, out, in, out, in, out, in, out)
     	is semidet,
     	in, in, out, in, out, in, out, in, out) is semidet.
     :- mode tree234.foldr4(pred(in, in, in, out, in, out, in, out, di, uo) is det,
     	in, in, out, in, out, in, out, di, uo) is det.
     :- mode tree234.foldr4(pred(in, in, in, out, in, out, di, uo, di, uo) is det,
     	in, in, out, in, out, di, uo, di, uo) is det.
     :- mode tree234.foldr4(pred(in, in, in, out, di, uo, di, uo, di, uo) is det,
     	in, in, out, di, uo, di, uo, di, uo) is det.
     :- mode tree234.foldr4(pred(in, in, di, uo, di, uo, di, uo, di, uo) is det,
     	in, di, uo, di, uo, di, uo, di, uo) is det.

     :- func tree234.map_values(func(K, V) = W, tree234(K, V)) = tree234(K, W).

     :- pred tree234.map_values(pred(K, V, W), tree234(K, V), tree234(K, W)).
     :- mode tree234.map_values(pred(in, in, out) is det, in, out) is det.
     :- mode tree234.map_values(pred(in, in, out) is semidet, in, out) is semidet.

     :- pred tree234.map_foldl(pred(K, V, W, A, A), tree234(K, V), tree234(K, W),
         A, A).
     :- mode tree234.map_foldl(pred(in, in, out, di, uo) is det,
         in, out, di, uo) is det.
     :- mode tree234.map_foldl(pred(in, in, out, in, out) is det,
         in, out, in, out) is det.
     :- mode tree234.map_foldl(pred(in, in, out, in, out) is semidet,
         in, out, in, out) is semidet.

     :- pred tree234.map_foldl2(pred(K, V, W, A, A, B, B),
         tree234(K, V), tree234(K, W), A, A, B, B).
     :- mode tree234.map_foldl2(pred(in, in, out, di, uo, di, uo) is det,
         in, out, di, uo, di, uo) is det.
     :- mode tree234.map_foldl2(pred(in, in, out, in, out, di, uo) is det,
         in, out, in, out, di, uo) is det.
     :- mode tree234.map_foldl2(pred(in, in, out, in, out, in, out) is det,
         in, out, in, out, in, out) is det.
     :- mode tree234.map_foldl2(pred(in, in, out, in, out, in, out) is semidet,
         in, out, in, out, in, out) is semidet.

         % Convert a tree234 into a pretty_printer.doc.  A tree mapping
         % K1 to V1, K2 to V2, ... is formatted as
         % "map([K1 -> V1, K2 -> V2, ...])".  The functor "map" is used
         % because tree234 values are almost exclusively maps.
         %
     :- func tree234_to_doc(tree234(K, V)) = pretty_printer.doc.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: tree_bitset,  Next: type_desc,  Prev: tree234,  Up: Top

93 tree_bitset
**************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et
     %--------------------------------------------------%
     % Copyright (C) 2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: tree_bitset.m.
     % Author: zs, based on sparse_bitset.m by stayl.
     % Stability: medium.
     %
     % This module provides an ADT for storing sets of non-negative integers.
     % If the integers stored are closely grouped, a tree_bitset is more compact
     % than the representation provided by set.m, and the operations will be much
     % faster. Compared to sparse_bitset.m, the operations provided by this module
     % for contains, union, intersection and difference can be expected to have
     % lower asymptotic complexity (often logarithmic in the number of elements in
     % the sets, rather than linear). The price for this is a representation that
     % requires more memory, higher constant factors, and an additional factor
     % representing the tree in the complexity of the operations that construct
     % tree_bitsets. However, since the depth of the tree has a small upper bound,
     % we will fold this into the "higher constant factors" in the descriptions of
     % the complexity of the individual operations below.
     %
     % All this means that using a tree_bitset in preference to a sparse_bitset
     % is likely to be a good idea only when the sizes of the sets to be manipulated
     % are quite big, or when worst-case performance is important.
     %
     % For the time being, this module can only handle items that map to nonnegative
     % integers. This may change once unsigned integer operations are available.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module tree_bitset.
     :- interface.

     :- import_module enum.
     :- import_module list.
     :- import_module term.

     :- use_module set.

     %--------------------------------------------------%

     :- type tree_bitset(T). % <= enum(T).

         % Return an empty set.
         %
     :- func init = tree_bitset(T).

     :- pred empty(tree_bitset(T)).
     :- mode empty(in) is semidet.
     :- mode empty(out) is det.

         % `equal(SetA, SetB)' is true iff `SetA' and `SetB' contain the same
         % elements. Takes O(min(card(SetA), card(SetB))) time.
         %
     :- pred equal(tree_bitset(T)::in, tree_bitset(T)::in) is semidet <= enum(T).

         % `list_to_set(List)' returns a set containing only the members of `List'.
         % Takes O(length(List)) time and space.
         %
     :- func list_to_set(list(T)) = tree_bitset(T) <= enum(T).

         % `sorted_list_to_set(List)' returns a set containing only the members
         % of `List'. `List' must be sorted. Takes O(length(List)) time and space.
         %
     :- func sorted_list_to_set(list(T)) = tree_bitset(T) <= enum(T).

         % `from_set(Set)' returns a bitset containing only the members of `Set'.
         % Takes O(card(Set)) time and space.
         %
     :- func from_set(set.set(T)) = tree_bitset(T) <= enum(T).

         % `to_sorted_list(Set)' returns a list containing all the members of `Set',
         % in sorted order. Takes O(card(Set)) time and space.
         %
     :- func to_sorted_list(tree_bitset(T)) = list(T) <= enum(T).

         % `to_sorted_list(Set)' returns a set.set containing all the members
         % of `Set', in sorted order. Takes O(card(Set)) time and space.
         %
     :- func to_set(tree_bitset(T)) = set.set(T) <= enum(T).

         % `make_singleton_set(Elem)' returns a set containing just the single
         % element `Elem'.
         %
     :- func make_singleton_set(T) = tree_bitset(T) <= enum(T).

         % `subset(Subset, Set)' is true iff `Subset' is a subset of `Set'.
         % Same as `intersect(Set, Subset, Subset)', but may be more efficient.
         %
     :- pred subset(tree_bitset(T)::in, tree_bitset(T)::in) is semidet.

         % `superset(Superset, Set)' is true iff `Superset' is a superset of `Set'.
         % Same as `intersect(Superset, Set, Set)', but may be more efficient.
         %
     :- pred superset(tree_bitset(T)::in, tree_bitset(T)::in) is semidet.

         % `contains(Set, X)' is true iff `X' is a member of `Set'.
         % Takes O(log(card(Set))) time.
         %
     :- pred contains(tree_bitset(T)::in, T::in) is semidet <= enum(T).

         % `member(Set, X)' is true iff `X' is a member of `Set'.
         % Takes O(card(Set)) time for the semidet mode.
         %
     :- pred member(T, tree_bitset(T)) <= enum(T).
     :- mode member(in, in) is semidet.
     :- mode member(out, in) is nondet.

         % `insert(Set, X)' returns the union of `Set' and the set containing
         % only `X'. Takes O(log(card(Set))) time and space.
         %
     :- func insert(tree_bitset(T), T) = tree_bitset(T) <= enum(T).
     :- pred insert(tree_bitset(T)::in, T::in, tree_bitset(T)::out)
         is det <= enum(T).

         % `insert_list(Set, X)' returns the union of `Set' and the set containing
         % only the members of `X'. Same as `union(Set, list_to_set(X))', but may be
         % more efficient.
         %
     :- func insert_list(tree_bitset(T), list(T)) = tree_bitset(T) <= enum(T).
     :- pred insert_list(tree_bitset(T)::in, list(T)::in, tree_bitset(T)::out)
         is det <= enum(T).

         % `delete(Set, X)' returns the difference of `Set' and the set containing
         % only `X'. Takes O(card(Set)) time and space.
         %
     :- func delete(tree_bitset(T), T) = tree_bitset(T) <= enum(T).
     :- pred delete(tree_bitset(T)::in, T::in, tree_bitset(T)::out)
         is det <= enum(T).

         % `delete_list(Set, X)' returns the difference of `Set' and the set
         % containing only the members of `X'. Same as
         % `difference(Set, list_to_set(X))', but may be more efficient.
         %
     :- func delete_list(tree_bitset(T), list(T)) = tree_bitset(T) <= enum(T).
     :- pred delete_list(tree_bitset(T)::in, list(T)::in, tree_bitset(T)::out)
         is det <= enum(T).

         % `remove(Set0, X, Set)' returns in `Set' the difference of `Set0'
         % and the set containing only `X', failing if `Set0' does not contain `X'.
         % Takes O(log(card(Set))) time and space.
         %
     :- pred remove(tree_bitset(T)::in, T::in, tree_bitset(T)::out)
         is semidet <= enum(T).

         % `remove_list(Set0, X, Set)' returns in `Set' the difference of `Set0'
         % and the set containing all the elements of `X', failing if any element
         % of `X' is not in `Set0'. Same as `subset(list_to_set(X), Set0),
         % difference(Set0, list_to_set(X), Set)', but may be more efficient.
         %
     :- pred remove_list(tree_bitset(T)::in, list(T)::in, tree_bitset(T)::out)
         is semidet <= enum(T).

         % `remove_leq(Set, X)' returns `Set' with all elements less than or equal
         % to `X' removed. In other words, it returns the set containing all the
         % elements of `Set' which are greater than `X'. Takes O(log(card(Set)))
         % time and space.
         %
     :- func remove_leq(tree_bitset(T), T) = tree_bitset(T) <= enum(T).

         % `remove_gt(Set, X)' returns `Set' with all elements greater than `X'
         % removed. In other words, it returns the set containing all the elements
         % of `Set' which are less than or equal to `X'. Takes O(log(card(Set)))
         % time and space.
         %
     :- func remove_gt(tree_bitset(T), T) = tree_bitset(T) <= enum(T).

         % `remove_least(Set0, X, Set)' is true iff `X' is the least element in
         % `Set0', and `Set' is the set which contains all the elements of `Set0'
         % except `X'. Takes O(1) time and space.
         %
     :- pred remove_least(tree_bitset(T)::in, T::out, tree_bitset(T)::out)
         is semidet <= enum(T).

         % `union(SetA, SetB)' returns the union of `SetA' and `SetB'. The
         % efficiency of the union operation is not sensitive to the argument
         % ordering. Takes somewhere between O(log(card(SetA)) + log(card(SetB)))
         % and O(card(SetA) + card(SetB)) time and space.
         %
     :- func union(tree_bitset(T), tree_bitset(T)) = tree_bitset(T).
     :- pred union(tree_bitset(T)::in, tree_bitset(T)::in, tree_bitset(T)::out)
         is det.

         % `intersect(SetA, SetB)' returns the intersection of `SetA' and `SetB'.
         % The efficiency of the intersection operation is not sensitive to the
         % argument ordering. Takes somewhere between
         % O(log(card(SetA)) + log(card(SetB))) and O(card(SetA) + card(SetB)) time,
         % and O(min(card(SetA)), card(SetB)) space.
         %
     :- func intersect(tree_bitset(T), tree_bitset(T)) = tree_bitset(T).
     :- pred intersect(tree_bitset(T)::in, tree_bitset(T)::in, tree_bitset(T)::out)
         is det.

         % `difference(SetA, SetB)' returns the set containing all the elements
         % of `SetA' except those that occur in `SetB'. Takes somewhere between
         % O(log(card(SetA)) + log(card(SetB))) and O(card(SetA) + card(SetB)) time,
         % and O(card(SetA)) space.
         %
     :- func difference(tree_bitset(T), tree_bitset(T)) = tree_bitset(T).
     :- pred difference(tree_bitset(T)::in, tree_bitset(T)::in, tree_bitset(T)::out)
         is det.

         % `count(Set)' returns the number of elements in `Set'.
         % Takes O(card(Set)) time.
         %
     :- func count(tree_bitset(T)) = int <= enum(T).

         % `foldl(Func, Set, Start)' calls Func with each element of `Set'
         % (in sorted order) and an accumulator (with the initial value of `Start'),
         % and returns the final value. Takes O(card(Set)) time.
         %
     :- func foldl(func(T, U) = U, tree_bitset(T), U) = U <= enum(T).

     :- pred foldl(pred(T, U, U), tree_bitset(T), U, U) <= enum(T).
     :- mode foldl(pred(in, di, uo) is det, in, di, uo) is det.
     :- mode foldl(pred(in, in, out) is det, in, in, out) is det.
     :- mode foldl(pred(in, in, out) is semidet, in, in, out) is semidet.
     :- mode foldl(pred(in, in, out) is nondet, in, in, out) is nondet.
     :- mode foldl(pred(in, di, uo) is cc_multi, in, di, uo) is cc_multi.
     :- mode foldl(pred(in, in, out) is cc_multi, in, in, out) is cc_multi.

     :- pred foldl2(pred(T, U, U, V, V), tree_bitset(T), U, U, V, V) <= enum(T).
     :- mode foldl2(pred(in, di, uo, di, uo) is det, in, di, uo, di, uo) is det.
     :- mode foldl2(pred(in, in, out, di, uo) is det, in, in, out, di, uo) is det.
     :- mode foldl2(pred(in, in, out, in, out) is det, in, in, out, in, out) is det.
     :- mode foldl2(pred(in, in, out, in, out) is semidet, in, in, out, in, out)
         is semidet.
     :- mode foldl2(pred(in, in, out, in, out) is nondet, in, in, out, in, out)
         is nondet.
     :- mode foldl2(pred(in, di, uo, di, uo) is cc_multi, in, di, uo, di, uo)
         is cc_multi.
     :- mode foldl2(pred(in, in, out, di, uo) is cc_multi, in, in, out, di, uo)
         is cc_multi.
     :- mode foldl2(pred(in, in, out, in, out) is cc_multi, in, in, out, in, out)
         is cc_multi.

         % `foldr(Func, Set, Start)' calls Func with each element of `Set'
         % (in reverse sorted order) and an accumulator (with the initial value
         % of `Start'), and returns the final value. Takes O(card(Set)) time.
         %
     :- func foldr(func(T, U) = U, tree_bitset(T), U) = U <= enum(T).

     :- pred foldr(pred(T, U, U), tree_bitset(T), U, U) <= enum(T).
     :- mode foldr(pred(in, di, uo) is det, in, di, uo) is det.
     :- mode foldr(pred(in, in, out) is det, in, in, out) is det.
     :- mode foldr(pred(in, in, out) is semidet, in, in, out) is semidet.
     :- mode foldr(pred(in, in, out) is nondet, in, in, out) is nondet.
     :- mode foldr(pred(in, di, uo) is cc_multi, in, di, uo) is cc_multi.
     :- mode foldr(pred(in, in, out) is cc_multi, in, in, out) is cc_multi.

     :- pred foldr2(pred(T, U, U, V, V), tree_bitset(T), U, U, V, V) <= enum(T).
     :- mode foldr2(pred(in, di, uo, di, uo) is det, in, di, uo, di, uo) is det.
     :- mode foldr2(pred(in, in, out, di, uo) is det, in, in, out, di, uo) is det.
     :- mode foldr2(pred(in, in, out, in, out) is det, in, in, out, in, out) is det.
     :- mode foldr2(pred(in, in, out, in, out) is semidet, in, in, out, in, out)
         is semidet.
     :- mode foldr2(pred(in, in, out, in, out) is nondet, in, in, out, in, out)
         is nondet.
     :- mode foldr2(pred(in, di, uo, di, uo) is cc_multi, in, di, uo, di, uo)
         is cc_multi.
     :- mode foldr2(pred(in, in, out, di, uo) is cc_multi, in, in, out, di, uo)
         is cc_multi.
     :- mode foldr2(pred(in, in, out, in, out) is cc_multi, in, in, out, in, out)
         is cc_multi.

         % `filter(Pred, Set)' removes those elements from `Set' for which
         % `Pred' fails. In other words, it returns the set consisting of those
         % elements of `Set' for which `Pred' succeeds.
         %
     :- func filter(pred(T), tree_bitset(T)) = tree_bitset(T) <= enum(T).
     :- mode filter(pred(in) is semidet, in) = out is det.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: type_desc,  Next: unit,  Prev: tree_bitset,  Up: Top

94 type_desc
************

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 2002-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: type_desc.m.
     % Main author: fjh, zs.
     % Stability: low.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module type_desc.
     :- interface.

     :- import_module list.

     %--------------------------------------------------%

         % The `type_desc', `pseudo_type_desc' and `type_ctor_desc' types
         % provide access to type information.
         % A type_desc represents a type, e.g. `list(int)'.
         % A pseudo_type_desc represents a type that possibly contains type
         % variables, e.g. `list(T)'.
         % A type_ctor_desc represents a type constructor, e.g. `list/1'.
         %
     :- type type_desc.
     :- type pseudo_type_desc.
     :- type type_ctor_desc.

         % The possibly nonground type represented by a pseudo_type_desc
         % is either a type constructor applied to zero or more
         % pseudo_type_descs, or a type variable. If the latter, the
         % type variable may be either universally or existentially quantified.
         % In either case, the type is identified by an integer, which has no
         % meaning beyond the fact that two type variables will be represented
         % by identical integers if and only if they are the same type variable.
         % Existentially quantified type variables may have type class
         % constraints placed on them, but for now we can't return these.
         %
     :- type pseudo_type_rep
         --->    bound(type_ctor_desc, list(pseudo_type_desc))
         ;       univ_tvar(int)
         ;       exist_tvar(int).

     :- pred pseudo_type_desc_is_ground(pseudo_type_desc::in) is semidet.

         % This function allows the caller to look into the structure
         % of the given pseudo_type_desc.
         %
     :- func pseudo_type_desc_to_rep(pseudo_type_desc) = pseudo_type_rep.

         % Convert a type_desc, which by definition describes a ground type,
         % to a pseudo_type_desc.
         %
     :- func type_desc_to_pseudo_type_desc(type_desc) = pseudo_type_desc.

         % Convert a pseudo_type_desc describing a ground type to a type_desc.
         % If the pseudo_type_desc describes a non-ground type, fail.
         %
     :- func ground_pseudo_type_desc_to_type_desc(pseudo_type_desc) = type_desc
         is semidet.

         % Convert a pseudo_type_desc describing a ground type to a type_desc.
         % If the pseudo_type_desc describes a non-ground type, abort.
         %
     :- func ground_pseudo_type_desc_to_type_desc_det(pseudo_type_desc) = type_desc
         is det.

         % The function type_of/1 returns a representation of the type
         % of its argument.
         %
         % (Note: it is not possible for the type of a variable to be an unbound
         % type variable; if there are no constraints on a type variable, then the
         % typechecker will use the type `void'. `void' is a special (builtin) type
         % that has no constructors. There is no way of creating an object of
         % type `void'. `void' is not considered to be a discriminated union, so
         % get_functor/5 and construct/3 will fail if used upon a value of
         % this type.)
         %
     :- func type_of(T::unused) = (type_desc::out) is det.

         % The predicate has_type/2 is basically an existentially typed inverse
         % to the function type_of/1. It constrains the type of the first argument
         % to be the type represented by the second argument.
         %
     :- some [T] pred has_type(T::unused, type_desc::in) is det.

         % The predicate same_type/2 ensures type identity of the two arguments.
         %
     :- pred same_type(T::unused, T::unused) is det.

         % type_name(Type) returns the name of the specified type
         % (e.g. type_name(type_of([2,3])) = "list.list(int)").
         % Any equivalence types will be fully expanded.
         % Builtin types (those defined in builtin.m) will not have
         % a module qualifier.
         %
     :- func type_name(type_desc) = string.

         % type_ctor_and_args(Type, TypeCtor, TypeArgs):
         %
         % True iff `TypeCtor' is a representation of the top-level type constructor
         % for `Type', and `TypeArgs' is a list of the corresponding type arguments
         % to `TypeCtor', and `TypeCtor' is not an equivalence type.
         %
         % For example, type_ctor_and_args(type_of([2,3]), TypeCtor, TypeArgs)
         % will bind `TypeCtor' to a representation of the type constructor list/1,
         % and will bind `TypeArgs' to the list `[Int]', where `Int' is a
         % representation of the type `int'.
         %
         % Note that the requirement that `TypeCtor' not be an equivalence type
         % is fulfilled by fully expanding any equivalence types. For example,
         % if you have a declaration `:- type foo == bar.', then
         % type_ctor_and_args/3 will always return a representation of type
         % constructor `bar/0', not `foo/0'. (If you don't want them expanded,
         %% you can use the reverse mode of make_type/2 instead.)
         %
     :- pred type_ctor_and_args(type_desc::in,
         type_ctor_desc::out, list(type_desc)::out) is det.

         % pseudo_type_ctor_and_args(Type, TypeCtor, TypeArgs):
         %
         % True iff `TypeCtor' is a representation of the top-level type constructor
         % for `Type', and `TypeArgs' is a list of the corresponding type arguments
         % to `TypeCtor', and `TypeCtor' is not an equivalence type.
         %
         % Similar to type_ctor_and_args, but works on pseudo_type_infos.
         % Fails if the input pseudo_type_info is a variable.
         %
     :- pred pseudo_type_ctor_and_args(pseudo_type_desc::in,
         type_ctor_desc::out, list(pseudo_type_desc)::out) is semidet.

         % type_ctor(Type) = TypeCtor :-
         %   type_ctor_and_args(Type, TypeCtor, _).
         %
     :- func type_ctor(type_desc) = type_ctor_desc.

         % pseudo_type_ctor(Type) = TypeCtor :-
         %   pseudo_type_ctor_and_args(Type, TypeCtor, _).
         %
     :- func pseudo_type_ctor(pseudo_type_desc) = type_ctor_desc is semidet.

         % type_args(Type) = TypeArgs :-
         %   type_ctor_and_args(Type, _, TypeArgs).
         %
     :- func type_args(type_desc) = list(type_desc).

         % pseudo_type_args(Type) = TypeArgs :-
         %   pseudo_type_ctor_and_args(Type, _, TypeArgs).
         %
     :- func pseudo_type_args(pseudo_type_desc) = list(pseudo_type_desc) is semidet.

         % type_ctor_name(TypeCtor) returns the name of specified type constructor.
         % (e.g. type_ctor_name(type_ctor(type_of([2,3]))) = "list").
         %
     :- func type_ctor_name(type_ctor_desc) = string.

         % type_ctor_module_name(TypeCtor) returns the module name of specified
         % type constructor.
         % (e.g. type_ctor_module_name(type_ctor(type_of(2))) = "builtin").
         %
     :- func type_ctor_module_name(type_ctor_desc) = string.

         % type_ctor_arity(TypeCtor) returns the arity of specified
         % type constructor.
         % (e.g. type_ctor_arity(type_ctor(type_of([2,3]))) = 1).
         %
     :- func type_ctor_arity(type_ctor_desc) = int.

         % type_ctor_name_and_arity(TypeCtor, ModuleName, TypeName, Arity) :-
         %   Name = type_ctor_name(TypeCtor),
         %   ModuleName = type_ctor_module_name(TypeCtor),
         %   Arity = type_ctor_arity(TypeCtor).
         %
     :- pred type_ctor_name_and_arity(type_ctor_desc::in,
         string::out, string::out, int::out) is det.

         % make_type(TypeCtor, TypeArgs) = Type:
         %
         % True iff `Type' is a type constructed by applying the type constructor
         % `TypeCtor' to the type arguments `TypeArgs'.
         %
         % Operationally, the forwards mode returns the type formed by applying
         % the specified type constructor to the specified argument types, or fails
         % if the length of TypeArgs is not the same as the arity of TypeCtor.
         % The reverse mode returns a type constructor and its argument types,
         % given a type_desc; the type constructor returned may be an equivalence
         % type (and hence this reverse mode of make_type/2 may be more useful
         % for some purposes than the type_ctor/1 function).
         %
     :- func make_type(type_ctor_desc, list(type_desc)) = type_desc.
     :- mode make_type(in, in) = out is semidet.
     :- mode make_type(out, out) = in is cc_multi.

         % det_make_type(TypeCtor, TypeArgs):
         %
         % Returns the type formed by applying the specified type constructor
         % to the specified argument types. Aborts if the length of `TypeArgs'
         % is not the same as the arity of `TypeCtor'.
         %
     :- func det_make_type(type_ctor_desc, list(type_desc)) = type_desc.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: unit,  Next: univ,  Prev: type_desc,  Up: Top

95 unit
*******

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1994-2006 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: unit.m.
     % Main author: fjh.
     % Stability: high.
     %
     % The "unit" type -  stores no information at all.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module unit.
     :- interface.

     %--------------------------------------------------%

     :- type unit ---> unit.

     :- type unit(T) ---> unit1.

     %--------------------------------------------------%
     :- end_module unit.
     %--------------------------------------------------%


File: mercury_library.info,  Node: univ,  Next: varset,  Prev: unit,  Up: Top

96 univ
*******

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1994-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: univ.m.
     % Main author: fjh.
     % Stability: medium.
     %
     % The universal type `univ'
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module univ.
     :- interface.

     :- import_module type_desc.

     %--------------------------------------------------%

         % An object of type `univ' can hold the type and value of an object of any
         % other type.
         %
     :- type univ.

         % type_to_univ(Object, Univ).
         %
         % True iff the type stored in `Univ' is the same as the type of `Object',
         % and the value stored in `Univ' is equal to the value of `Object'.
         %
         % Operational, the forwards mode converts an object to type `univ',
         % while the reverse mode converts the value stored in `Univ'
         % to the type of `Object', but fails if the type stored in `Univ'
         % does not match the type of `Object'.
         %
     :- pred type_to_univ(T, univ).
     :- mode type_to_univ(di, uo) is det.
     :- mode type_to_univ(in, out) is det.
     :- mode type_to_univ(out, in) is semidet.

         % univ_to_type(Univ, Object) :- type_to_univ(Object, Univ).
         %
     :- pred univ_to_type(univ, T).
     :- mode univ_to_type(in, out) is semidet.
     :- mode univ_to_type(out, in) is det.
     :- mode univ_to_type(uo, di) is det.

         % The function univ/1 provides the same functionality as type_to_univ/2.
         % univ(Object) = Univ :- type_to_univ(Object, Univ).
         %
     :- func univ(T) = univ.
     :- mode univ(in) = out is det.
     :- mode univ(di) = uo is det.
     :- mode univ(out) = in is semidet.

         % det_univ_to_type(Univ, Object).
         %
         % The same as the forwards mode of univ_to_type, but aborts
         % if univ_to_type fails.
         %
     :- pred det_univ_to_type(univ::in, T::out) is det.

         % univ_type(Univ).
         %
         % Returns the type_desc for the type stored in `Univ'.
         %
     :- func univ_type(univ) = type_desc.

         % univ_value(Univ).
         %
         % Returns the value of the object stored in Univ.
         %
     :- some [T] func univ_value(univ) = T.

     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: varset,  Next: version_array2d,  Prev: univ,  Up: Top

97 varset
*********

     %--------------------------------------------------%
     % vim: ft=mercury ts=4 sw=4 et wm=0 tw=0
     %--------------------------------------------------%
     % Copyright (C) 1993-2000,2002-2007 The University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: varset.m.
     % Main author: fjh.
     % Stability: low.
     %
     % This file provides facilities for manipulating collections of
     % variables and terms.
     % It provides the 'varset' ADT. A varset is a set of variables.
     % (These variables are object-level variables, and are represented
     % as ground terms, so it might help to think of them as "variable ids"
     % rather than variables.)
     % Associated with each variable there can be both a name and a value
     % (binding).
     %
     % There may be some design flaws in the relationship between varset.m,
     % term.m, and graph.m.  Once we have implemented unique modes and
     % destructive assignment, we will need to rethink the design;  we may
     % end up modifying these modules considerably, or we may end up
     % making new single-threaded versions of these modules.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%

     :- module varset.
     :- interface.

     :- import_module assoc_list.
     :- import_module list.
     :- import_module map.
     :- import_module maybe.
     :- import_module set.
     :- import_module term.

     %--------------------------------------------------%

     :- type varset(T).

     :- type varset  ==  varset(generic).

         % Construct an empty varset.
         %
     :- func varset.init = varset(T).
     :- pred varset.init(varset(T)::out) is det.

         % Check whether a varset is empty.
         %
     :- pred varset.is_empty(varset(T)::in) is semidet.

         % Create a new variable.
         %
     :- pred varset.new_var(varset(T)::in, var(T)::out, varset(T)::out) is det.

         % Create a new named variable.
         %
     :- pred varset.new_named_var(varset(T)::in, string::in, var(T)::out,
         varset(T)::out) is det.

         % Create a new named variable with a unique (w.r.t. the
         % varset) number appended to the name.
         %
     :- pred varset.new_uniquely_named_var(varset(T)::in, string::in, var(T)::out,
         varset(T)::out) is det.

         % Create a new variable, and maybe give it a name.
         %
     :- pred varset.new_maybe_named_var(varset(T)::in, maybe(string)::in,
         var(T)::out, varset(T)::out) is det.

         % Create multiple new variables.
         %
     :- pred varset.new_vars(varset(T)::in, int::in, list(var(T))::out,
         varset(T)::out) is det.

         % Delete the name and value for a variable.
         %
     :- func varset.delete_var(varset(T), var(T)) = varset(T).
     :- pred varset.delete_var(varset(T)::in, var(T)::in, varset(T)::out) is det.

         % Delete the names and values for a list of variables.
         %
     :- func varset.delete_vars(varset(T), list(var(T))) = varset(T).
     :- pred varset.delete_vars(varset(T)::in, list(var(T))::in, varset(T)::out)
         is det.

         % Return a list of all the variables in a varset.
         %
     :- func varset.vars(varset(T)) = list(var(T)).
     :- pred varset.vars(varset(T)::in, list(var(T))::out) is det.

         % Set the name of a variable.
         %
     :- func varset.name_var(varset(T), var(T), string) = varset(T).
     :- pred varset.name_var(varset(T)::in, var(T)::in, string::in, varset(T)::out)
         is det.

         % Lookup the name of a variable;
         % create one if it doesn't have one using V_ as a prefix.
         %
     :- func varset.lookup_name(varset(T), var(T)) = string.
     :- pred varset.lookup_name(varset(T)::in, var(T)::in, string::out) is det.

         % Lookup the name of a variable;
         % create one if it doesn't have one using the specified prefix
         %
     :- func varset.lookup_name(varset(T), var(T), string) = string.
     :- pred varset.lookup_name(varset(T)::in, var(T)::in, string::in, string::out)
         is det.

         % Lookup the name of a variable;
         % fail if it doesn't have one
         %
     :- pred varset.search_name(varset(T)::in, var(T)::in, string::out) is semidet.

         % Bind a value to a variable.
         % This will overwrite any existing binding.
         %
     :- func varset.bind_var(varset(T), var(T), term(T)) = varset(T).
     :- pred varset.bind_var(varset(T)::in, var(T)::in, term(T)::in,
         varset(T)::out) is det.

         % Bind a set of terms to a set of variables.
         %
     :- func varset.bind_vars(varset(T), substitution(T)) = varset(T).
     :- pred varset.bind_vars(varset(T)::in, substitution(T)::in, varset(T)::out)
         is det.

         % Lookup the value of a variable.
         %
     :- pred varset.search_var(varset(T)::in, var(T)::in, term(T)::out) is semidet.

         % Get the bindings for all the bound variables.
         %
     :- func varset.lookup_vars(varset(T)) = substitution(T).
     :- pred varset.lookup_vars(varset(T)::in, substitution(T)::out) is det.

         % Combine two different varsets, renaming apart:
         % varset.merge_renaming(VarSet0, NewVarSet, VarSet, Subst) is true
         % iff VarSet is the varset that results from joining a suitably renamed
         % version of NewVarSet to VarSet0. (Any bindings in NewVarSet are ignored.)
         % Renaming map the variables in NewVarSet into the corresponding
         % fresh variable in VarSet.
         %
     :- pred varset.merge_renaming(varset(T)::in, varset(T)::in, varset(T)::out,
         map(var(T), var(T))::out) is det.

         % Does the same job as varset.merge_renaming, but returns the renaming
         % as a general substitution in which all the terms in the range happen
         % to be variables.
         %
         % Consider using varset.merge_renaming instead.
         %
     :- pred varset.merge_subst(varset(T)::in, varset(T)::in, varset(T)::out,
         substitution(T)::out) is det.

         % varset.merge(VarSet0, NewVarSet, Terms0, VarSet, Terms):
         %
         % As varset.merge_renaming, except instead of returning the renaming,
         % this predicate applies it to the given list of terms.
         %
     :- pred varset.merge(varset(T)::in, varset(T)::in, list(term(T))::in,
         varset(T)::out, list(term(T))::out) is det.

         % Same as varset.merge_renaming, except that the names of variables
         % in NewVarSet are not included in the final varset.
         % This is useful if varset.create_name_var_map needs to be used
         % on the resulting varset.
         %
     :- pred varset.merge_renaming_without_names(varset(T)::in,
         varset(T)::in, varset(T)::out, map(var(T), var(T))::out) is det.

         % Same as varset.merge_subst, except that the names of variables
         % in NewVarSet are not included in the final varset.
         % This is useful if varset.create_name_var_map needs to be used
         % on the resulting varset.
         %
         % Consider using varset.merge_renaming_without_names instead.
         %
     :- pred varset.merge_subst_without_names(varset(T)::in,
         varset(T)::in, varset(T)::out, substitution(T)::out) is det.

         % Same as varset.merge, except that the names of variables
         % in NewVarSet are not included in the final varset.
         % This is useful if varset.create_name_var_map needs to be used
         % on the resulting varset.
         %
     :- pred varset.merge_without_names(varset(T)::in, varset(T)::in,
         list(term(T))::in, varset(T)::out, list(term(T))::out) is det.

         % Get the bindings for all the bound variables.
         %
     :- func varset.get_bindings(varset(T)) = substitution(T).
     :- pred varset.get_bindings(varset(T)::in, substitution(T)::out) is det.

         % Set the bindings for all the bound variables.
         %
     :- func varset.set_bindings(varset(T), substitution(T)) = varset(T).
     :- pred varset.set_bindings(varset(T)::in, substitution(T)::in,
         varset(T)::out) is det.

         % Create a map from names to variables.
         % Each name is mapped to only one variable, even if a name is
         % shared by more than one variable. Therefore this predicate
         % is only really useful if it is already known that no two
         % variables share the same name.
         %
     :- func varset.create_name_var_map(varset(T)) = map(string, var(T)).
     :- pred varset.create_name_var_map(varset(T)::in, map(string, var(T))::out)
         is det.

         % Return an association list giving the name of each variable.
         % Every variable has an entry in the returned association list,
         % even if it shares its name with another variable.
         %
     :- func varset.var_name_list(varset(T)) = assoc_list(var(T), string).
     :- pred varset.var_name_list(varset(T)::in, assoc_list(var(T), string)::out)
         is det.

         % Given a list of variable and varset in which some variables have
         % no name but some other variables may have the same name,
         % return another varset in which every variable has a unique name.
         % If necessary, names will have suffixes added on the end;
         % the second argument gives the suffix to use.
         %
     :- func varset.ensure_unique_names(list(var(T)), string, varset(T))
         = varset(T).
     :- pred varset.ensure_unique_names(list(var(T))::in,
         string::in, varset(T)::in, varset(T)::out) is det.

         % Given a varset and a set of variables, remove the names
         % and values of any other variables stored in the varset.
         %
     :- func varset.select(varset(T), set(var(T))) = varset(T).
     :- pred varset.select(varset(T)::in, set(var(T))::in, varset(T)::out) is det.

         % Given a varset and a list of variables, construct a new varset
         % containing one variable for each one in the list (and no others).
         % Also return a substitution mapping the selected variables in the
         % original varset into variables in the new varset. The relative
         % ordering of variables in the original varset is maintained.
         %
     :- pred varset.squash(varset(T)::in, list(var(T))::in,
         varset(T)::out, map(var(T), var(T))::out) is det.

         % Coerce the types of the variables in a varset.
         %
     :- func varset.coerce(varset(T)) = varset(U).
     :- pred varset.coerce(varset(T)::in, varset(U)::out) is det.

     %--------------------------------------------------%
     %--------------------------------------------------%

