This is mercury_ref.info, produced by makeinfo version 4.13 from
reference_manual.texi_pp.

INFO-DIR-SECTION The Mercury Programming Language
START-INFO-DIR-ENTRY
* Mercury Language: (mercury_ref).  The Mercury Language Reference Manual.
END-INFO-DIR-ENTRY

   This file documents the Mercury programming language, version
rotd-2013-10-01.

   Copyright (C) 1995-2013 The University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


Indirect:
mercury_ref.info-1: 969
mercury_ref.info-2: 300805

Tag Table:
(Indirect)
Node: Top969
Node: Introduction3304
Node: Syntax5214
Node: Syntax Overview5596
Node: Tokens6367
Node: Terms12038
Node: Builtin Operators15520
Ref: Builtin Operators-Footnote-123107
Node: Items23146
Node: Declarations23918
Node: Facts24767
Node: Rules25549
Node: Goals26281
Node: State variables38312
Node: DCG-rules45303
Node: DCG-goals46590
Node: Data-terms51295
Node: Data-functors52407
Node: Record syntax54082
Node: Unification expressions57143
Node: Conditional expressions58212
Node: Lambda expressions58917
Node: Higher-order function applications61087
Node: Explicit type qualification61830
Node: Variable scoping62729
Node: Implicit quantification64784
Node: Elimination of double negation66200
Node: Types67112
Node: Builtin types67507
Node: User-defined types69147
Node: Discriminated unions69512
Node: Equivalence types73633
Node: Abstract types74530
Node: Predicate and function type declarations75266
Ref: Predicate and function type declarations-Footnote-181111
Node: Field access functions81494
Node: Field selection82294
Node: Field update83344
Node: User-supplied field access function declarations85105
Node: Field access examples87145
Node: Modes88881
Node: Insts modes and mode definitions89151
Node: Predicate and function mode declarations94697
Node: Constrained polymorphic modes101247
Node: Different clauses for different modes103955
Node: Unique modes108188
Node: Destructive update109395
Node: Backtrackable destructive update110820
Node: Limitations of the current implementation112350
Node: Determinism113280
Node: Determinism categories113660
Node: Determinism checking and inference118668
Node: Replacing compile-time checking with run-time checking127481
Node: Interfacing nondeterministic code with the real world129938
Node: Committed choice nondeterminism133311
Node: User-defined equality and comparison136244
Ref: User-defined equality and comparison-Footnote-1143779
Node: Higher-order144159
Node: Creating higher-order terms144810
Node: Calling higher-order terms149651
Node: Higher-order modes152692
Node: Modules156747
Node: The module system157017
Node: An example module160845
Node: Sub-modules162115
Node: Nested sub-modules162849
Node: Separate sub-modules164388
Node: Visibility rules166887
Node: Implementation bugs and limitations168210
Node: Module initialisation168907
Node: Module finalisation170442
Node: Module-local mutable variables171821
Node: Type classes176744
Node: Typeclass declarations177451
Node: Instance declarations180293
Node: Abstract typeclass declarations187578
Node: Abstract instance declarations188587
Node: Type class constraints on predicates and functions190165
Node: Type class constraints on type class declarations191853
Node: Type class constraints on instance declarations193876
Node: Functional dependencies195914
Node: Existential types201901
Node: Existentially typed predicates and functions202733
Node: Syntax for explicit type quantifiers203166
Node: Semantics of type quantifiers204709
Node: Examples of correct code using type quantifiers207563
Node: Examples of incorrect code using type quantifiers208846
Node: Existential class constraints209895
Node: Existentially typed data types211420
Node: Some idioms using existentially quantified types215068
Node: Exception handling219163
Node: Semantics223432
Node: Foreign language interface230540
Node: Calling foreign code from Mercury232209
Node: pragma foreign_proc232717
Node: Foreign code attributes237618
Node: Calling Mercury from foreign code245597
Node: Data passing conventions246658
Node: C data passing conventions247266
Node: C# data passing conventions251021
Node: Java data passing conventions255924
Node: Erlang data passing conventions261422
Node: Using foreign types from Mercury263740
Node: Using Mercury enumerations in foreign code267642
Node: Using foreign enumerations in Mercury code271327
Node: Adding foreign declarations273084
Node: Adding foreign definitions276587
Node: Language specific bindings277534
Node: Interfacing with C278628
Node: Using pragma foreign_type for C279645
Node: Using pragma foreign_export_enum for C282723
Node: Using pragma foreign_enum for C283707
Node: Using pragma foreign_proc for C284150
Node: Using pragma foreign_export for C286730
Node: Using pragma foreign_decl for C289364
Node: Using pragma foreign_code for C290932
Node: Memory management for C291495
Node: Linking with C object files293628
Node: Interfacing with C#295043
Node: Using pragma foreign_type for C#295812
Node: Using pragma foreign_export_enum for C#296517
Node: Using pragma foreign_enum for C#297203
Node: Using pragma foreign_proc for C#297617
Node: Using pragma foreign_export for C#299379
Node: Using pragma foreign_decl for C#300805
Node: Using pragma foreign_code for C#301671
Node: Interfacing with Java302658
Node: Using pragma foreign_type for Java303497
Node: Using pragma foreign_export_enum for Java304238
Node: Using pragma foreign_enum for Java305092
Node: Using pragma foreign_proc for Java305431
Node: Using pragma foreign_export for Java307261
Node: Using pragma foreign_decl for Java308715
Node: Using pragma foreign_code for Java309814
Node: Interfacing with Erlang310825
Node: Using pragma foreign_type for Erlang311405
Node: Using pragma foreign_proc for Erlang311944
Node: Using pragma foreign_export for Erlang313137
Node: Using pragma foreign_decl for Erlang314616
Node: Using pragma foreign_code for Erlang315677
Node: Impurity316468
Node: Purity levels318803
Node: Purity ordering320720
Node: Impurity semantics321019
Node: Declaring impurity323425
Node: Impure goals324818
Node: Promising purity326442
Node: Impurity Example328830
Node: Higher-order impurity330286
Node: Purity annotations on higher-order types330915
Node: Purity annotations on lambda expressions332007
Node: Purity annotations on higher-order calls333047
Node: Solver types334381
Node: The any inst335308
Node: Abstract solver type declarations336316
Node: Solver type definitions336796
Node: Implementing solver types341142
Node: Solver types and negated contexts342540
Node: Trace goals345252
Node: Pragmas354367
Node: Inlining355726
Node: Type specialization356436
Node: Syntax and semantics of type specialization pragmas357081
Node: When to use type specialization358341
Node: Implementation specific details359305
Node: Obsolescence359800
Node: No determinism warnings360940
Node: Source file name362121
Node: Implementation-dependent extensions363789
Node: Fact tables364739
Node: Tabled evaluation366336
Node: Termination analysis378305
Node: Feature sets382539
Node: Trailing385355
Node: Choice points386769
Node: Value trailing387718
Node: Function trailing388857
Node: Delayed goals and floundering392181
Node: Avoiding redundant trailing393923
Node: Bibliography400787
Node: [1]401446
Node: [2]401872
Node: [3]402223
Node: [4]402556
Node: [5]402869

End Tag Table
