This is mercury_ref.info, produced by makeinfo version 4.11 from
reference_manual.texi_pp.

INFO-DIR-SECTION The Mercury Programming Language
START-INFO-DIR-ENTRY
* Mercury Language: (mercury_ref).  The Mercury Language Reference Manual.
END-INFO-DIR-ENTRY

   This file documents the Mercury programming language, version
11.07-beta-2011-07-20.

   Copyright (C) 1995-2011 The University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


Indirect:
mercury_ref.info-1: 975
mercury_ref.info-2: 300782

Tag Table:
(Indirect)
Node: Top975
Node: Introduction3322
Node: Syntax5232
Node: Syntax Overview5614
Node: Tokens6385
Node: Terms12056
Node: Builtin Operators15538
Ref: Builtin Operators-Footnote-123125
Node: Items23164
Node: Declarations23936
Node: Facts24785
Node: Rules25567
Node: Goals26299
Node: State variables38330
Node: DCG-rules45321
Node: DCG-goals46608
Node: Data-terms51313
Node: Data-functors52425
Node: Record syntax54100
Node: Unification expressions57161
Node: Conditional expressions58230
Node: Lambda expressions58935
Node: Higher-order function applications61105
Node: Explicit type qualification61848
Node: Variable scoping62747
Node: Implicit quantification64802
Node: Elimination of double negation66218
Node: Types67130
Node: Builtin types67525
Node: User-defined types69165
Node: Discriminated unions69530
Node: Equivalence types73651
Node: Abstract types74548
Node: Predicate and function type declarations75284
Ref: Predicate and function type declarations-Footnote-181129
Node: Field access functions81512
Node: Field selection82312
Node: Field update83362
Node: User-supplied field access function declarations85123
Node: Field access examples87163
Node: Modes88899
Node: Insts modes and mode definitions89169
Node: Predicate and function mode declarations94701
Node: Constrained polymorphic modes101251
Node: Different clauses for different modes103959
Node: Unique modes108192
Node: Destructive update109399
Node: Backtrackable destructive update110824
Node: Limitations of the current implementation112354
Node: Determinism113284
Node: Determinism categories113664
Node: Determinism checking and inference118672
Node: Replacing compile-time checking with run-time checking127485
Node: Interfacing nondeterministic code with the real world129942
Node: Committed choice nondeterminism133315
Node: User-defined equality and comparison136248
Ref: User-defined equality and comparison-Footnote-1143783
Node: Higher-order144163
Node: Creating higher-order terms144814
Node: Calling higher-order terms149655
Node: Higher-order modes152696
Node: Modules156751
Node: The module system157021
Node: An example module160849
Node: Sub-modules162119
Node: Nested sub-modules162853
Node: Separate sub-modules164392
Node: Visibility rules166891
Node: Implementation bugs and limitations168214
Node: Module initialisation168911
Node: Module finalisation170446
Node: Module-local mutable variables171825
Node: Type classes176718
Node: Typeclass declarations177425
Node: Instance declarations180267
Node: Abstract typeclass declarations187560
Node: Abstract instance declarations188569
Node: Type class constraints on predicates and functions190147
Node: Type class constraints on type class declarations191835
Node: Type class constraints on instance declarations193858
Node: Functional dependencies195896
Node: Existential types201883
Node: Existentially typed predicates and functions202715
Node: Syntax for explicit type quantifiers203148
Node: Semantics of type quantifiers204691
Node: Examples of correct code using type quantifiers207545
Node: Examples of incorrect code using type quantifiers208828
Node: Existential class constraints209877
Node: Existentially typed data types211402
Node: Some idioms using existentially quantified types215050
Node: Exception handling219145
Node: Semantics223409
Node: Foreign language interface230517
Node: Calling foreign code from Mercury232186
Node: pragma foreign_proc232694
Node: Foreign code attributes237595
Node: Calling Mercury from foreign code245574
Node: Data passing conventions246635
Node: C data passing conventions247243
Node: C# data passing conventions250998
Node: Java data passing conventions255901
Node: Erlang data passing conventions261399
Node: Using foreign types from Mercury263717
Node: Using Mercury enumerations in foreign code267619
Node: Using foreign enumerations in Mercury code271304
Node: Adding foreign declarations273061
Node: Adding foreign definitions276564
Node: Language specific bindings277511
Node: Interfacing with C278605
Node: Using pragma foreign_type for C279622
Node: Using pragma foreign_export_enum for C282700
Node: Using pragma foreign_enum for C283684
Node: Using pragma foreign_proc for C284127
Node: Using pragma foreign_export for C286707
Node: Using pragma foreign_decl for C289341
Node: Using pragma foreign_code for C290909
Node: Memory management for C291472
Node: Linking with C object files293605
Node: Interfacing with C#295020
Node: Using pragma foreign_type for C#295789
Node: Using pragma foreign_export_enum for C#296494
Node: Using pragma foreign_enum for C#297180
Node: Using pragma foreign_proc for C#297594
Node: Using pragma foreign_export for C#299356
Node: Using pragma foreign_decl for C#300782
Node: Using pragma foreign_code for C#301648
Node: Interfacing with Java302635
Node: Using pragma foreign_type for Java303474
Node: Using pragma foreign_export_enum for Java304215
Node: Using pragma foreign_enum for Java305069
Node: Using pragma foreign_proc for Java305408
Node: Using pragma foreign_export for Java307238
Node: Using pragma foreign_decl for Java308692
Node: Using pragma foreign_code for Java309791
Node: Interfacing with Erlang310802
Node: Using pragma foreign_type for Erlang311382
Node: Using pragma foreign_proc for Erlang311921
Node: Using pragma foreign_export for Erlang313114
Node: Using pragma foreign_decl for Erlang314593
Node: Using pragma foreign_code for Erlang315654
Node: Impurity316445
Node: Purity levels318780
Node: Purity ordering320697
Node: Impurity semantics320996
Node: Declaring impurity323402
Node: Impure goals324795
Node: Promising purity326419
Node: Impurity Example328807
Node: Higher-order impurity330263
Node: Purity annotations on higher-order types330892
Node: Purity annotations on lambda expressions331984
Node: Purity annotations on higher-order calls333024
Node: Solver types334358
Node: The any inst335285
Node: Abstract solver type declarations336293
Node: Solver type definitions336773
Node: Implementing solver types341119
Node: Solver types and negated contexts342517
Node: Trace goals345229
Node: Pragmas354344
Node: Inlining355703
Node: Type specialization356413
Node: Syntax and semantics of type specialization pragmas357058
Node: When to use type specialization358318
Node: Implementation specific details359282
Node: Obsolescence359777
Node: No determinism warnings360917
Node: Source file name362098
Node: Implementation-dependent extensions363766
Node: Fact tables364716
Node: Tabled evaluation366313
Node: Termination analysis378282
Node: Feature sets382516
Node: Trailing385332
Node: Choice points386746
Node: Value trailing387695
Node: Function trailing388834
Node: Delayed goals and floundering392158
Node: Avoiding redundant trailing393900
Node: Bibliography400764
Node: [1]401423
Node: [2]401849
Node: [3]402200
Node: [4]402533
Node: [5]402846

End Tag Table
