This is mercury_ref.info, produced by makeinfo version 4.7 from
reference_manual.texi_pp.

INFO-DIR-SECTION The Mercury Programming Language
START-INFO-DIR-ENTRY
* Mercury Language: (mercury_ref).  The Mercury Language Reference Manual.
END-INFO-DIR-ENTRY

   This file documents the Mercury programming language, version
rotd-2007-08-01.

   Copyright (C) 1995-2007 The University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


Indirect:
mercury_ref.info-1: 968
mercury_ref.info-2: 300306

Tag Table:
(Indirect)
Node: Top968
Node: Introduction3257
Node: Syntax5167
Node: Syntax Overview5549
Node: Tokens6320
Node: Terms11485
Node: Builtin Operators14972
Ref: Builtin Operators-Footnote-122205
Node: Items22244
Node: Declarations23016
Node: Facts23850
Node: Rules24632
Node: Goals25364
Node: State variables34422
Node: DCG-rules40779
Node: DCG-goals42065
Node: Data-terms46770
Node: Data-functors47882
Node: Record syntax48492
Node: Unification expressions51553
Node: Conditional expressions52622
Node: Lambda expressions53327
Node: Higher-order function applications55497
Node: Explicit type qualification56240
Node: Variable scoping57139
Node: Implicit quantification59194
Node: Elimination of double negation60610
Node: Types61522
Node: Builtin types61934
Node: User-defined types63574
Node: Discriminated unions63939
Node: Equivalence types68060
Node: Abstract types68957
Node: Predicate and function type declarations69693
Ref: Predicate and function type declarations-Footnote-175562
Node: Field access functions75945
Node: Field selection76766
Node: Field update77816
Node: User-supplied field access function declarations79577
Node: Field access examples81617
Node: Solver types83353
Node: The any inst84307
Node: Abstract solver type declarations85317
Node: Solver type definitions85799
Node: Implementing solver types90418
Node: Solver types and negated contexts91818
Node: Polymorphic solver types92502
Node: Modes92918
Node: Insts modes and mode definitions93188
Node: Predicate and function mode declarations98720
Node: Constrained polymorphic modes105270
Node: Different clauses for different modes107978
Node: Unique modes112211
Node: Destructive update113418
Node: Backtrackable destructive update114843
Node: Limitations of the current implementation116373
Node: Determinism117303
Node: Determinism categories117683
Node: Determinism checking and inference122691
Node: Replacing compile-time checking with run-time checking131504
Node: Interfacing nondeterministic code with the real world133961
Node: Committed choice nondeterminism137334
Node: User-defined equality and comparison140267
Ref: User-defined equality and comparison-Footnote-1147800
Node: Higher-order148180
Node: Creating higher-order terms148831
Node: Calling higher-order terms153239
Node: Higher-order modes156280
Node: Modules159956
Node: The module system160226
Node: An example module164054
Node: Sub-modules165324
Node: Nested sub-modules166058
Node: Separate sub-modules167597
Node: Visibility rules170096
Node: Implementation bugs and limitations171419
Node: Module initialisation172116
Node: Module finalisation173746
Node: Module-local mutable variables175218
Node: Type classes180203
Node: Typeclass declarations180910
Node: Instance declarations183752
Node: Abstract typeclass declarations191045
Node: Abstract instance declarations192054
Node: Type class constraints on predicates and functions193632
Node: Type class constraints on type class declarations195320
Node: Type class constraints on instance declarations197343
Node: Functional dependencies199381
Node: Existential types205368
Node: Existentially typed predicates and functions206191
Node: Syntax for explicit type quantifiers206624
Node: Semantics of type quantifiers208167
Node: Examples of correct code using type quantifiers211021
Node: Examples of incorrect code using type quantifiers212304
Node: Existential class constraints213353
Node: Existentially typed data types214878
Node: Some idioms using existentially quantified types218526
Node: Semantics222621
Node: Foreign language interface229770
Node: Calling foreign code from Mercury231992
Node: pragma foreign_proc232500
Node: Foreign code attributes235764
Node: Calling Mercury from foreign code243780
Node: Data passing conventions244841
Node: C data passing conventions245456
Node: IL and C# data passing conventions249113
Node: Java data passing conventions252032
Node: Erlang data passing conventions254921
Node: Using foreign types from Mercury257214
Node: Using Mercury enumerations in foreign code261088
Node: Adding foreign declarations264207
Node: Adding foreign definitions267401
Node: Language specific bindings268348
Node: Interfacing with C269695
Node: Using pragma foreign_type for C270297
Node: Using pragma foreign_export_enum for C272055
Node: Using pragma foreign_proc for C273039
Node: Using pragma foreign_export for C275488
Node: Using pragma foreign_decl for C278125
Node: Using pragma foreign_code for C279677
Node: Interfacing with C#280208
Node: Using pragma foreign_type for C#280767
Node: Using pragma foreign_proc for C#281264
Node: Using pragma foreign_export for C#283033
Node: Using pragma foreign_decl for C#283359
Node: Using pragma foreign_code for C#284225
Node: Interfacing with IL285212
Node: Using pragma foreign_type for IL285774
Node: Using pragma foreign_proc for IL288207
Node: Using pragma foreign_export for IL289353
Node: Using pragma foreign_decl for IL291973
Node: Using pragma foreign_code for IL292293
Node: Interfacing with Java292570
Node: Using pragma foreign_type for Java293154
Node: Using pragma foreign_proc for Java293709
Node: Using pragma foreign_export for Java295507
Node: Using pragma foreign_decl for Java295847
Node: Using pragma foreign_code for Java296946
Node: Interfacing with Erlang297957
Node: Using pragma foreign_type for Erlang298537
Node: Using pragma foreign_proc for Erlang299076
Node: Using pragma foreign_export for Erlang300306
Node: Using pragma foreign_decl for Erlang301788
Node: Using pragma foreign_code for Erlang302849
Node: C interface303640
Node: Calling C code from Mercury305479
Node: pragma import306434
Node: pragma c_code308550
Node: Nondet pragma c_code312096
Node: C code attributes316838
Node: Purity and side effects318853
Node: Including C headers321320
Node: Including C code322353
Node: Calling Mercury code from C322826
Node: Linking with C object files326135
Node: Passing data to and from C327510
Node: Using C pointers327774
Node: Memory management329167
Node: Trailing331220
Node: Choice points332615
Node: Value trailing333564
Node: Function trailing334452
Node: Delayed goals and floundering337656
Node: Avoiding redundant trailing339398
Node: Impurity346262
Node: Purity levels348566
Node: Purity ordering350483
Node: Impurity semantics350782
Node: Declaring impurity353188
Node: Impure goals354581
Node: Promising purity356205
Node: Impurity Example358593
Node: Higher-order impurity360049
Node: Purity annotations on higher-order types360678
Node: Purity annotations on lambda expressions361770
Node: Purity annotations on higher-order calls362810
Node: Trace goals364144
Node: Pragmas372286
Node: Inlining373468
Node: Type specialization374178
Node: Syntax and semantics of type specialization pragmas374823
Node: When to use type specialization376083
Node: Implementation specific details377047
Node: Obsolescence377542
Node: Source file name378675
Node: Implementation-dependent extensions380332
Node: Fact tables381019
Node: Tabled evaluation382616
Node: Termination analysis394309
Node: Bibliography398522
Node: [1]399181
Node: [2]399607
Node: [3]399958
Node: [4]400291
Node: [5]400604

End Tag Table
