This is mercury_ref.info, produced by makeinfo version 4.11 from
reference_manual.texi_pp.

INFO-DIR-SECTION The Mercury Programming Language
START-INFO-DIR-ENTRY
* Mercury Language: (mercury_ref).  The Mercury Language Reference Manual.
END-INFO-DIR-ENTRY

   This file documents the Mercury programming language, version
rotd-2011-05-29.

   Copyright (C) 1995-2011 The University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


Indirect:
mercury_ref.info-1: 969
mercury_ref.info-2: 300605

Tag Table:
(Indirect)
Node: Top969
Node: Introduction3304
Node: Syntax5214
Node: Syntax Overview5596
Node: Tokens6367
Node: Terms12038
Node: Builtin Operators15520
Ref: Builtin Operators-Footnote-123107
Node: Items23146
Node: Declarations23918
Node: Facts24767
Node: Rules25549
Node: Goals26281
Node: State variables38312
Node: DCG-rules45303
Node: DCG-goals46590
Node: Data-terms51295
Node: Data-functors52407
Node: Record syntax54082
Node: Unification expressions57143
Node: Conditional expressions58212
Node: Lambda expressions58917
Node: Higher-order function applications61087
Node: Explicit type qualification61830
Node: Variable scoping62729
Node: Implicit quantification64784
Node: Elimination of double negation66200
Node: Types67112
Node: Builtin types67507
Node: User-defined types69147
Node: Discriminated unions69512
Node: Equivalence types73633
Node: Abstract types74530
Node: Predicate and function type declarations75266
Ref: Predicate and function type declarations-Footnote-181111
Node: Field access functions81494
Node: Field selection82294
Node: Field update83344
Node: User-supplied field access function declarations85105
Node: Field access examples87145
Node: Modes88881
Node: Insts modes and mode definitions89151
Node: Predicate and function mode declarations94683
Node: Constrained polymorphic modes101233
Node: Different clauses for different modes103941
Node: Unique modes108174
Node: Destructive update109381
Node: Backtrackable destructive update110806
Node: Limitations of the current implementation112336
Node: Determinism113266
Node: Determinism categories113646
Node: Determinism checking and inference118654
Node: Replacing compile-time checking with run-time checking127467
Node: Interfacing nondeterministic code with the real world129924
Node: Committed choice nondeterminism133297
Node: User-defined equality and comparison136230
Ref: User-defined equality and comparison-Footnote-1143765
Node: Higher-order144145
Node: Creating higher-order terms144796
Node: Calling higher-order terms149637
Node: Higher-order modes152678
Node: Modules156733
Node: The module system157003
Node: An example module160831
Node: Sub-modules162101
Node: Nested sub-modules162835
Node: Separate sub-modules164374
Node: Visibility rules166873
Node: Implementation bugs and limitations168196
Node: Module initialisation168893
Node: Module finalisation170428
Node: Module-local mutable variables171807
Node: Type classes176700
Node: Typeclass declarations177407
Node: Instance declarations180249
Node: Abstract typeclass declarations187542
Node: Abstract instance declarations188551
Node: Type class constraints on predicates and functions190129
Node: Type class constraints on type class declarations191817
Node: Type class constraints on instance declarations193840
Node: Functional dependencies195878
Node: Existential types201865
Node: Existentially typed predicates and functions202697
Node: Syntax for explicit type quantifiers203130
Node: Semantics of type quantifiers204673
Node: Examples of correct code using type quantifiers207527
Node: Examples of incorrect code using type quantifiers208810
Node: Existential class constraints209859
Node: Existentially typed data types211384
Node: Some idioms using existentially quantified types215032
Node: Exception handling219127
Node: Semantics223391
Node: Foreign language interface230499
Node: Calling foreign code from Mercury232168
Node: pragma foreign_proc232676
Node: Foreign code attributes237571
Node: Calling Mercury from foreign code245550
Node: Data passing conventions246611
Node: C data passing conventions247219
Node: C# data passing conventions250949
Node: Java data passing conventions255852
Node: Erlang data passing conventions261350
Node: Using foreign types from Mercury263668
Node: Using Mercury enumerations in foreign code267570
Node: Using foreign enumerations in Mercury code271255
Node: Adding foreign declarations273012
Node: Adding foreign definitions276515
Node: Language specific bindings277462
Node: Interfacing with C278556
Node: Using pragma foreign_type for C279573
Node: Using pragma foreign_export_enum for C282651
Node: Using pragma foreign_enum for C283635
Node: Using pragma foreign_proc for C284078
Node: Using pragma foreign_export for C286658
Node: Using pragma foreign_decl for C289295
Node: Using pragma foreign_code for C290863
Node: Memory management for C291426
Node: Linking with C object files293559
Node: Interfacing with C#294974
Node: Using pragma foreign_type for C#295743
Node: Using pragma foreign_export_enum for C#296448
Node: Using pragma foreign_enum for C#297134
Node: Using pragma foreign_proc for C#297548
Node: Using pragma foreign_export for C#299310
Node: Using pragma foreign_decl for C#300605
Node: Using pragma foreign_code for C#301471
Node: Interfacing with Java302458
Node: Using pragma foreign_type for Java303297
Node: Using pragma foreign_export_enum for Java304038
Node: Using pragma foreign_enum for Java304892
Node: Using pragma foreign_proc for Java305231
Node: Using pragma foreign_export for Java307061
Node: Using pragma foreign_decl for Java308384
Node: Using pragma foreign_code for Java309483
Node: Interfacing with Erlang310494
Node: Using pragma foreign_type for Erlang311074
Node: Using pragma foreign_proc for Erlang311613
Node: Using pragma foreign_export for Erlang312806
Node: Using pragma foreign_decl for Erlang314288
Node: Using pragma foreign_code for Erlang315349
Node: Impurity316140
Node: Purity levels318475
Node: Purity ordering320392
Node: Impurity semantics320691
Node: Declaring impurity323097
Node: Impure goals324490
Node: Promising purity326114
Node: Impurity Example328502
Node: Higher-order impurity329958
Node: Purity annotations on higher-order types330587
Node: Purity annotations on lambda expressions331679
Node: Purity annotations on higher-order calls332719
Node: Solver types334053
Node: The any inst334980
Node: Abstract solver type declarations335988
Node: Solver type definitions336468
Node: Implementing solver types340814
Node: Solver types and negated contexts342212
Node: Trace goals344924
Node: Pragmas354039
Node: Inlining355398
Node: Type specialization356108
Node: Syntax and semantics of type specialization pragmas356753
Node: When to use type specialization358013
Node: Implementation specific details358977
Node: Obsolescence359472
Node: No determinism warnings360612
Node: Source file name361793
Node: Implementation-dependent extensions363461
Node: Fact tables364411
Node: Tabled evaluation366008
Node: Termination analysis377977
Node: Feature sets382211
Node: Trailing385027
Node: Choice points386441
Node: Value trailing387390
Node: Function trailing388529
Node: Delayed goals and floundering391853
Node: Avoiding redundant trailing393595
Node: Bibliography400459
Node: [1]401118
Node: [2]401544
Node: [3]401895
Node: [4]402228
Node: [5]402541

End Tag Table
