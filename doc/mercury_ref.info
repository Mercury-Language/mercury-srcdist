This is mercury_ref.info, produced by makeinfo version 4.11 from
reference_manual.texi_pp.

INFO-DIR-SECTION The Mercury Programming Language
START-INFO-DIR-ENTRY
* Mercury Language: (mercury_ref).  The Mercury Language Reference Manual.
END-INFO-DIR-ENTRY

   This file documents the Mercury programming language, version
rotd-2009-11-10.

   Copyright (C) 1995-2009 The University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


Indirect:
mercury_ref.info-1: 969
mercury_ref.info-2: 299461

Tag Table:
(Indirect)
Node: Top969
Node: Introduction3363
Node: Syntax5273
Node: Syntax Overview5655
Node: Tokens6426
Node: Terms11777
Node: Builtin Operators15264
Ref: Builtin Operators-Footnote-122320
Node: Items22359
Node: Declarations23131
Node: Facts23965
Node: Rules24747
Node: Goals25479
Node: State variables34479
Node: DCG-rules40836
Node: DCG-goals42122
Node: Data-terms46827
Node: Data-functors47939
Node: Record syntax49614
Node: Unification expressions52675
Node: Conditional expressions53744
Node: Lambda expressions54449
Node: Higher-order function applications56619
Node: Explicit type qualification57362
Node: Variable scoping58261
Node: Implicit quantification60316
Node: Elimination of double negation61732
Node: Types62644
Node: Builtin types63056
Node: User-defined types64696
Node: Discriminated unions65061
Node: Equivalence types69182
Node: Abstract types70079
Node: Predicate and function type declarations70815
Ref: Predicate and function type declarations-Footnote-176660
Node: Field access functions77043
Node: Field selection77864
Node: Field update78914
Node: User-supplied field access function declarations80675
Node: Field access examples82715
Node: Solver types84451
Node: The any inst85376
Node: Abstract solver type declarations86386
Node: Solver type definitions86868
Node: Implementing solver types91216
Node: Solver types and negated contexts92616
Node: Modes95330
Node: Insts modes and mode definitions95600
Node: Predicate and function mode declarations101132
Node: Constrained polymorphic modes107682
Node: Different clauses for different modes110390
Node: Unique modes114623
Node: Destructive update115830
Node: Backtrackable destructive update117255
Node: Limitations of the current implementation118785
Node: Determinism119715
Node: Determinism categories120095
Node: Determinism checking and inference125103
Node: Replacing compile-time checking with run-time checking133916
Node: Interfacing nondeterministic code with the real world136373
Node: Committed choice nondeterminism139746
Node: User-defined equality and comparison142679
Ref: User-defined equality and comparison-Footnote-1150214
Node: Higher-order150594
Node: Creating higher-order terms151245
Node: Calling higher-order terms156086
Node: Higher-order modes159127
Node: Modules163182
Node: The module system163452
Node: An example module167280
Node: Sub-modules168550
Node: Nested sub-modules169284
Node: Separate sub-modules170823
Node: Visibility rules173322
Node: Implementation bugs and limitations174645
Node: Module initialisation175342
Node: Module finalisation176972
Node: Module-local mutable variables178444
Node: Type classes183429
Node: Typeclass declarations184136
Node: Instance declarations186978
Node: Abstract typeclass declarations194271
Node: Abstract instance declarations195280
Node: Type class constraints on predicates and functions196858
Node: Type class constraints on type class declarations198546
Node: Type class constraints on instance declarations200569
Node: Functional dependencies202607
Node: Existential types208594
Node: Existentially typed predicates and functions209426
Node: Syntax for explicit type quantifiers209859
Node: Semantics of type quantifiers211402
Node: Examples of correct code using type quantifiers214256
Node: Examples of incorrect code using type quantifiers215539
Node: Existential class constraints216588
Node: Existentially typed data types218113
Node: Some idioms using existentially quantified types221761
Node: Exception handling225856
Node: Semantics230113
Node: Foreign language interface237221
Node: Calling foreign code from Mercury239220
Node: pragma foreign_proc239728
Node: Foreign code attributes242992
Node: Calling Mercury from foreign code251008
Node: Data passing conventions252069
Node: C data passing conventions252684
Node: IL and C# data passing conventions255688
Node: Java data passing conventions258607
Node: Erlang data passing conventions262940
Node: Using foreign types from Mercury265258
Node: Using Mercury enumerations in foreign code269132
Node: Using foreign enumerations in Mercury code272817
Node: Adding foreign declarations274574
Node: Adding foreign definitions278077
Node: Language specific bindings279024
Node: Interfacing with C280371
Node: Using pragma foreign_type for C281257
Node: Using pragma foreign_export_enum for C283023
Node: Using pragma foreign_enum for C284007
Node: Using pragma foreign_proc for C284450
Node: Using pragma foreign_export for C287030
Node: Using pragma foreign_decl for C289667
Node: Using pragma foreign_code for C291235
Node: Memory management for C291798
Node: Interfacing with C#293895
Node: Using pragma foreign_type for C#294454
Node: Using pragma foreign_proc for C#294951
Node: Using pragma foreign_export for C#296720
Node: Using pragma foreign_decl for C#297046
Node: Using pragma foreign_code for C#297912
Node: Interfacing with IL298899
Node: Using pragma foreign_type for IL299461
Node: Using pragma foreign_proc for IL301902
Node: Using pragma foreign_export for IL303048
Node: Using pragma foreign_decl for IL305668
Node: Using pragma foreign_code for IL305988
Node: Interfacing with Java306265
Node: Using pragma foreign_type for Java307104
Node: Using pragma foreign_export_enum for Java307845
Node: Using pragma foreign_enum for Java308699
Node: Using pragma foreign_proc for Java309038
Node: Using pragma foreign_export for Java310836
Node: Using pragma foreign_decl for Java312159
Node: Using pragma foreign_code for Java313258
Node: Interfacing with Erlang314269
Node: Using pragma foreign_type for Erlang314849
Node: Using pragma foreign_proc for Erlang315388
Node: Using pragma foreign_export for Erlang316581
Node: Using pragma foreign_decl for Erlang318063
Node: Using pragma foreign_code for Erlang319124
Node: C interface319915
Node: Calling C code from Mercury321287
Node: pragma import322242
Node: pragma c_code324358
Node: Nondet pragma c_code327904
Node: C code attributes332646
Node: Purity and side effects334661
Node: Including C headers337128
Node: Including C code338161
Node: Calling Mercury code from C338634
Node: Linking with C object files341943
Node: Passing data to and from C343318
Node: Using C pointers343582
Node: Impurity345141
Node: Purity levels347445
Node: Purity ordering349362
Node: Impurity semantics349661
Node: Declaring impurity352067
Node: Impure goals353460
Node: Promising purity355084
Node: Impurity Example357472
Node: Higher-order impurity358928
Node: Purity annotations on higher-order types359557
Node: Purity annotations on lambda expressions360649
Node: Purity annotations on higher-order calls361689
Node: Trace goals363023
Node: Pragmas371161
Node: Inlining372343
Node: Type specialization373053
Node: Syntax and semantics of type specialization pragmas373698
Node: When to use type specialization374958
Node: Implementation specific details375922
Node: Obsolescence376417
Node: Source file name377550
Node: Implementation-dependent extensions379207
Node: Fact tables380157
Node: Tabled evaluation381754
Node: Termination analysis393437
Node: Feature sets397671
Node: Trailing400491
Node: Choice points401905
Node: Value trailing402854
Node: Function trailing403993
Node: Delayed goals and floundering407317
Node: Avoiding redundant trailing409059
Node: Bibliography415923
Node: [1]416582
Node: [2]417008
Node: [3]417359
Node: [4]417692
Node: [5]418005

End Tag Table
