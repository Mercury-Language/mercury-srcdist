This is mercury_ref.info, produced by makeinfo version 4.11 from
reference_manual.texi_pp.

INFO-DIR-SECTION The Mercury Programming Language
START-INFO-DIR-ENTRY
* Mercury Language: (mercury_ref).  The Mercury Language Reference Manual.
END-INFO-DIR-ENTRY

   This file documents the Mercury programming language, version
rotd-2010-01-31.

   Copyright (C) 1995-2010 The University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


Indirect:
mercury_ref.info-1: 969
mercury_ref.info-2: 300792

Tag Table:
(Indirect)
Node: Top969
Node: Introduction3363
Node: Syntax5273
Node: Syntax Overview5655
Node: Tokens6426
Node: Terms11777
Node: Builtin Operators15264
Ref: Builtin Operators-Footnote-122320
Node: Items22359
Node: Declarations23131
Node: Facts23965
Node: Rules24747
Node: Goals25479
Node: State variables35289
Node: DCG-rules41646
Node: DCG-goals42932
Node: Data-terms47637
Node: Data-functors48749
Node: Record syntax50424
Node: Unification expressions53485
Node: Conditional expressions54554
Node: Lambda expressions55259
Node: Higher-order function applications57429
Node: Explicit type qualification58172
Node: Variable scoping59071
Node: Implicit quantification61126
Node: Elimination of double negation62542
Node: Types63454
Node: Builtin types63866
Node: User-defined types65506
Node: Discriminated unions65871
Node: Equivalence types69992
Node: Abstract types70889
Node: Predicate and function type declarations71625
Ref: Predicate and function type declarations-Footnote-177470
Node: Field access functions77853
Node: Field selection78674
Node: Field update79724
Node: User-supplied field access function declarations81485
Node: Field access examples83525
Node: Solver types85261
Node: The any inst86186
Node: Abstract solver type declarations87196
Node: Solver type definitions87678
Node: Implementing solver types92026
Node: Solver types and negated contexts93426
Node: Modes96140
Node: Insts modes and mode definitions96410
Node: Predicate and function mode declarations101942
Node: Constrained polymorphic modes108492
Node: Different clauses for different modes111200
Node: Unique modes115433
Node: Destructive update116640
Node: Backtrackable destructive update118065
Node: Limitations of the current implementation119595
Node: Determinism120525
Node: Determinism categories120905
Node: Determinism checking and inference125913
Node: Replacing compile-time checking with run-time checking134726
Node: Interfacing nondeterministic code with the real world137183
Node: Committed choice nondeterminism140556
Node: User-defined equality and comparison143489
Ref: User-defined equality and comparison-Footnote-1151024
Node: Higher-order151404
Node: Creating higher-order terms152055
Node: Calling higher-order terms156896
Node: Higher-order modes159937
Node: Modules163992
Node: The module system164262
Node: An example module168090
Node: Sub-modules169360
Node: Nested sub-modules170094
Node: Separate sub-modules171633
Node: Visibility rules174132
Node: Implementation bugs and limitations175455
Node: Module initialisation176152
Node: Module finalisation177782
Node: Module-local mutable variables179254
Node: Type classes184239
Node: Typeclass declarations184946
Node: Instance declarations187788
Node: Abstract typeclass declarations195081
Node: Abstract instance declarations196090
Node: Type class constraints on predicates and functions197668
Node: Type class constraints on type class declarations199356
Node: Type class constraints on instance declarations201379
Node: Functional dependencies203417
Node: Existential types209404
Node: Existentially typed predicates and functions210236
Node: Syntax for explicit type quantifiers210669
Node: Semantics of type quantifiers212212
Node: Examples of correct code using type quantifiers215066
Node: Examples of incorrect code using type quantifiers216349
Node: Existential class constraints217398
Node: Existentially typed data types218923
Node: Some idioms using existentially quantified types222571
Node: Exception handling226666
Node: Semantics230926
Node: Foreign language interface238034
Node: Calling foreign code from Mercury240033
Node: pragma foreign_proc240541
Node: Foreign code attributes243805
Node: Calling Mercury from foreign code251821
Node: Data passing conventions252882
Node: C data passing conventions253497
Node: IL and C# data passing conventions256501
Node: Java data passing conventions259420
Node: Erlang data passing conventions264833
Node: Using foreign types from Mercury267151
Node: Using Mercury enumerations in foreign code271025
Node: Using foreign enumerations in Mercury code274710
Node: Adding foreign declarations276467
Node: Adding foreign definitions279970
Node: Language specific bindings280917
Node: Interfacing with C282264
Node: Using pragma foreign_type for C283150
Node: Using pragma foreign_export_enum for C284916
Node: Using pragma foreign_enum for C285900
Node: Using pragma foreign_proc for C286343
Node: Using pragma foreign_export for C288923
Node: Using pragma foreign_decl for C291560
Node: Using pragma foreign_code for C293128
Node: Memory management for C293691
Node: Interfacing with C#295788
Node: Using pragma foreign_type for C#296347
Node: Using pragma foreign_proc for C#296844
Node: Using pragma foreign_export for C#298613
Node: Using pragma foreign_decl for C#298939
Node: Using pragma foreign_code for C#299805
Node: Interfacing with IL300792
Node: Using pragma foreign_type for IL301354
Node: Using pragma foreign_proc for IL303795
Node: Using pragma foreign_export for IL304941
Node: Using pragma foreign_decl for IL307561
Node: Using pragma foreign_code for IL307881
Node: Interfacing with Java308158
Node: Using pragma foreign_type for Java308997
Node: Using pragma foreign_export_enum for Java309738
Node: Using pragma foreign_enum for Java310592
Node: Using pragma foreign_proc for Java310931
Node: Using pragma foreign_export for Java312729
Node: Using pragma foreign_decl for Java314052
Node: Using pragma foreign_code for Java315151
Node: Interfacing with Erlang316162
Node: Using pragma foreign_type for Erlang316742
Node: Using pragma foreign_proc for Erlang317281
Node: Using pragma foreign_export for Erlang318474
Node: Using pragma foreign_decl for Erlang319956
Node: Using pragma foreign_code for Erlang321017
Node: C interface321808
Node: Calling C code from Mercury323180
Node: pragma import324135
Node: pragma c_code326251
Node: Nondet pragma c_code329797
Node: C code attributes334539
Node: Purity and side effects336554
Node: Including C headers339021
Node: Including C code340054
Node: Calling Mercury code from C340527
Node: Linking with C object files343836
Node: Passing data to and from C345211
Node: Using C pointers345475
Node: Impurity347034
Node: Purity levels349338
Node: Purity ordering351255
Node: Impurity semantics351554
Node: Declaring impurity353960
Node: Impure goals355353
Node: Promising purity356977
Node: Impurity Example359365
Node: Higher-order impurity360821
Node: Purity annotations on higher-order types361450
Node: Purity annotations on lambda expressions362542
Node: Purity annotations on higher-order calls363582
Node: Trace goals364916
Node: Pragmas373054
Node: Inlining374236
Node: Type specialization374946
Node: Syntax and semantics of type specialization pragmas375591
Node: When to use type specialization376851
Node: Implementation specific details377815
Node: Obsolescence378310
Node: Source file name379443
Node: Implementation-dependent extensions381100
Node: Fact tables382050
Node: Tabled evaluation383647
Node: Termination analysis395330
Node: Feature sets399564
Node: Trailing402384
Node: Choice points403798
Node: Value trailing404747
Node: Function trailing405886
Node: Delayed goals and floundering409210
Node: Avoiding redundant trailing410952
Node: Bibliography417816
Node: [1]418475
Node: [2]418901
Node: [3]419252
Node: [4]419585
Node: [5]419898

End Tag Table
